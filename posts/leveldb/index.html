<!doctype html><html lang=en><head><title>LevelDB源码阅读 ::
Asky — My note blog
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="LevelDB: version 1.23 Date: Thu Oct 20 15:32:47 2022 CPU: 16 * AMD Ryzen 9 5900HS with Radeon Graphics CPUCache: 512 KB Keys: 16 bytes each Values: 100 bytes each (50 bytes after compression) Entries: 1000000 RawSize: 110.6 MB (estimated) FileSize: 62.9 MB (estimated) ------------------------------------------------ fillseq : 1.394 micros/op; 79.3 MB/s fillsync : 1208.178 micros/op; 0.1 MB/s (1000 ops) fillrandom : 1.948 micros/op; 56.8 MB/s overwrite : 2.448 micros/op; 45.2 MB/s readrandom : 3.251 micros/op; (864322 of 1000000 found) readrandom : 2.947 micros/op; (864083 of 1000000 found) readseq : 0.126 micros/op; 878.1 MB/s readreverse : 0.216 micros/op; 511.4 MB/s compact : 473557."><meta name=keywords content="程序员、码农、database、C++"><meta name=robots content="noodp"><link rel=canonical href=https://askyx.github.io/posts/leveldb/><link rel=stylesheet href=//cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/lxgwwenkaiscreen.css media=print onload='this.media="all"'><link rel=stylesheet href=https://askyx.github.io/assets/style.css><link rel=stylesheet href=https://askyx.github.io/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://askyx.github.io/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://askyx.github.io/favicon.ico><link rel=apple-touch-icon href=https://askyx.github.io/favicon.ico><link rel=bookmark href=https://askyx.github.io/favicon.ico><link rel=apple-touch-icon-precomposed sizes=180x180 href=https://askyx.github.io/favicon.ico><meta name=twitter:card content="summary"><meta name=twitter:title content="LevelDB源码阅读"><meta name=twitter:description content="leveldb 源码总结分析"><meta property="og:title" content="LevelDB源码阅读"><meta property="og:description" content="leveldb 源码总结分析"><meta property="og:type" content="article"><meta property="og:url" content="https://askyx.github.io/posts/leveldb/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-15T21:59:53+08:00"><meta property="article:modified_time" content="2022-05-15T21:59:53+08:00"></head><body class=light-theme><div class=container><header class=header><span class=header__inner><a href=https://askyx.github.io/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>Asky</span>
<span class=logo__cursor></span>
</a><span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about>About</a></li><li><a href=/archive>Archive</a></li><li><a href=/search>🔍</a></li><li><a href=javascript:; onclick=randomPost() title=随机访问一篇文章><svg t="1660103436159" class="icon search-box-icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="1184" width="32" height="32"><path d="M421.376 481.28s117.248 24.576 175.104-8.704c0 0-89.6 70.144-89.6 166.4.512-.512-8.192-121.344-85.504-157.696zm17.408 487.936s68.608 6.656 68.608-80.896c0 0 3.072 88.576 65.024 78.336.0.512-50.688 22.016-133.632 2.56zM161.28 238.08s-30.208 65.536 11.264 91.648c0 0-67.072-17.408-81.408 37.376.0.0 8.704-82.944 70.144-129.024zM857.6 227.328s49.152 50.176 1.024 81.408c0 0 58.88-18.432 66.56 36.352.0.0 5.12-69.632-67.584-117.76z" p-id="1185"/><path d="M443.392 970.752c-5.632.0-10.752-1.024-15.36-3.072L157.184 810.496l-1.536-1.024s-1.024-1.024-4.608-2.56c-51.2-29.184-62.976-94.208-65.536-120.832V386.56c0-3.072.512-7.168 1.024-11.264l.512-3.584 1.024-2.56c19.456-50.688 76.8-51.2 103.936-44.032l-1.536 5.632 4.096-6.144L476.16 486.4l18.944 37.888c20.992 36.864 29.184 77.824 32.768 99.84v258.048c-4.608 56.32-36.864 76.288-55.808 82.944-1.024.512-15.36 5.632-28.672 5.632zM181.248 774.656l263.168 152.576c12.288-.512 36.864-6.656 40.448-48.128V628.736c-4.608-31.744-20.992-103.936-72.192-128L322.56 445.44l1.536 3.072L181.76 366.08c-2.048-.512-40.448-9.216-52.736 15.872-.512 2.56-.512 4.608-.512 6.144v294.4c1.536 16.896 9.728 67.072 43.52 86.528 3.584 2.048 6.656 4.096 9.216 5.632z" p-id="1186"/><path d="M837.632 212.992c6.656 4.096 12.8 7.168 18.432 10.752l1.536 1.024 1.536 1.536c5.12 4.096 10.752 9.216 16.384 15.36 6.144 11.776 5.632 33.28 4.608 49.152-1.024 12.288-6.656 30.208-26.624 44.544l-1.024.512-247.808 156.672c-26.624 14.336-62.976 18.432-96.256 18.432-40.96.0-77.824-6.656-89.088-8.704l-3.072-.512-245.248-142.336c-39.424-29.696-28.16-85.504-15.36-113.664l2.56-6.144 263.68-166.912c29.184-14.336 104.448-43.008 173.056-1.024 3.584 2.56 58.368 34.304 119.296 69.632M431.616 460.8c40.448 7.168 114.176 13.824 152.576-6.144L828.928 299.52c7.168-5.632 8.192-10.24 8.704-12.8 1.024-11.264-9.728-26.624-15.36-32.768-55.808-32.256-243.712-141.312-250.368-145.408-49.664-30.72-107.008-9.216-130.048 2.56L192.512 268.8c-4.096 12.288-12.288 42.496 3.584 55.808L431.616 460.8z" p-id="1187"/><path d="M831.488 299.008c4.096-1.024 38.4-11.264 66.048 6.144 7.168 4.608 17.92 11.776 24.064 24.576 1.024 5.632 4.096 10.752 4.608 16.896v2.048l-1.024 323.072c-5.12 35.328-22.528 91.648-77.312 125.44l-5.12 3.584h-1.024L579.584 966.656l-4.608.512c-4.096.512-8.704 1.024-12.8 1.024-15.872.0-30.208-5.12-41.984-14.848-24.576-20.48-32.768-55.808-35.328-73.728l-1.024-252.928h1.536c6.144-96.768 88.576-164.864 96.768-171.008l-.512-.512L829.44 299.52M528.384 867.328c.512 10.24 5.12 41.472 19.968 53.76 3.072 2.56 7.68 5.632 16.384 5.12L829.44 758.272c56.32-38.4 53.76-115.712 53.76-116.224l-.512-32.256 1.024-250.368h-.512c-1.536-12.8-7.168-16.384-8.704-17.408-8.704-5.632-23.552-3.072-28.672-2.048L610.304 488.96c-1.024.512-80.896 65.024-80.896 149.504h-1.536l.512 228.864zM435.2 264.192c0 27.648 31.744 50.176 71.168 50.176s71.168-22.528 71.168-50.176-31.744-50.176-71.168-50.176S435.2 236.544 435.2 264.192z" p-id="1188"/><path d="M663.552 782.848c0 30.72-22.528 67.072-49.664 80.384-27.648 13.824-50.176-.512-50.176-31.232s22.528-67.072 50.176-80.384c27.136-13.824 49.664.0 49.664 31.232zM760.32 602.624c0 30.72-22.528 67.072-49.664 80.384-27.648 13.824-49.664-.512-49.664-31.232s22.528-67.072 49.664-80.384c27.136-13.824 49.664.512 49.664 31.232zM867.84 428.032c0 30.72-22.528 67.072-49.664 80.384C790.528 522.24 768 507.904 768 477.184s22.528-67.072 50.176-80.384c27.136-13.824 49.664.0 49.664 31.232zM270.848 538.112c0 30.72-22.016 41.984-48.64 24.576-27.136-16.896-48.64-55.808-48.64-86.528s22.016-41.984 48.64-24.576c26.624 16.896 48.64 55.808 48.64 86.528zm161.28 285.184c0 30.72-22.016 41.984-48.64 24.576-26.624-17.408-48.64-55.808-48.64-86.528s22.016-41.984 48.64-24.576c26.624 16.896 48.64 55.808 48.64 86.528z" p-id="1189"/></svg></a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about>About</a></li><li><a href=/archive>Archive</a></li><li><a href=/search>🔍</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><div class=post><div class=breadcrumb><li><a href=https://askyx.github.io/>首页</a></li><li><a href=https://askyx.github.io/posts/>Posts</a></li><li class=active><a href=https://askyx.github.io/posts/leveldb/>LevelDB源码阅读</a></li></div><h2 class=post-title><a href=https://askyx.github.io/posts/leveldb/>LevelDB源码阅读</a></h2><div class=post-meta><span class=post-date>2022-05-15</span></div><span class=post-tags><a href=https://askyx.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/>#源码阅读</a>&nbsp;
<a href=https://askyx.github.io/tags/leveldb/>#LevelDB</a>&nbsp;
<a href=https://askyx.github.io/tags/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/>#存储引擎</a>&nbsp;</span><div class=post-content><hr><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>LevelDB:    version <span style=color:#ae81ff>1.23</span>
</span></span><span style=display:flex><span>Date:       Thu Oct <span style=color:#ae81ff>20</span> <span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>32</span><span style=color:#f92672>:</span><span style=color:#ae81ff>47</span> <span style=color:#ae81ff>2022</span>
</span></span><span style=display:flex><span>CPU:        <span style=color:#ae81ff>16</span> <span style=color:#f92672>*</span> AMD Ryzen <span style=color:#ae81ff>9</span> <span style=color:#ae81ff>5900</span>HS with Radeon Graphics
</span></span><span style=display:flex><span>CPUCache:   <span style=color:#ae81ff>512</span> KB
</span></span><span style=display:flex><span>Keys:       <span style=color:#ae81ff>16</span> bytes each
</span></span><span style=display:flex><span>Values:     <span style=color:#ae81ff>100</span> bytes each (<span style=color:#ae81ff>50</span> bytes after compression)
</span></span><span style=display:flex><span>Entries:    <span style=color:#ae81ff>1000000</span>
</span></span><span style=display:flex><span>RawSize:    <span style=color:#ae81ff>110.6</span> MB (estimated)
</span></span><span style=display:flex><span>FileSize:   <span style=color:#ae81ff>62.9</span> MB (estimated)
</span></span><span style=display:flex><span><span style=color:#f92672>------------------------------------------------</span>
</span></span><span style=display:flex><span>fillseq      :       <span style=color:#ae81ff>1.394</span> micros<span style=color:#f92672>/</span>op;   <span style=color:#ae81ff>79.3</span> MB<span style=color:#f92672>/</span>s     
</span></span><span style=display:flex><span>fillsync     :    <span style=color:#ae81ff>1208.178</span> micros<span style=color:#f92672>/</span>op;    <span style=color:#ae81ff>0.1</span> MB<span style=color:#f92672>/</span>s (<span style=color:#ae81ff>1000</span> ops)
</span></span><span style=display:flex><span>fillrandom   :       <span style=color:#ae81ff>1.948</span> micros<span style=color:#f92672>/</span>op;   <span style=color:#ae81ff>56.8</span> MB<span style=color:#f92672>/</span>s     
</span></span><span style=display:flex><span>overwrite    :       <span style=color:#ae81ff>2.448</span> micros<span style=color:#f92672>/</span>op;   <span style=color:#ae81ff>45.2</span> MB<span style=color:#f92672>/</span>s     
</span></span><span style=display:flex><span>readrandom   :       <span style=color:#ae81ff>3.251</span> micros<span style=color:#f92672>/</span>op; (<span style=color:#ae81ff>864322</span> of <span style=color:#ae81ff>1000000</span> found)
</span></span><span style=display:flex><span>readrandom   :       <span style=color:#ae81ff>2.947</span> micros<span style=color:#f92672>/</span>op; (<span style=color:#ae81ff>864083</span> of <span style=color:#ae81ff>1000000</span> found)
</span></span><span style=display:flex><span>readseq      :       <span style=color:#ae81ff>0.126</span> micros<span style=color:#f92672>/</span>op;  <span style=color:#ae81ff>878.1</span> MB<span style=color:#f92672>/</span>s    
</span></span><span style=display:flex><span>readreverse  :       <span style=color:#ae81ff>0.216</span> micros<span style=color:#f92672>/</span>op;  <span style=color:#ae81ff>511.4</span> MB<span style=color:#f92672>/</span>s    
</span></span><span style=display:flex><span>compact      :  <span style=color:#ae81ff>473557.000</span> micros<span style=color:#f92672>/</span>op;
</span></span><span style=display:flex><span>readrandom   :       <span style=color:#ae81ff>2.174</span> micros<span style=color:#f92672>/</span>op; (<span style=color:#ae81ff>864105</span> of <span style=color:#ae81ff>1000000</span> found)
</span></span><span style=display:flex><span>readseq      :       <span style=color:#ae81ff>0.111</span> micros<span style=color:#f92672>/</span>op;  <span style=color:#ae81ff>997.1</span> MB<span style=color:#f92672>/</span>s    
</span></span><span style=display:flex><span>readreverse  :       <span style=color:#ae81ff>0.185</span> micros<span style=color:#f92672>/</span>op;  <span style=color:#ae81ff>598.0</span> MB<span style=color:#f92672>/</span>s    
</span></span><span style=display:flex><span>fill100K     :     <span style=color:#ae81ff>530.603</span> micros<span style=color:#f92672>/</span>op;  <span style=color:#ae81ff>179.8</span> MB<span style=color:#f92672>/</span>s (<span style=color:#ae81ff>1000</span> ops)
</span></span><span style=display:flex><span>crc32c       :       <span style=color:#ae81ff>0.904</span> micros<span style=color:#f92672>/</span>op; <span style=color:#ae81ff>4322.1</span> MB<span style=color:#f92672>/</span>s (<span style=color:#ae81ff>4</span>K per op)
</span></span><span style=display:flex><span>snappycomp   :       <span style=color:#ae81ff>2.353</span> micros<span style=color:#f92672>/</span>op; <span style=color:#ae81ff>1659.9</span> MB<span style=color:#f92672>/</span>s (output: <span style=color:#ae81ff>55.1</span><span style=color:#f92672>%</span>)
</span></span><span style=display:flex><span>snappyuncomp :       <span style=color:#ae81ff>0.390</span> micros<span style=color:#f92672>/</span>op; <span style=color:#ae81ff>10026.4</span> MB<span style=color:#f92672>/</span>s 
</span></span></code></pre></div><hr><pre><code>read: d019e3605f222ebc5a3a2484a2cb29db537551dd
</code></pre><p>小且完整的工业存储实现，其中有许多细节是可以借鉴的。这里没有完整的深入每一行代码，后续会时不时的慢慢补充</p><ul><li>2022-05-17 初步阅读代码，了解组件及大致执行逻辑</li><li>2022-10-20 重读部分代码，感觉自己貌似有了些许长进</li></ul><h2 id=编译>编译
<a href=#%e7%bc%96%e8%af%91 class=h-anchor aria-hidden=true>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>git clone --recurse-submodules https://github.com/google/leveldb.git
</span></span><span style=display:flex><span>cd leveldb
</span></span></code></pre></div><p><code>VSCode</code>安装<code>cmake</code>插件之后，打开项目，cmake插件自动配置，此时使用<code>shift+p</code>设置<code>cmake: set build target</code>之后，再使用<code>shift+p</code>选择<code>cmake: build</code>即可编译目标模块，d019e3605f222ebc5a3a2484a2cb29db537551dd中测试文件进行了调整，全部合并到<code>leveldb_tests</code>中，调试时按照想要了解的模块，自己注释其他测试文件，重新编译即可。此时可以在文件中断点调试，或者使用gdb调试</p><h2 id=slice>slice
<a href=#slice class=h-anchor aria-hidden=true>#</a></h2><p>字符串的浅拷贝实现，使用一个指针和指针长度实现，类似c++后来实现的string_view，如果使用string，则在传递数据的时候会进行拷贝操作，有性能损失。另一个目的是为了自主可控，确保数据在传输的过程中不会造成太多的数据副本。所以拷贝构造函数使用的是默认的系统函数，使用浅拷贝</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>Slice(<span style=color:#66d9ef>const</span> Slice<span style=color:#f92672>&amp;</span>) <span style=color:#f92672>=</span> <span style=color:#66d9ef>default</span>;
</span></span><span style=display:flex><span>Slice<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(<span style=color:#66d9ef>const</span> Slice<span style=color:#f92672>&amp;</span>) <span style=color:#f92672>=</span> <span style=color:#66d9ef>default</span>;
</span></span></code></pre></div><h2 id=status>status
<a href=#status class=h-anchor aria-hidden=true>#</a></h2><p>自定义信息模块，把状态码和状态信息进行压缩，压缩格式如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>Status<span style=color:#f92672>::</span>Status(Code code, <span style=color:#66d9ef>const</span> Slice<span style=color:#f92672>&amp;</span> msg, <span style=color:#66d9ef>const</span> Slice<span style=color:#f92672>&amp;</span> msg2) {
</span></span><span style=display:flex><span>  assert(code <span style=color:#f92672>!=</span> kOk);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>uint32_t</span> len1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint32_t</span><span style=color:#f92672>&gt;</span>(msg.size());
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>uint32_t</span> len2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint32_t</span><span style=color:#f92672>&gt;</span>(msg2.size());
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>uint32_t</span> size <span style=color:#f92672>=</span> len1 <span style=color:#f92672>+</span> (len2 <span style=color:#f92672>?</span> (<span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> len2) <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> result <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>char</span>[size <span style=color:#f92672>+</span> <span style=color:#ae81ff>5</span>];
</span></span><span style=display:flex><span>  std<span style=color:#f92672>::</span>memcpy(result, <span style=color:#f92672>&amp;</span>size, <span style=color:#66d9ef>sizeof</span>(size));
</span></span><span style=display:flex><span>  result[<span style=color:#ae81ff>4</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span>(code);
</span></span><span style=display:flex><span>  std<span style=color:#f92672>::</span>memcpy(result <span style=color:#f92672>+</span> <span style=color:#ae81ff>5</span>, msg.data(), len1);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (len2) {
</span></span><span style=display:flex><span>    result[<span style=color:#ae81ff>5</span> <span style=color:#f92672>+</span> len1] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;:&#39;</span>;
</span></span><span style=display:flex><span>    result[<span style=color:#ae81ff>6</span> <span style=color:#f92672>+</span> len1] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39; &#39;</span>;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>memcpy(result <span style=color:#f92672>+</span> <span style=color:#ae81ff>7</span> <span style=color:#f92672>+</span> len1, msg2.data(), len2);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  state_ <span style=color:#f92672>=</span> result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>TIPS: 对于数字，之际拷贝地址可以直接序列化，不需要使用 to_string，取数的时候直接取字节码，然后static_cast就可以了</p></blockquote><h2 id=数值编码>数值编码
<a href=#%e6%95%b0%e5%80%bc%e7%bc%96%e7%a0%81 class=h-anchor aria-hidden=true>#</a></h2><p>leveldb中几乎所有的数据都会和数据格式的编码或多或少的有联系，首先数据的存储不能直接简单的to_string然后存储字符串，其次对于整形的变长编码，他会把数据的二进制编码按7拆分，在每个字节的第一位使用1表示是否为数据的结尾，例如<code>int(1)</code>编码为<code>00000001</code>，<code>11 10101010</code>会编码为<code>10101010 00000111</code>，对应压缩和解压代码如下，变长编码是一种编程技巧，int类型是4字节，long是8字节。当存储的数据小的时候。可以节约空间。并且我们有理由相信，程序中大部分场景使用的是小数字。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>EncodeVarint32</span>(<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> dst, <span style=color:#66d9ef>uint32_t</span> v) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Operate on characters as unsigneds
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>*</span> ptr <span style=color:#f92672>=</span> <span style=color:#66d9ef>reinterpret_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>*&gt;</span>(dst);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> B <span style=color:#f92672>=</span> <span style=color:#ae81ff>128</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (v <span style=color:#f92672>&lt;</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>7</span>)) {
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>(ptr<span style=color:#f92672>++</span>) <span style=color:#f92672>=</span> v;
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (v <span style=color:#f92672>&lt;</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>14</span>)) {
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>(ptr<span style=color:#f92672>++</span>) <span style=color:#f92672>=</span> v <span style=color:#f92672>|</span> B;
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>(ptr<span style=color:#f92672>++</span>) <span style=color:#f92672>=</span> v <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>7</span>;
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (v <span style=color:#f92672>&lt;</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>21</span>)) {
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>(ptr<span style=color:#f92672>++</span>) <span style=color:#f92672>=</span> v <span style=color:#f92672>|</span> B;
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>(ptr<span style=color:#f92672>++</span>) <span style=color:#f92672>=</span> (v <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>7</span>) <span style=color:#f92672>|</span> B;
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>(ptr<span style=color:#f92672>++</span>) <span style=color:#f92672>=</span> v <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>14</span>;
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (v <span style=color:#f92672>&lt;</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>28</span>)) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> GetVarint32PtrFallback(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> p, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> limit,
</span></span><span style=display:flex><span>                                   <span style=color:#66d9ef>uint32_t</span><span style=color:#f92672>*</span> value) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint32_t</span> result <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>uint32_t</span> shift <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; shift <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>28</span> <span style=color:#f92672>&amp;&amp;</span> p <span style=color:#f92672>&lt;</span> limit; shift <span style=color:#f92672>+=</span> <span style=color:#ae81ff>7</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span> byte <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(<span style=color:#66d9ef>reinterpret_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>*&gt;</span>(p));
</span></span><span style=display:flex><span>    p<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (byte <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>128</span>) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// More bytes are present
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      result <span style=color:#f92672>|=</span> ((byte <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>127</span>) <span style=color:#f92672>&lt;&lt;</span> shift);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      result <span style=color:#f92672>|=</span> (byte <span style=color:#f92672>&lt;&lt;</span> shift);
</span></span><span style=display:flex><span>      <span style=color:#f92672>*</span>value <span style=color:#f92672>=</span> result;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>reinterpret_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*&gt;</span>(p);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>除了变长之外，还有定长编码，以及对应的32位，64位的实现等，在实际的数据处理中，会有记录数据长度等操作，就会使用编码操作，把数值编码到数据中。定长编码是直接存储字节序。</p><h2 id=arena>Arena
<a href=#arena class=h-anchor aria-hidden=true>#</a></h2><p>自定义内存池，设计思路是申请内存和分配内存隔离，申请内存的时候多申请，分配内存的时候从已申请的内存中分配，使用vector维护内存空间，LevelDB中在memtable中使用，理论上可以用在任何想使用的组件中，但是实际上数据变动最多的地方是memtable，所以暂时只发现只有这里使用。</p><ul><li>对于大空间(大于kBlockSize / 4的空间，大于kBlockSize = 4096)，则直接申请，独占一个block，不受block大小的限制，且不改变之前记录的block的指针状态</li><li>对于小空间<ul><li>第一次会申请大小为4k的空间，然后记录当前空间的指针及空间使用情况，然后从空间上分配内存，且空间push到vector中</li><li>之后的空间申请如果在当前block上可以继续分配，则在block上直接分配</li><li>如果不满足条件，则重新分配，之前残留的空间直接丢弃，且不计入使用空间统计</li></ul></li><li>对于空间的统计情况，使用原子变量<code>std::atomic&lt;size_t> memory_usage_;</code>记录，因为Arena在skiplist中使用的时候，可能有并发的情况</li></ul><blockquote><p>TIPS: 原子类型的细节需要调研</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span> pool <span style=color:#f92672>=</span> area<span style=color:#f92672>-&gt;</span>Allocate(size);               <span style=color:#75715e>// 不对齐的申请
</span></span></span><span style=display:flex><span><span style=color:#75715e>// char * pool = area-&gt;AllocateAligned(size);     // 申请对齐的空间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>auto</span> mem <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> (pool) <span style=color:#66d9ef>char</span>(size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Allocate(size) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (size <span style=color:#f92672>&lt;</span> alloc_bytes_remaining_) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> result <span style=color:#f92672>=</span> alloc_ptr_;
</span></span><span style=display:flex><span>    alloc_ptr_ <span style=color:#f92672>+=</span> bytes;
</span></span><span style=display:flex><span>    alloc_bytes_remaining_ <span style=color:#f92672>-=</span> bytes;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>AllocateFallback</span>(size);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=skiplist>SkipList
<a href=#skiplist class=h-anchor aria-hidden=true>#</a></h2><p>来自论文<a href=https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.>Skip lists: a probabilistic alternative to balanced trees</a>，其中介绍了跳表的实现和其他不同结构之间的对比情况，</p><blockquote><p>需要重修概率论</p></blockquote><p>跳表使用使用概率均衡的技术，大部分操作都可以实现<code>O(log n)</code>的时间复杂度，可以参考上面的文章，这里总结几个点</p><ol><li>跳表可以简单的理解为链表的+index的实现，index的目的是为了快速的查找数据</li><li>跳表在增加节点的时候，使用概率为0.25来确定使得否增加下一层，在这个概率下，空间需要花费的代价为<code>(cost(node) * 1.33)</code></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> kBranching <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> height <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (height <span style=color:#f92672>&lt;</span> kMaxHeight <span style=color:#f92672>&amp;&amp;</span> rnd_.OneIn(kBranching)) {
</span></span><span style=display:flex><span>    height<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><ol start=3><li>查找的时间复杂度可以抽象的理解为二分查找的<code>O(log n)</code></li><li>跳表的操作的时间复杂度和红黑树几乎差不多，但是有一点功能是红黑树无法实现的，即<code>range search</code>，红黑树由于结构特性，无法进行类似的操作，跳表可以定位node之后，可以根据node间的链接实现顺序遍历</li><li>insert的时候先查找位置，然后按概率计算层高，再进行插入
<img src=/posts/readbooks/images/skiplist.png alt=skiplist></li><li>容易实现并发操作，并发的时候只需要对极少的节点加锁即可，但是红黑树由于需要变形旋转需要对整棵树加锁，所以这也是大部分存储使用skiplist的作为memtable的理由之一<br>1. <a href=https://www.bookstack.cn/read/Cpp_Concurrency_In_Action/README.md>c++并发编程</a><br>2. 三种并发<ol><li>max_heights_ 使用memory_order_relaxed，skiplist只允许一写多读，max_height_只有写才会改变</li><li>insert设置新节点的next，使用NoBarrier_Next和NoBarrier_SetNext操作，此时对node使用memory_order_relaxed操作，此时其他线程无法看见新节点</li><li>insert设置新节点的forward，此时使用SetNext的memory_order_release，此时所有线程可以看见新节点<br>但是由于skiplist 分层，所以此时只能看见当前插入的这一层，而查询是需要从顶层往下查的，所以insert需要从底层开始，否则可能出现上层查询节点存在，但是下层不存在</li></ol></li><li>leveldb中，skiplist没有delete操作，如果需要实现，则需要实现类似insert中的部分操作，查找到pre，在设置节点即可。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Key, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Comparator</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> SkipList<span style=color:#f92672>&lt;</span>Key, Comparator<span style=color:#f92672>&gt;::</span>Insert(<span style=color:#66d9ef>const</span> Key<span style=color:#f92672>&amp;</span> key) {
</span></span><span style=display:flex><span>  Node<span style=color:#f92672>*</span> prev[kMaxHeight];
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 设置pre，从顶层开始查找，记录的是每一层的当前节点的pre节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Node<span style=color:#f92672>*</span> x <span style=color:#f92672>=</span> FindGreaterOrEqual(key, prev);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  assert(x <span style=color:#f92672>==</span> <span style=color:#66d9ef>nullptr</span> <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>Equal(key, x<span style=color:#f92672>-&gt;</span>key));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//   随即高度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> height <span style=color:#f92672>=</span> RandomHeight();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (height <span style=color:#f92672>&gt;</span> GetMaxHeight()) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果高度比之前的高，则把prev之前高度节点到height之间的node设置为head_
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> GetMaxHeight(); i <span style=color:#f92672>&lt;</span> height; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>      prev[i] <span style=color:#f92672>=</span> head_;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    max_height_.store(height, std<span style=color:#f92672>::</span>memory_order_relaxed);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  x <span style=color:#f92672>=</span> NewNode(key, height);
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 使用height设置当前节点和pre以及next阶段之间的链接
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> height; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    x<span style=color:#f92672>-&gt;</span>NoBarrier_SetNext(i, prev[i]<span style=color:#f92672>-&gt;</span>NoBarrier_Next(i));
</span></span><span style=display:flex><span>    prev[i]<span style=color:#f92672>-&gt;</span>SetNext(i, x);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=8><li><code>std::atomic&lt;Node*> next_[1];</code>，不能是<code>next_[0]</code>，因为0的时候sizeof不计算这位，大小不对，不能是二级指针，因为此时next在后续的使用中，上层next_是nullptr，无法直接操作，只有使用数组提前占位，才可以设置node，自己手写的时候需要注意。也可以再insert的时候注意于head的相对关系。</li></ol><h2 id=memtable>MemTable
<a href=#memtable class=h-anchor aria-hidden=true>#</a></h2><p>SkipList的封装，长期处于内存中，活动的table只有一个，满的之后冻结落盘。基础操作为add和get，使用MemTableIterator访问memtable。<br>MemTableIterator是SkipList的迭代器的封装。持有一个跳表和node，使用SeekToFirst和SeekToLast定位node之后，开始使用</p><ol><li>add编码数据和类型以及长度和key等，拼接为一个buffer，然后insert到skiplist中</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>// Format of an entry is concatenation of:
</span></span></span><span style=display:flex><span><span style=color:#75715e>//  key_size     : varint32 of internal_key.size()
</span></span></span><span style=display:flex><span><span style=color:#75715e>//  key bytes    : char[internal_key.size()]
</span></span></span><span style=display:flex><span><span style=color:#75715e>//  tag          : uint64((sequence &lt;&lt; 8) | type)
</span></span></span><span style=display:flex><span><span style=color:#75715e>//  value_size   : varint32 of value.size()
</span></span></span><span style=display:flex><span><span style=color:#75715e>//  value bytes  : char[value.size()]
</span></span></span></code></pre></div><ol start=2><li>使用迭代器seek到node，然后获得数据，解码，判断数据类型</li></ol><h2 id=dbimpl>DBImpl
<a href=#dbimpl class=h-anchor aria-hidden=true>#</a></h2><p>DB的具体实现，对外接口使用DB对象，但是内部实际调用的还是DBImpl实例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>Status DBImpl<span style=color:#f92672>::</span>Put(<span style=color:#66d9ef>const</span> WriteOptions<span style=color:#f92672>&amp;</span> o, <span style=color:#66d9ef>const</span> Slice<span style=color:#f92672>&amp;</span> key, <span style=color:#66d9ef>const</span> Slice<span style=color:#f92672>&amp;</span> val) {
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> DB<span style=color:#f92672>::</span>Put(o, key, val);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Status DBImpl<span style=color:#f92672>::</span>Delete(<span style=color:#66d9ef>const</span> WriteOptions<span style=color:#f92672>&amp;</span> options, <span style=color:#66d9ef>const</span> Slice<span style=color:#f92672>&amp;</span> key) {
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> DB<span style=color:#f92672>::</span>Delete(options, key);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol><li>新建</li><li>恢复</li><li>写<br>1. 使用WriteBatch打包一批写入数据
2. 限制一写多读，WriteBatch会添加到队列，等待写入消耗
3. 写入会有多种中间状况<ol><li>当前正在L0的compact，此时如果不是强制异步写，则需要等待1s让出资源，等待compact完成，但是最多只能等待一次</li><li>mem空间不足，需要进行 compact， 等待</li><li>L0 SST超过限制，等待compact</li></ol><blockquote><p>这里几条应该是写入的最大的性能瓶颈，RocksDB中应该有解决的方案，后续可以看看他的写入流程</p></blockquote></li><li>读<br>1. 三层读取。存在读放大的问题<br>2. 先都memtable
3. 再都inmem
4. 读取L0层
5. 读取其他层
6. 读取文件上的数据的时候使用<code>Version::Get</code>，内部先从L0开始，然后在依次向下读取，能进行key的比对的依据是version中保存文件的FileMetaData</li><li>compact</li><li>lock机制</li></ol><h2 id=writebatch>WriteBatch
<a href=#writebatch class=h-anchor aria-hidden=true>#</a></h2><p><img src=/posts/readbooks/images/xx.webp alt></p><p>写操作的主要操作对象，主要步骤是把操作的数据打包为一个buffer，然后使用<code>WriteBatch::Iterate</code>操作handler实现insert操作，hanle是一个实现put和delete的接口，所以这里是把数据和操作分离了，这里有几点细节</p><ol><li>WriteBatch的数据格式为 <code>seq|countkey|{type|key|val}</code>，batch添加一个数据的时候，除了正常添加数据，还会count++，用于在<code>WriteBatch::Iterate</code>的时候检测当前批次数据数量是否正确</li><li>一个batch的数据只有一个sequence，batch写完之后，数值加一，</li><li>有標記控制是否使用使用同步寫。默認為同步寫，異步寫入的速度快，但是可能導致系統崩潰的時候丟數據，所以爲了分攤大量數據的同步寫的cost，這裏設計WriteBatch來打包數據，進行一次同步寫操作，因爲是順序寫入磁盤，所以寫入速度可以接受</li><li>写入操作具有原子性，在写数据的时候会先写日志然后再写数据，当写日志之前或者写日志过程中宕机，下次重启时恢复数据库的时候直接丢弃异常日志。或者写完日志之后宕机，系统在下次启动之后都是确保数据的原子性，</li></ol><h2 id=posixenv>PosixEnv
<a href=#posixenv class=h-anchor aria-hidden=true>#</a></h2><p>posix环境资源的实现，继承自env，目的是便于实现不同平台下的代码，</p><ul><li>线程池，一个简单的例子 <a href=https://github.com/progschj/ThreadPool>https://github.com/progschj/ThreadPool</a></li><li>日志</li><li>文件</li></ul><h2 id=wal日志>WAL日志
<a href=#wal%e6%97%a5%e5%bf%97 class=h-anchor aria-hidden=true>#</a></h2><blockquote><p><a href=https://leveldb-handbook.readthedocs.io/zh/latest/journal.html>https://leveldb-handbook.readthedocs.io/zh/latest/journal.html</a></p></blockquote><p>日志在写数据之前记录，写完之后立刻flush，之后才是真正的写数据到memtable，日志文件会一直保存，直到数据落盘才删除，即memtable变为immemtable且compact(数据落盘)之后才删除，如果期间系统异常，则日志文件保存，到下次重启之后回复之后才删除，</p><p>(log::Writer)<br>写数据之前需要预写日志，目的是为了保证数据安全，在操作数据异常的时候可以使用日志恢复数据，按block划分，一个block大小为32k，一个block有四种状态</p><ol><li>kFullType<br>一个block可以存完数据</li><li>kFirstType<br>一个block存不下数据，标记为第一个block</li><li>kLastType<br>最后一个block</li><li>kMiddleType<br>中间的block</li></ol><p>每一个block中的数据的组织格式为<code>crc|len(2)|type(1)|values</code>，其中values的数据来自于前面的WriteBatch打包的数据，是一个整体，没有做太多的处理，主要的调用方法为</p><ul><li>DBImpl::Write</li><li>DBImpl::NewDB</li><li>VersionSet::LogAndApply</li><li>VersionSet::WriteSnapshot</li></ul><p>(log::Reader)<br>wal对应的读取操作</p><h2 id=lrucache>LRUCache
<a href=#lrucache class=h-anchor aria-hidden=true>#</a></h2><blockquote><p><a href=https://leveldb-handbook.readthedocs.io/zh/latest/cache.html>https://leveldb-handbook.readthedocs.io/zh/latest/cache.html</a></p></blockquote><p>缓存模块，测试文件为<code>cache_test.cc</code>。</p><ul><li><p>ShardedLRUCache<br>LRUHandle的包装，主要原因是LRUHandle的接口都加锁，所以这里使用ShardedLRUCache包装一下，使用16个LRUHandle来管理缓存，以提高并发时候的操作效率。<code>uint32_t Shard(uint32_t hash) { return hash >> (32 - kNumShardBits); }</code>会使用前4个bit计算位置，得到对应的LRUHandle对象，之后的操作使用此对象处理，相当于LRUHandle的hash表。</p></li><li><p>LRUCache</p><blockquote><p><a href=https://leetcode.cn/problems/lru-cache/>https://leetcode.cn/problems/lru-cache/</a></p></blockquote><p>LRU的实现，使用HandleTable作为hash表保存的数据。LRUHandle为链表保存数据，主要细节为</p><ul><li>使用hash表保存数据</li><li>使用一个LRUHandle维护使用情况，数据在缓存中的时候，要么只是在缓存中，保存在lru_链表中，或者是使用中的数据，保存在<code>in_use_</code>中</li><li>使用引用标记数据的使用，只有当引用为0的时候，才会删除数据，当数据存在在缓存中的时候，引用默认为1，为0则表示不缓存且没有外部引用</li><li>对于重复的key，会直接替换</li><li>容量不足的时候。替换lru_中的数据，<code>in_use_</code>中的数据不操作</li><li>链表在append的时候，总是添加在链表头节点</li></ul></li><li><p>LRUHandle<br>双向链表，在hash表中会保存数据，在LRU中会维护使用情况，</p><ul><li>remove，直接设置链接，跳过当前节点</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>void</span> LRUCache<span style=color:#f92672>::</span>LRU_Remove(LRUHandle<span style=color:#f92672>*</span> e) {
</span></span><span style=display:flex><span>  e<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> e<span style=color:#f92672>-&gt;</span>prev;
</span></span><span style=display:flex><span>  e<span style=color:#f92672>-&gt;</span>prev<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> e<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>LRU_Append，insert操作，把节点append在链表之前</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>void</span> LRUCache<span style=color:#f92672>::</span>LRU_Append(LRUHandle<span style=color:#f92672>*</span> list, LRUHandle<span style=color:#f92672>*</span> e) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Make &#34;e&#34; newest entry by inserting just before *list
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  e<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> list;
</span></span><span style=display:flex><span>  e<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> list<span style=color:#f92672>-&gt;</span>prev;
</span></span><span style=display:flex><span>  e<span style=color:#f92672>-&gt;</span>prev<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> e;
</span></span><span style=display:flex><span>  e<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> e;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>HandleTable
LRUHandle的二维数组，使用连地址法来处理冲突，基础容量为4，rehash按2扩充空间</p></li></ul><p>缓存有两种，一种是用来缓存的打开的SST table的cache，一种是用来缓存使用的block的cache</p><h2 id=sst>SST
<a href=#sst class=h-anchor aria-hidden=true>#</a></h2><p><img src=/posts/readbooks/images/image.png alt=格式圖>
具體格式如圖，文件最后是footer，保存mata和index的大小和偏移，</p><ul><li><p>footer (<code>Footer::EncodeTo</code>)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>  int64 <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>|</span> mata
</span></span><span style=display:flex><span>  int64 <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>|</span> index
</span></span><span style=display:flex><span>  padding
</span></span><span style=display:flex><span>  magicnum
</span></span></code></pre></div></li><li><p>BlockBuilder<br>磁盘读写按照一定大小读取比较有效率，leveldb按照4K大小组织文件，4K为一个block，block按照一个一个的条目编码数据，格式为<code>slen|uslen|vlen|uskey|v</code>，s指的是share，如下的例子</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    string key1 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;abcd&#34;</span>, v1 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;vv1vv&#34;</span>;
</span></span><span style=display:flex><span>    string key2 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;abce&#34;</span>, v2 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;vv2vv&#34;</span>;
</span></span><span style=display:flex><span>    string key3 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;abxf&#34;</span>, v3 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;vv3vv&#34;</span>;
</span></span><span style=display:flex><span>    encode <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>5</span> abcd vv1vv <span style=color:#f92672>|</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>5</span> e vv2vv <span style=color:#f92672>|</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>5</span> xf vv3vv}
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>第一个记录不编码，第二个和第一个对比，编码存取，key抽取相同的前缀，记录长度，之后的数据都按前一个数据编码，如果数据太多，可能后面的key和之前的key差距比较大，查找的时候只能全部解码然后寻找key，所以设计可以控制每隔固定数量的key存一个完整的key，称为重启点，按重启点划分为不同的group，此时且记录key的偏移，此时查找的时候可以按照偏移取key然后使用二分查找等方式快速查寻。在持久化的时候，block末尾记录group的大小，再使用一个bit记录压缩格式，再使用4个bit记录crc。这就是block的基本格式
除了footer使用单独的编码格式之外。其余的mata，index，data都使用block的格式编码数据，
block 是一个读写单位，所以如果使用场景大量批量读写，则可以适当增加block size，如果单点读写比较多，则可以减少block size， 这要平衡</p><ul><li>写入流程</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>TableBuilder<span style=color:#f92672>::</span>Add
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (r<span style=color:#f92672>-&gt;</span>pending_index_entry)   <span style=color:#75715e>//  新的block设置index
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    index_block.Add
</span></span><span style=display:flex><span>  filter_block<span style=color:#f92672>-&gt;</span>AddKey          <span style=color:#75715e>//  设置filter
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  data_block.Add                <span style=color:#75715e>// 添加数据到data_block，如果大小达到限制，flush
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (estimated_block_size <span style=color:#f92672>&gt;=</span> r<span style=color:#f92672>-&gt;</span>options.block_size)
</span></span><span style=display:flex><span>    TableBuilder<span style=color:#f92672>::</span>Flush()
</span></span><span style=display:flex><span>      TableBuilder<span style=color:#f92672>::</span>WriteBlock    <span style=color:#75715e>// 写block 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        BlockBuilder<span style=color:#f92672>::</span>Finish      <span style=color:#75715e>// 打包数据，编码group offset
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        compression               <span style=color:#75715e>//  压缩
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        TableBuilder<span style=color:#f92672>::</span>WriteRawBlock <span style=color:#75715e>//  写压缩之后的数据，设置编码格式和crc
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    r<span style=color:#f92672>-&gt;</span>pending_index_entry <span style=color:#f92672>=</span> true;  <span style=color:#75715e>//  设置标记为true，记录index
</span></span></span></code></pre></div><ul><li><p>读取流程<br>讀取的時候逆向操作，校監crc</p></li><li><p>index
index的一個條目對應的是一個datablock中的最大的key以及block的偏移和大小，key使用FindShortestSeparator計算得出，確保他計算的key是當前保存的datablock中的最大值加1，目的是便於查找</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>  start: abcdef
</span></span><span style=display:flex><span>  limit: abcdgh
</span></span><span style=display:flex><span>  FindShortestSeparator<span style=color:#f92672>--&gt;</span> start <span style=color:#f92672>=</span> abcdf  <span style=color:#75715e>// 公共前綴加1
</span></span></span></code></pre></div></li></ul><hr><ul><li>immemtable的寫入</li></ul><blockquote><p><a href=https://hardcore.feishu.cn/docs/doccn4w8clvork96K3dqQnJRh9g#>https://hardcore.feishu.cn/docs/doccn4w8clvork96K3dqQnJRh9g#</a>
<a href=https://my.oschina.net/fileoptions/blog/903206>https://my.oschina.net/fileoptions/blog/903206</a></p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>
</span></span><span style=display:flex><span>WriteLevel0Table
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    mutex_.Unlock();    <span style=color:#75715e>// 不加鎖是因爲immemtable不可變，所以沒有并發問題
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    s <span style=color:#f92672>=</span> BuildTable(dbname_, env_, options_, table_cache_, iter, <span style=color:#f92672>&amp;</span>meta);
</span></span><span style=display:flex><span>    BuildTable :{
</span></span><span style=display:flex><span>      <span style=color:#75715e>// get file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// add values
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      builder<span style=color:#f92672>-&gt;</span>Add(key, iter<span style=color:#f92672>-&gt;</span>value());
</span></span><span style=display:flex><span>      s <span style=color:#f92672>=</span> builder<span style=color:#f92672>-&gt;</span>Finish();
</span></span><span style=display:flex><span>      Finish: {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// filter
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// metaindex
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// index
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// footer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      }
</span></span><span style=display:flex><span>      file<span style=color:#f92672>-&gt;</span>sync();
</span></span><span style=display:flex><span>      file<span style=color:#f92672>-&gt;</span>close();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    mutex_.Lock();
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>具體的細節可以參考代碼的文檔，</p><h2 id=迭代器>迭代器
<a href=#%e8%bf%ad%e4%bb%a3%e5%99%a8 class=h-anchor aria-hidden=true>#</a></h2><p>訪問特定數據結構的抽象，使數據的訪問和存儲分離，可以參考STL的實現，levelDB中對不同的組件實現不同的迭代器</p><ul><li>MemTableIterator</li><li>LevelFileNumIterator</li><li>Block::Iter</li></ul><h2 id=version>version
<a href=#version class=h-anchor aria-hidden=true>#</a></h2><blockquote><p><a href=https://leveldb-handbook.readthedocs.io/zh/latest/version.html>https://leveldb-handbook.readthedocs.io/zh/latest/version.html</a></p></blockquote><p>本质上是使用版本号组成key，用来查询数据，之前数据存放的时候，是有记录seq的，version是专为这种行为设计的系统，<br>需要管理磁盘文件的版本，不同的版本使用不同的Sequence，key中含有LastSequence信息，所以本质上还是key的查询</p><ul><li>get<br>需要读取磁盘中的文件，version中保存FileMetaData，所以可以快速的定位数据的sst，然后直接读取sst，对于L0，由于存在重复key，所以
需要进行key的比较，读取多个文件</li></ul><h2 id=compact>compact
<a href=#compact class=h-anchor aria-hidden=true>#</a></h2><p>定期的数据的整理合并操作</p><hr><ul><li>minor compaction<br>immemtable持久化为SST，可以手动使用TEST_CompactMemTable触发，主要方式是设置<code>DBImpl::Write</code>的WriteBatch参数为null，此时在<code>MakeRoomForWrite</code>中，会根据参数导致选择compact的分支，会进行CompactMemTable操作，此时之前的数据会固化到文件中。也可以自动触发，当memtable 满了之后，会进行相同的操作。<ul><li>TIPS: 此时version中会保存SST的相关信息，包括beginkey和endkey，以及版本信息</li><li>文件不一定是level0，对于大文件，预测level0可能很快到达限制，可以在一定条件下直接把文件放在较高层。</li></ul></li></ul><hr><ul><li>Major Compaction<br>sst之间向下合并，其会把相同key的不同版本的数据合并，可以手动使用TEST_CompactRange触发，此时可以选择需要compact的level和start key和endkey，他会把文件向下层合并，这里需要注意的是<ul><li>level0会有重叠的key，compact的时候需要选择beginkey endkey以及他中间覆盖的文件进行compact操作，否则会残留下old key，</li><li>sst不一定是向下推一层，可以选择想要合并的层数，对于level 0，使用文件个数计算score，对于其他层，使用文件大小计算</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> level <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; level <span style=color:#f92672>&lt;</span> config<span style=color:#f92672>::</span>kNumLevels <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; level<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> score;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (level <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We treat level-0 specially by bounding the number of files
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// instead of number of bytes for two reasons:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// (1) With larger write-buffer sizes, it is nice not to do too
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// many level-0 compactions.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// (2) The files in level-0 are merged on every read and
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// therefore we wish to avoid too many files when the individual
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// file size is small (perhaps because of a small write-buffer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// setting, or very high compression ratios, or lots of
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// overwrites/deletions).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    score <span style=color:#f92672>=</span> v<span style=color:#f92672>-&gt;</span>files_[level].size() <span style=color:#f92672>/</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>double</span><span style=color:#f92672>&gt;</span>(config<span style=color:#f92672>::</span>kL0_CompactionTrigger);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Compute the ratio of current size to size limit.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>uint64_t</span> level_bytes <span style=color:#f92672>=</span> TotalFileSize(v<span style=color:#f92672>-&gt;</span>files_[level]);
</span></span><span style=display:flex><span>      score <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>double</span><span style=color:#f92672>&gt;</span>(level_bytes) <span style=color:#f92672>/</span> MaxBytesForLevel(options_, level);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (score <span style=color:#f92672>&gt;</span> best_score) {
</span></span><span style=display:flex><span>      best_level <span style=color:#f92672>=</span> level;
</span></span><span style=display:flex><span>      best_score <span style=color:#f92672>=</span> score;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><ul><li>sst记录一个查询次数，当一个文件被查询多次且是无效查询的时候的，当达到一定次数就会触发compcat操作，理由是他可能和其他文件有太多的重复的key，需要被清理以平衡io操作，这里的依据是的一次额外的compact操作的cost和多次的无效seek的均衡。</li><li></li></ul>他的大致逻辑是当前使用的线程设置manual_compaction_信息，然后调用compact线程使用manual_compaction_执行compact操作<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>compact {
</span></span><span style=display:flex><span>  BackgroundCompaction {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (imm_ <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nullptr</span>) {
</span></span><span style=display:flex><span>      CompactMemTable();
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Compaction<span style=color:#f92672>*</span> c;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (is_manual) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 执行manual compact，优先级最高，获得Compaction
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      c <span style=color:#f92672>=</span> versions_<span style=color:#f92672>-&gt;</span>CompactRange(m<span style=color:#f92672>-&gt;</span>level, m<span style=color:#f92672>-&gt;</span>begin, m<span style=color:#f92672>-&gt;</span>end);
</span></span><span style=display:flex><span>    } 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (c <span style=color:#f92672>==</span> <span style=color:#66d9ef>nullptr</span>) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 不做处理，不需要compact
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }<span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (<span style=color:#f92672>!</span>is_manual <span style=color:#f92672>&amp;&amp;</span> c<span style=color:#f92672>-&gt;</span>IsTrivialMove()) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 仅仅只需要移动文件，例如最开始的时候下层没有需要合并的文件，直接移动文件，修改元数据即可
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 执行compact
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      CompactionState<span style=color:#f92672>*</span> compact <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CompactionState(c);
</span></span><span style=display:flex><span>      status <span style=color:#f92672>=</span> DoCompactionWork(compact); 
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//  多个文件的合并操作，会处理过期或者需要删除的数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  DoCompactionWork {
</span></span><span style=display:flex><span>    Iterator<span style=color:#f92672>*</span> input <span style=color:#f92672>=</span> versions_<span style=color:#f92672>-&gt;</span>MakeInputIterator(compact<span style=color:#f92672>-&gt;</span>compaction);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (input<span style=color:#f92672>-&gt;</span>Valid() <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>shutting_down_.load(std<span style=color:#f92672>::</span>memory_order_acquire)) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (has_imm_.load(std<span style=color:#f92672>::</span>memory_order_relaxed)) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//  如果有minor compact，则优先处理
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 判断重叠，重叠太多影响查询，直接终止
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> compact<span style=color:#f92672>-&gt;</span>compaction<span style=color:#f92672>-&gt;</span>ShouldStopBefore(key)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span><span style=color:#960050;background-color:#1e0010>；</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 处理key
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果是delete
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//  或者是sequence小于当前使用中的sequence 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//  或者更高层没有这个key
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        drop <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>drop)
</span></span><span style=display:flex><span>        compact<span style=color:#f92672>-&gt;</span>builder<span style=color:#f92672>-&gt;</span>Add(key, input<span style=color:#f92672>-&gt;</span>value());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><p>由于compact的时候，会占用一定的系统资源，所以如果发生compaction的时候</p><ul><li>如果是minor compact，则减缓写操作，释放一定的系统资源</li><li>如果是Major Compaction，则暂停操作。等待compact任务完成</li></ul></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://askyx.github.io/posts/coursenote/><span class=button__icon>←</span>
<span class=button__text>Coursenote</span>
</a></span><span class="button next"><a href=https://askyx.github.io/posts/volcanooptimizer/><span class=button__text>VolcanoOptimizer</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><a href=https://askyx.github.io/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>Asky</span>
<span class=logo__cursor></span></a><div class=copyright><span>© 2025 Powered by
<a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span>
<span>Theme created by
<a href=https://twitter.com/panr target=_blank rel=noopener>panr</a></span></div></div></footer><script src=https://askyx.github.io/assets/main.js></script><script src=https://askyx.github.io/assets/prism.js></script></div></body></html>