<!doctype html><html lang=en>
<head>
<title>
Greenplum ::
Esoye — My note blog
</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="源码编译 #  详细编译过程见这里
起源与发展与架构 #  1. 起源发展 #   数据爆炸式增长，数据处理进入大数据时代 传统数据处理模式的纵向增长速度难以更上数据的增长速度 为了解决大数据场景下的数据处理，主要思路是数据存储和数据计算的横向扩展 分布式存储和分布式运算的实际成果，Google的三驾马车  GP在这个背景下，选择PG搭建MPP架构的OLAP的数据库，且内核是PG，所以天然具有非常丰富的特性，相比其他的OLAP数据库，他的功能支持是比较完善的。
 支持完整的ANSI SQL标准 分布式事务 MPP赋予他良好的线性扩展能力 完善的生态系统   Greenplum 公司成立于 2003 年，2008 年发布 Greenplum 数据库产品。2010 年 Greenplum 被 高端存储领域巨头 EMC 收购，同年 Greenplum 借助 EMC 中国卓越研发集团进入中国，并创建 Greenplum 中国研发团队。2014 年 Greenplum 从 EMC 独立出来创立 Pivotal，并获得通用电气、 福特汽车和微软的投资。2018 年 4 月 Pivotal 在纽约证券交易所上市，目前市值 60 多亿美元
 2. 架构 #  MPP架构，由Master Severs和Segment Severs通过Interconnect互联组成
  Master节点">
<meta name=keywords content="数据库">
<meta name=robots content="noodp">
<link rel=canonical href=https://Esoye.github.io/posts/postgres/greenplum/>
<link rel=stylesheet href=https://Esoye.github.io/assets/style.css>
<link rel=stylesheet href=https://Esoye.github.io/style.css>
<link rel=apple-touch-icon-precomposed sizes=144x144 href=https://Esoye.github.io/img/apple-touch-icon-144-precomposed.png>
<link rel="shortcut icon" href=https://Esoye.github.io/img/favicon.png>
<link href=https://Esoye.github.io/assets/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=https://Esoye.github.io/assets/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=https://Esoye.github.io/assets/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=https://Esoye.github.io/assets/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=https://Esoye.github.io/assets/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=https://Esoye.github.io/assets/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin>
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Greenplum">
<meta name=twitter:description content="GreenPlum优化器和执行器的源码调研">
<meta property="og:title" content="Greenplum">
<meta property="og:description" content="GreenPlum优化器和执行器的源码调研">
<meta property="og:type" content="article">
<meta property="og:url" content="https://Esoye.github.io/posts/postgres/greenplum/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-08-10T20:22:49+08:00">
<meta property="article:modified_time" content="2022-08-10T20:22:49+08:00"><meta property="og:site_name" content="Esoye">
</head>
<body class=light-theme>
<div class=container>
<header class=header>
<span class=header__inner>
<a href=/ class=logo style=text-decoration:none>
<span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg>
</span>
<span class=logo__text>Esoye</span>
<span class=logo__cursor></span>
</a>
<span class=header__right>
<nav class=menu>
<ul class="menu__inner menu__inner--desktop">
<li><a href=/archive>Archive</a></li>
</ul>
<ul class="menu__inner menu__inner--mobile">
<li><a href=/archive>Archive</a></li>
</ul>
</nav>
<span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
</span>
<span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg>
</span>
</span>
</span>
</header>
<div class=content>
<div class=post>
<h1 class=post-title>Greenplum</h1>
<div class=post-meta>
<span class=post-date>
2022-08-10
</span>
</div>
<span class=post-tags>
<a href=https://Esoye.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/>#数据库</a>&nbsp;
<a href=https://Esoye.github.io/tags/postgres/>#Postgres</a>&nbsp;
<a href=https://Esoye.github.io/tags/greenplum/>#GreenPlum</a>&nbsp;
</span>
<div class=post-content>
<h2>Table of Contents</h2>
<aside class=table-of-contents><nav id=TableOfContents>
<ul>
<li><a href=#源码编译>源码编译</a></li>
<li><a href=#起源与发展与架构>起源与发展与架构</a>
<ul>
<li><a href=#1-起源发展>1. 起源发展</a></li>
<li><a href=#2-架构>2. 架构</a></li>
</ul>
</li>
<li><a href=#源码分析>源码分析</a>
<ul>
<li><a href=#执行计划>执行计划</a></li>
<li><a href=#执行计划的生成>执行计划的生成</a></li>
<li><a href=#antdb-vs-greenplum>AntDB VS GreenPlum</a></li>
</ul>
</li>
<li><a href=#简单的性能对比>简单的性能对比</a></li>
<li><a href=#总结>总结</a>
<ul>
<li></li>
</ul>
</li>
</ul>
</nav></aside>
<h2 id=源码编译>
源码编译
<a href=#%e6%ba%90%e7%a0%81%e7%bc%96%e8%af%91 class=h-anchor aria-hidden=true>#</a>
</h2>
<p>详细编译过程见<a href=https://esoye.github.io/posts/postgres/pgenvbuild>这里</a></p>
<h2 id=起源与发展与架构>
起源与发展与架构
<a href=#%e8%b5%b7%e6%ba%90%e4%b8%8e%e5%8f%91%e5%b1%95%e4%b8%8e%e6%9e%b6%e6%9e%84 class=h-anchor aria-hidden=true>#</a>
</h2>
<h3 id=1-起源发展>
1. 起源发展
<a href=#1-%e8%b5%b7%e6%ba%90%e5%8f%91%e5%b1%95 class=h-anchor aria-hidden=true>#</a>
</h3>
<ul>
<li>数据爆炸式增长，数据处理进入大数据时代</li>
<li>传统数据处理模式的纵向增长速度难以更上数据的增长速度</li>
<li>为了解决大数据场景下的数据处理，主要思路是数据存储和数据计算的横向扩展</li>
<li>分布式存储和分布式运算的实际成果，Google的三驾马车</li>
</ul>
<p>GP在这个背景下，选择PG搭建MPP架构的OLAP的数据库，且内核是PG，所以天然具有非常丰富的特性，相比其他的OLAP数据库，他的功能支持是比较完善的。</p>
<ol>
<li>支持完整的ANSI SQL标准</li>
<li>分布式事务</li>
<li>MPP赋予他良好的线性扩展能力</li>
<li>完善的生态系统</li>
</ol>
<blockquote>
<p>Greenplum 公司成立于 2003 年，2008 年发布 Greenplum 数据库产品。2010 年 Greenplum 被
高端存储领域巨头 EMC 收购，同年 Greenplum 借助 EMC 中国卓越研发集团进入中国，并创建
Greenplum 中国研发团队。2014 年 Greenplum 从 EMC 独立出来创立 Pivotal，并获得通用电气、
福特汽车和微软的投资。2018 年 4 月 Pivotal 在纽约证券交易所上市，目前市值 60 多亿美元</p>
</blockquote>
<h3 id=2-架构>
2. 架构
<a href=#2-%e6%9e%b6%e6%9e%84 class=h-anchor aria-hidden=true>#</a>
</h3>
<p>MPP架构，由<code>Master Severs</code>和<code>Segment Severs</code>通过Interconnect互联组成</p>
<ul>
<li>
<p><code>Master</code>节点<br>
是整个系统的控制中心和对外的服务接入点，它负责接收用户SQL请求，将SQL生成查询计划并进行并行处理优化，然后将查询计划分配（dispatch）到所有的<code>segment</code>节点进行并行处理，协调组织各个<code>segment</code>节点按照查询计划一步一步地进行并行处理，最后获取到<code>segment</code>的计算结果，再返回给客户端；从用户的角度看Greenplum集群，看到的只是Master节点,无需关心集群内部的机制，所有的并行处理都是在Master控制下自动完成的。Master节点一般只有一个或两个（互为备份）；</p>
</li>
<li>
<p><code>segment</code>节点<br>
是Greenplum执行并行任务的并行运算节点，它接收Master的指令进行MPP并行计算，因此所有<code>segment</code>节点的计算性能总和就是整个集群的性能，通过增加<code>segment</code>节点，可以线性化得增加集群的处理性能和存储容量，<code>segment</code>节点可以是1~10000个节点；</p>
</li>
<li>
<p><code>Interconnect</code><br>
是Master节点与<code>segment</code>节点、<code>segment</code>节点与<code>segment</code>节点之间的数据传输组件，它基于千兆交换机或万兆交换机实现数据在节点间的高速传输。原来pg中的libpq用于控制信息的传输</p>
</li>
</ul>
<p><img src=/posts/postgres/images/%E6%9E%B6%E6%9E%84%E5%9B%BE.png alt=架构></p>
<blockquote>
<p>MPP: (Massively Parallel Processing)<br>
类似MapReduce ,Impala、ClickHouse、Druid、Doris等都是MPP架构。<br>
<a href=https://zhuanlan.zhihu.com/p/395519072>MPP大规模并行处理架构详解</a><br>
<a href=https://blog.csdn.net/yimenglin/article/details/90510134>MPP 与 Hadoop是什么关系</a>
<a href=https://0x0fff.com/apache-spark-future/>评论区大佬发言</a></p>
</blockquote>
<p>● 任务并行执行;<br>
● 数据分布式存储(本地化);</p>
<ul>
<li>hash分布</li>
<li>随机分布</li>
<li>复制表<br>
● 多态存储，实现类似冷热数据的异构存储
● 分布式计算;<br>
● 横向扩展;<br>
● Shared Nothing架构。</li>
</ul>
<blockquote>
<p>RE-READ: <a href="https://cs-people.bu.edu/mathan/reading-groups/papers-classics/volcano.pdf#:~:text=Volcano-An%20Extensible%20and%20Parallel%20Query%20Evaluation%20System%20Goetz,a%20new%20dataflow%20query%20execution%20system%20called%20Volcano.">Volcano-An Extensible and Parallel Query Evaluation System</a></p>
</blockquote>
<hr>
<h2 id=源码分析>
源码分析
<a href=#%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90 class=h-anchor aria-hidden=true>#</a>
</h2>
<p>这里希望可以让大家知道下面的几个问题</p>
<ol>
<li>remote执行计划怎么解读</li>
<li>remote如何执行</li>
<li>remote执行计划怎么生成</li>
<li>AntDB和GP有关remote的区别</li>
</ol>
<h3 id=执行计划>
执行计划
<a href=#%e6%89%a7%e8%a1%8c%e8%ae%a1%e5%88%92 class=h-anchor aria-hidden=true>#</a>
</h3>
<p>为了更好的理解语句的执行过程，先了解下GP的执行计划，以下面的语句为例，两表数据一样，进行join，条件只是普通列，非主键，非分区列。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>prepare</span> s36(int, int) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>select</span> a.no_o_id <span style=color:#66d9ef>from</span> bmsql_new_order a <span style=color:#66d9ef>join</span> bmsql_new_order_bak1 b <span style=color:#66d9ef>on</span>  a.no_o_id  <span style=color:#f92672>=</span> b.no_o_id ;
<span style=color:#66d9ef>explain</span> (<span style=color:#66d9ef>verbose</span>, <span style=color:#66d9ef>analyze</span>) <span style=color:#66d9ef>execute</span> s36(<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>1</span>); 
</code></pre></div><p>具体的执行计划如下</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>
benchmarksql<span style=color:#f92672>=</span><span style=color:#960050;background-color:#1e0010>#</span> explain (verbose, analyze) execute s36(<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>1</span>); 
 Gather Motion <span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>1</span>  (slice3; <span style=color:#960050;background-color:#1e0010>`</span>segment<span style=color:#960050;background-color:#1e0010>`</span>s: <span style=color:#ae81ff>2</span>)  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>1975.90</span>.<span style=color:#ae81ff>.29568.15</span> rows<span style=color:#f92672>=</span><span style=color:#ae81ff>2243323</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>) (actual time<span style=color:#f92672>=</span><span style=color:#ae81ff>27.853</span>.<span style=color:#ae81ff>.1062.597</span> rows<span style=color:#f92672>=</span><span style=color:#ae81ff>2249955</span> loops<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
   Output: a.no_o_id
   <span style=color:#f92672>-&gt;</span>  Hash Join  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>1975.90</span>.<span style=color:#ae81ff>.29568.15</span> rows<span style=color:#f92672>=</span><span style=color:#ae81ff>1121662</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>) (actual time<span style=color:#f92672>=</span><span style=color:#ae81ff>27.156</span>.<span style=color:#ae81ff>.445.908</span> rows<span style=color:#f92672>=</span><span style=color:#ae81ff>1177455</span> loops<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
         Output: a.no_o_id
         Hash Cond: (a.no_o_id <span style=color:#f92672>=</span> b.no_o_id)
         Executor Memory: <span style=color:#ae81ff>1408</span>kB  <span style=color:#960050;background-color:#1e0010>`</span>segment<span style=color:#960050;background-color:#1e0010>`</span>s: <span style=color:#ae81ff>2</span>  Max: <span style=color:#ae81ff>737</span>kB (<span style=color:#960050;background-color:#1e0010>`</span>segment<span style=color:#960050;background-color:#1e0010>`</span> <span style=color:#ae81ff>1</span>)
         work_mem: <span style=color:#ae81ff>1408</span>kB  <span style=color:#960050;background-color:#1e0010>`</span>segment<span style=color:#960050;background-color:#1e0010>`</span>s: <span style=color:#ae81ff>2</span>  Max: <span style=color:#ae81ff>737</span>kB (<span style=color:#960050;background-color:#1e0010>`</span>segment<span style=color:#960050;background-color:#1e0010>`</span> <span style=color:#ae81ff>1</span>)  Workfile: (<span style=color:#ae81ff>0</span> spilling)
         Extra Text: (seg1)   Hash chain length <span style=color:#ae81ff>49.6</span> avg, <span style=color:#ae81ff>50</span> max, <span style=color:#66d9ef>using</span> <span style=color:#ae81ff>475</span> of <span style=color:#ae81ff>524288</span> buckets.
         <span style=color:#f92672>-&gt;</span>  Redistribute Motion <span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>2</span>  (slice1; <span style=color:#960050;background-color:#1e0010>`</span>segment<span style=color:#960050;background-color:#1e0010>`</span>s: <span style=color:#ae81ff>2</span>)  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0.00</span>.<span style=color:#ae81ff>.1412.99</span> rows<span style=color:#f92672>=</span><span style=color:#ae81ff>22517</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>) (actual time<span style=color:#f92672>=</span><span style=color:#ae81ff>0.123</span>.<span style=color:#ae81ff>.10.948</span> rows<span style=color:#f92672>=</span><span style=color:#ae81ff>23583</span> loops<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
               Output: a.no_o_id, a.no_w_id
               Hash Key: a.no_o_id
               <span style=color:#f92672>-&gt;</span>  Seq Scan on <span style=color:#66d9ef>public</span>.bmsql_new_order a  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0.00</span>.<span style=color:#ae81ff>.512.33</span> rows<span style=color:#f92672>=</span><span style=color:#ae81ff>22517</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>) (actual time<span style=color:#f92672>=</span><span style=color:#ae81ff>0.014</span>.<span style=color:#ae81ff>.7.987</span> rows<span style=color:#f92672>=</span><span style=color:#ae81ff>27017</span> loops<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
                     Output: a.no_o_id, a.no_w_id
         <span style=color:#f92672>-&gt;</span>  Hash  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>1412.99</span>.<span style=color:#ae81ff>.1412.99</span> rows<span style=color:#f92672>=</span><span style=color:#ae81ff>22517</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>) (actual time<span style=color:#f92672>=</span><span style=color:#ae81ff>25.454</span>.<span style=color:#ae81ff>.25.454</span> rows<span style=color:#f92672>=</span><span style=color:#ae81ff>23583</span> loops<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
               Output: b.no_o_id, b.no_w_id
               <span style=color:#f92672>-&gt;</span>  Redistribute Motion <span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>2</span>  (slice2; <span style=color:#960050;background-color:#1e0010>`</span>segment<span style=color:#960050;background-color:#1e0010>`</span>s: <span style=color:#ae81ff>2</span>)  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0.00</span>.<span style=color:#ae81ff>.1412.99</span> rows<span style=color:#f92672>=</span><span style=color:#ae81ff>22517</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>) (actual time<span style=color:#f92672>=</span><span style=color:#ae81ff>1.616</span>.<span style=color:#ae81ff>.17.073</span> rows<span style=color:#f92672>=</span><span style=color:#ae81ff>23583</span> loops<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
                     Output: b.no_o_id, b.no_w_id
                     Hash Key: b.no_o_id
                     <span style=color:#f92672>-&gt;</span>  Seq Scan on <span style=color:#66d9ef>public</span>.bmsql_new_order_bak1 b  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0.00</span>.<span style=color:#ae81ff>.512.33</span> rows<span style=color:#f92672>=</span><span style=color:#ae81ff>22517</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>) (actual time<span style=color:#f92672>=</span><span style=color:#ae81ff>0.024</span>.<span style=color:#ae81ff>.8.003</span> rows<span style=color:#f92672>=</span><span style=color:#ae81ff>27017</span> loops<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
                           Output: b.no_o_id, b.no_w_id
   (slice0)    Executor memory: <span style=color:#ae81ff>247</span>K bytes.
   (slice1)    Executor memory: <span style=color:#ae81ff>60</span>K bytes avg x <span style=color:#ae81ff>2</span> workers, <span style=color:#ae81ff>60</span>K bytes max (seg0).
   (slice2)    Executor memory: <span style=color:#ae81ff>44</span>K bytes avg x <span style=color:#ae81ff>2</span> workers, <span style=color:#ae81ff>44</span>K bytes max (seg0).
   (slice3)    Executor memory: <span style=color:#ae81ff>6328</span>K bytes avg x <span style=color:#ae81ff>2</span> workers, <span style=color:#ae81ff>6328</span>K bytes max (seg0).  Work_mem: <span style=color:#ae81ff>737</span>K bytes 
max.
 Memory used:  <span style=color:#ae81ff>128000</span>kB
 Optimizer: Postgres query optimizer
 Execution time: <span style=color:#ae81ff>1150.876</span> ms
(<span style=color:#ae81ff>27</span> rows)

Time: <span style=color:#ae81ff>1152.362</span> ms
</code></pre></div><p><img src=/posts/postgres/images/plan1.svg alt=plan1></p>
<p>和普通的PG的执行计划类似，其中稍有区别，主要区别为其中有<code>Redistribute Motion 2:2 (slice2; segments: 2) </code>类似的算子，这有几个GP的执行器的概念</p>
<h4 id=1-motion算子>
1. Motion算子
<a href=#1-motion%e7%ae%97%e5%ad%90 class=h-anchor aria-hidden=true>#</a>
</h4>
<p>实现并行操作的算子，有三大类，主要负责<code>segment</code>之间数据的传输，具体类型如下</p>
<ul>
<li><code>Redistribute</code>
<ul>
<li><code>Redistribute Motion</code><br>
重分布，把一个节点的数据使用hash重新发送到其他节点</li>
<li><code>Explicit Redistribute Motion</code><br>
显示重分布，按照segid直接发送数据到指定node</li>
</ul>
</li>
<li><code>Broadcast</code>
<ul>
<li><code>Broadcast Motion</code><br>
广播，小表广播，把数据复制到其他节点</li>
</ul>
</li>
<li><code>Gather</code>
<ul>
<li><code>Gather Motion</code><br>
数据汇总，收集节点到master</li>
<li><code>Explicit Gather Motion</code><br>
显示数据汇总</li>
</ul>
</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>MotionType</span>
{
 MOTIONTYPE_HASH,     <span style=color:#75715e>// 重點是hash，目標未知
</span><span style=color:#75715e></span> MOTIONTYPE_FIXED,    <span style=color:#75715e>// 重點是限定接收者，目標固定
</span><span style=color:#75715e></span> MOTIONTYPE_EXPLICIT  <span style=color:#75715e>// 重點是目標已知，不需要hash計算，发送元组给其 segid 字段指定的 `segment`s
</span><span style=color:#75715e></span>} MotionType;

<span style=color:#66d9ef>case</span><span style=color:#f92672>:</span> MOTIONTYPE_HASH
  sname <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Redistribute Motion&#34;</span>;
<span style=color:#66d9ef>case</span><span style=color:#f92672>:</span> MOTIONTYPE_FIXED
  <span style=color:#66d9ef>if</span> (pMotion<span style=color:#f92672>-&gt;</span>isBroadcast)
    sname <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Broadcast Motion&#34;</span>;
  <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (plan<span style=color:#f92672>-&gt;</span>lefttree<span style=color:#f92672>-&gt;</span>flow<span style=color:#f92672>-&gt;</span>locustype <span style=color:#f92672>==</span> CdbLocusType_Replicated)
    sname <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Explicit Gather Motion&#34;</span>;
  <span style=color:#66d9ef>else</span>
    sname <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Gather Motion&#34;</span>;
<span style=color:#66d9ef>case</span> MOTIONTYPE_EXPLICIT:
  sname <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Explicit Redistribute Motion&#34;</span>;
</code></pre></div><p>一个完整的motion算子分为<code>execMotionSender</code>和<code>execMotionReceiver</code>，按照不同的算子可以分为一对多和多对多两种，
以上面的例子为例，总共有2个<code>segment</code>，<code>Gather Motion</code>在master上有一个<code>execMotionReceiver</code>负责接受<code>segment</code>的数据，在每个<code>segment</code>上，有与之对应的<code>execMotionSender</code>，负责发送处理之后的数据</p>
<p><img src=/posts/postgres/images/plan2.svg alt=plan2></p>
<p>master 和<code>segment</code>之间使用<code>Gather Motion</code>汇总数据，<code>segment</code>之间也使用不同的motion算子交换数据，这里和AntDB的执行流程类似，</p>
<h4 id=2-slice>
2. slice
<a href=#2-slice class=h-anchor aria-hidden=true>#</a>
</h4>
<p>GP提升性能的出发点是并行，理论上并行可以获得正反馈的操作，他都倾向于实现对应的并行操作，这里为了提高查询执行并行度和效率，
他以motion算子为界限，把执行计划分为不同的slice，然后不同的slice到不同的<code>segment</code>上执行，上面的例子有4个slice，在语句运行之后，查看运行的进程信息，可以看见下面的信息</p>
<pre tabindex=0><code>vscode   0:00 postgres:  5432, vscode benchmarksql [local] con35 cmd4 EXPLAIN
vscode   0:00 postgres: 40000, vscode benchmarksql 172.17.0.2(37002) con35 seg0 cmd5 slice3 MPPEXEC SELECT
vscode   0:00 postgres: 40001, vscode benchmarksql 172.17.0.2(46892) con35 seg1 cmd5 slice3 MPPEXEC SELECT
vscode   0:00 postgres: 40000, vscode benchmarksql 172.17.0.2(37006) con35 seg0 cmd5 slice1 MPPEXEC SELECT
vscode   0:00 postgres: 40001, vscode benchmarksql 172.17.0.2(46896) con35 seg1 cmd5 slice1 MPPEXEC SELECT
vscode   0:00 postgres: 40000, vscode benchmarksql 172.17.0.2(37010) con35 seg0 cmd5 slice2 MPPEXEC SELECT
vscode   0:00 postgres: 40001, vscode benchmarksql 172.17.0.2(46900) con35 seg1 cmd5 slice2 MPPEXEC SELECT
</code></pre><p>这里调高日志等级，查看不同<code>segment</code>的日志记录如下</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>// master 日志
</span><span style=color:#75715e></span><span style=color:#a6e22e>Motion</span> <span style=color:#a6e22e>Node</span> <span style=color:#ae81ff>3</span> (<span style=color:#a6e22e>RECEIVER</span>) <span style=color:#a6e22e>Statistics</span><span style=color:#f92672>:</span>
<span style=color:#a6e22e>Timing</span><span style=color:#f92672>:</span>  
         <span style=color:#a6e22e>Time</span> <span style=color:#a6e22e>receiving</span> <span style=color:#a6e22e>the</span> <span style=color:#a6e22e>tuple</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>1.138736</span> <span style=color:#a6e22e>sec</span>
<span style=color:#a6e22e>Counters</span><span style=color:#f92672>:</span> 
        <span style=color:#a6e22e>numTuplesFromChild</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>
        <span style=color:#a6e22e>numTuplesFromAMS</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>2249955</span>
        <span style=color:#a6e22e>numTuplesToAMS</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>
        <span style=color:#a6e22e>numTuplesToParent</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>2249955</span>
<span style=color:#e6db74>&#34;,,,,,,,0,,&#34;</span><span style=color:#a6e22e>nodeMotion</span>.<span style=color:#a6e22e>c</span><span style=color:#e6db74>&#34;,1270,
</span><span style=color:#e6db74>
</span><span style=color:#e6db74>// `segment` 日志
</span><span style=color:#e6db74>Motion Node 3 (SENDER) Statistics:
</span><span style=color:#e6db74>Timing:  
</span><span style=color:#e6db74>         Time getting next tuple to send: 0.910967 sec 
</span><span style=color:#e6db74>         Time sending the tuple:          0.361539  sec
</span><span style=color:#e6db74>         Percentage of time sending:      28.41% 
</span><span style=color:#e6db74>Counters: 
</span><span style=color:#e6db74>        numTuplesFromChild: 1072500
</span><span style=color:#e6db74>        numTuplesToAMS: 1072500
</span><span style=color:#e6db74>&#34;</span>,,,,,,,<span style=color:#ae81ff>0</span>,,<span style=color:#e6db74>&#34;nodeMotion.c&#34;</span>,<span style=color:#ae81ff>1290</span>,
</code></pre></div><p>明显的可以看出他的执行方式以slice划分为不同的阶段，每一个slice实例就是具体的slice的task，每个slice实例有具体的数据输入与输出，相同阶段下的slice之间相互独立，只和下一个阶段的slice进行数据交互</p>
<blockquote>
<p>眼熟，只看描述和MapReduce几乎一样，网上也确实有许多关于MPP和MP的讨论，个人觉得他们更多的是同一个处理框架下的面对不同细节划分的结果</p>
</blockquote>
<p>每个motion在不同的<code>segment</code>上运行有<code>RECEIVER</code>和<code>SENDER</code>，按照slice细分执行计划，大致逻辑上的和pg执行步骤类似，只是针对分布式，添加了motion算子，此时具体的数据流动如下</p>
<p><img src=/posts/postgres/images/plan3.svg alt=plan3></p>
<p>每一个slice都是一个独立的进程，使用interconnet和其他进程进行数据交互，数据由一个流向下一个slice，在slice中进行运算。
当前发现的现象是对于slice，无论数据规模大小，只要执行计划选择使用motion算子，则就会以motion算子为边界，划分不同的slice，可能造成的问题是对于数据规模比较小的时候，创建进程的代价远大于数据处理的代价</p>
<blockquote>
<p>此问题经过调查确实存在，尚不清楚后续是否有优化</p>
</blockquote>
<h4 id=源码>
源码
<a href=#%e6%ba%90%e7%a0%81 class=h-anchor aria-hidden=true>#</a>
</h4>
<p>motions算子的主要文件为<code>nodeMotion.h</code>和<code>nodeMotion.c</code>，主要执行方法为</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>MotionState <span style=color:#f92672>*</span>ExecInitMotion(Motion <span style=color:#f92672>*</span>node, EState <span style=color:#f92672>*</span>estate, <span style=color:#66d9ef>int</span> eflags)
TupleTableSlot <span style=color:#f92672>*</span>ExecMotion(MotionState <span style=color:#f92672>*</span>node)
<span style=color:#66d9ef>void</span> ExecEndMotion(MotionState <span style=color:#f92672>*</span>node)
</code></pre></div><p>具体的调用逻辑如下</p>
<p><img src=/posts/postgres/images/execute1.svg alt=execute1></p>
<ul>
<li>QD Query Dispatch</li>
<li>QE Query Execute</li>
</ul>
<p>在master上初始化的时候，会使用<code>CdbDispatchPlan</code>方法分发执行计划到具体的<code>segment</code>上，分发的执行计划是以slice划分的执行片段。<code>segment</code>接收到执行计划使用<code>exec_mpp_query</code>执行具体的流程和上图类似，也是进行执行计划的初始化，执行，以及释放资源等。</p>
<blockquote>
<p>cdb 代表cluster database，项目早期使用的名字，保留到现在</p>
</blockquote>
<p>在代码内部，他使用<code>GpRoleValue</code>区分不同角色，QE和QD执行的是不同的路径，在QE下，再使用<code>MotionStateType</code>区分是<code>sender</code>还是<code>recver</code>，让他们再执行不同的逻辑</p>
<p>在<code>ExecInitMotion</code>只是进行一些初始化，master会初始化整个执行计划，确定执行算子的slice并且把执行计划切分到不同的<code>segment</code>，然后发送执行计划的片段到<code>segment</code>，<code>segment</code>初始化的时候，从<code>serder</code>开始，如果当前执行计划有<code>recver</code>，则一直初始化到<code>recver</code>，如果没有，则初始化整棵树</p>
<p>这里主要对<code>ExecMotion</code>进行分析</p>
<p><img src=/posts/postgres/images/ExecMotion.svg alt=ExecMotion></p>
<p>按照type这里划分为两条执行路径</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>if</span> (recver) {
  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>sorted) {
    execMotionUnsortedReceiver();
  } <span style=color:#66d9ef>else</span> {
    <span style=color:#66d9ef>if</span> (gp_enable_motion_mk_sort)
      execMotionSortedReceiver_mk();
    <span style=color:#66d9ef>else</span>
      <span style=color:#a6e22e>execMotionSortedReceiver</span>();
  }
} <span style=color:#66d9ef>else</span> (sender) {
  execMotionSender() {
    <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>done) {
      outerNode <span style=color:#f92672>=</span> outerPlanState(node);
      outerTupleSlot <span style=color:#f92672>=</span> ExecProcNode(outerNode);
      <span style=color:#75715e>// 根据hash值计算targetRoute
</span><span style=color:#75715e></span>      doSendTuple() {
        hval <span style=color:#f92672>=</span> evalHashKey();
        SendTuple();
      }
    }
  }
} <span style=color:#66d9ef>else</span> 
  error report
</code></pre></div><p>这里的sort最初以为是对于sort算子的优化，但是使用几个简单的sort语句没有构造出理想中的执行计划，例如对于语句<code>select * from t1 order by c1</code><br>
我以为的执行计划是</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql> Gather Motion <span style=color:#ae81ff>2</span>:<span style=color:#ae81ff>1</span>  (slice1; <span style=color:#f92672>`</span>segment<span style=color:#f92672>`</span>s: <span style=color:#ae81ff>2</span>)  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>207</span>.<span style=color:#ae81ff>26</span>..<span style=color:#ae81ff>214</span>.<span style=color:#ae81ff>76</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>3000</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>)
   Merge <span style=color:#66d9ef>Key</span>: c1
      <span style=color:#f92672>-&gt;</span>  Seq Scan <span style=color:#66d9ef>on</span> t1  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span>..<span style=color:#ae81ff>34</span>.<span style=color:#ae81ff>00</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1500</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>)
</code></pre></div><p>但是实际的执行计划还是</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql> Gather Motion <span style=color:#ae81ff>2</span>:<span style=color:#ae81ff>1</span>  (slice1; <span style=color:#f92672>`</span>segment<span style=color:#f92672>`</span>s: <span style=color:#ae81ff>2</span>)  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>207</span>.<span style=color:#ae81ff>26</span>..<span style=color:#ae81ff>214</span>.<span style=color:#ae81ff>76</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>3000</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>)
   Merge <span style=color:#66d9ef>Key</span>: c1
   <span style=color:#f92672>-&gt;</span>  Sort  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>207</span>.<span style=color:#ae81ff>26</span>..<span style=color:#ae81ff>214</span>.<span style=color:#ae81ff>76</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1500</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>)
         Sort <span style=color:#66d9ef>Key</span>: c1
         <span style=color:#f92672>-&gt;</span>  Seq Scan <span style=color:#66d9ef>on</span> t1  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span>..<span style=color:#ae81ff>34</span>.<span style=color:#ae81ff>00</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1500</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>)
</code></pre></div><p>这里的sort还是在<code>segment</code>上进行了sort，再由master的recver进行二次排序，不全部交到master排序可能还是基于减低master的负载来考虑的吧。</p>
<hr>
<h3 id=执行计划的生成>
执行计划的生成
<a href=#%e6%89%a7%e8%a1%8c%e8%ae%a1%e5%88%92%e7%9a%84%e7%94%9f%e6%88%90 class=h-anchor aria-hidden=true>#</a>
</h3>
<p>这里就还是以前面的语句为例子，相比于普通的pg，gp需要额外的逻辑处理motion算子的生成，是否需要生成motion路径，主要的信息的是数据分布，数据的分布信息添加在path结构体中，使用<code>CdbPathLocus</code>来表示数据的分布，后续在<code>cdbpath_create_motion_path</code>中，使用此信息生成motion path。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>CdbPathLocus</span>
{
 CdbLocusType locustype;
 List    <span style=color:#f92672>*</span>distkey;
 <span style=color:#66d9ef>int</span>   numsegments;
} CdbPathLocus;

<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>CdbLocusType</span>
{
    CdbLocusType_Null,
    CdbLocusType_Entry,         <span style=color:#75715e>/* a single backend process on the entry db:
</span><span style=color:#75715e>                                 * usually the qDisp itself, but could be a
</span><span style=color:#75715e>                                 * qExec started by the entry postmaster.
</span><span style=color:#75715e>                                 */</span>
    CdbLocusType_SingleQE,      <span style=color:#75715e>/* a single backend process on any db: the
</span><span style=color:#75715e>                                 * qDisp itself, or a qExec started by a
</span><span style=color:#75715e>                                 * segment postmaster or the entry postmaster.
</span><span style=color:#75715e>                                 */</span>
    CdbLocusType_General,       <span style=color:#75715e>/* compatible with any locus (data is
</span><span style=color:#75715e>                                 * self-contained in the query plan or
</span><span style=color:#75715e>                                 * generally available in any qExec or qDisp) */</span>
    CdbLocusType_SegmentGeneral,<span style=color:#75715e>/* generally available in any qExec, but not
</span><span style=color:#75715e>				 * available in qDisp */</span>
    CdbLocusType_Replicated,    <span style=color:#75715e>/* replicated over all qExecs of an N-gang */</span>
    CdbLocusType_Hashed,        <span style=color:#75715e>/* hash partitioned over all qExecs of N-gang */</span>
    CdbLocusType_HashedOJ,      <span style=color:#75715e>/* result of hash partitioned outer join, NULLs can be anywhere */</span>
    CdbLocusType_Strewn,        <span style=color:#75715e>/* partitioned on no known function */</span>
    CdbLocusType_End            <span style=color:#75715e>/* = last valid CdbLocusType + 1 */</span>
} CdbLocusType;
</code></pre></div><p><code>CdbLocusType</code>字段表示的数据的分布信息，后续使用他参与执行计划的生成。<code>CdbPathLocus</code>是在<code>set_plain_rel_pathlist</code>中建立base_rel_path的时候使用<code>RelOptInfo</code>构建的，他参与后续的优化过程，以join为例，当前gp中join path的生成路径的关键函数调用关系如下</p>
<p><img src=/posts/postgres/images/join.svg alt=join></p>
<p>在<code>cdbpath_motion_for_join</code>中，会对join节点的上下文信息以及左右子节点的<code>CdbPathLocus</code>进行和<code>join key</code>等信息综合判断，例如左节点的数据分布是否和右节点的数据分布是否一致，如果数据分布一致，则此左右节点无需创建motion，如果当前数据分布和下层节点数据分布不一致的情况下，在什么情况下需要单个节点处理，什么情况下必须多个节点处理，是选择创建<code>Redistribute Motion</code>还是选择创建<code>Broadcast Motion</code>等，</p>
<p>最终对于需要生成motion算子的节点，则调用<code>cdbpath_create_motion_path</code>生成motion，如果这个方法不是在join中调用的，此处也会使用<code>CdbPathLocus</code>信息进行更进一步的判断，如果不需要motion，中间就直接返回了，如果需要，最后生成motion节点。此时会计算motion节点的cost，具体的cost计算函数为<code>cdbpath_cost_motion</code>，具体的计算方法为</p>
<p><img src=/posts/postgres/images/cost1.svg alt=cost></p>
<p>如果是子节点需要进行广播，则针对一个motion来说，他的<code>recvrows</code>数据则会是所有下层算子的数据，而<code>sendrows</code>由于下层数据互不交互，所以直接就是下层节点的数据， <code>startup_cost</code>和子节点的<code>startup cost</code>一样，<code>total_cost</code>等于<code>motioncost</code>加上子节点的<code>total_cost</code>，在上面的计算过程中，<code>gp_motion_cost_per_row</code>是可以自行设定的，如果没有设置，则使用<code>cpu_tuple_cost</code>计算，并没有看见网络IO等代价的计算。</p>
<p>上面的操作都是在<code>query_planner</code>中生成的，属于一些基础算子层面优化，对于聚合函数等优化，接下来会在<code>cdb_grouping_planner</code>中进行二次优化。</p>
<p>最终生成path之后，使用<code>create_plan</code>生成plan，在生成plan的时候，还会在plan中调用<code>cdbpathtoplan_create_flow</code>，为每一个node生成一个flow信息，此信息主要由元数据信息以及上面的<code>Locus</code>信息生成，主要描述节点的数据流向，用于在后面划分slice的时候使用</p>
<p>🎈 flow的作用类似AntDB中计算exec_node，只是AntDB中这个过程紧密的结合在优化过程中，而GP在优化的最后阶段，才生成flow信息，执行器根据flow信息选择执行流程</p>
<blockquote>
<p><del>对于motion，AntDB的类似操作是在<code>set_plain_rel_pathlist</code>中直接构建<code>cluster</code>的执行计划，然后在join阶段，和原来的pg的过程类似，没有太特殊的处理，只是把最后的path添加到cluster_path中去，只是这个过程中，由于有更多的基础scanpath，所以后续的join的搜索空间理论上会成倍的增加，且在join的过程中，没有对左右子节点进行key相关的判断，如果有类似的操作，那为什么不在这里呢</del></p>
</blockquote>
<blockquote>
<p>👴 AntDB在生成base_path的时候同时生成生成cluster_path，然后在后续的操作中，例如<code>make_join_rel</code>的时候，除了处理常规的path之外，还会使用<code>add_cluster_paths_to_joinrel</code>处理前面的cluster_path，用于生成reduce plan，此方法的逻辑和处理join方法类似。而gp的此过程时直接嵌入到原生的pg内核中的，具体如上描述，是在处理join左右节点的时候使用<code>CdbPathLocus</code>，进行判断。相比起来，gp的处理逻辑清晰易懂</p>
</blockquote>
<blockquote>
<p>怀疑是不是因为这么实现的话，在升级pg内核的时候，难度会小很多。</p>
</blockquote>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Flow</span> {
 NodeTag    type;     <span style=color:#75715e>// T_Flow 
</span><span style=color:#75715e></span><span style=color:#75715e>/*
</span><span style=color:#75715e>typedef enum FlowType
</span><span style=color:#75715e>{
</span><span style=color:#75715e> FLOW_UNDEFINED,    // used prior to calculation of type of derived flow 
</span><span style=color:#75715e> FLOW_SINGLETON,    // flow has single stream  单向流动，主要指的是gather
</span><span style=color:#75715e> FLOW_REPLICATED,   // flow is replicated across IOPs  广播
</span><span style=color:#75715e> FLOW_PARTITIONED,  // flow is partitioned across IOPs 重分布
</span><span style=color:#75715e>} FlowType;
</span><span style=color:#75715e>*/</span> 
 FlowType flotype;        <span style=color:#75715e>// Type of flow produced by the plan. 
</span><span style=color:#75715e></span>
<span style=color:#75715e>// typedef enum Movement
</span><span style=color:#75715e>// {
</span><span style=color:#75715e>//  MOVEMENT_NONE,   /* No motion required. */
</span><span style=color:#75715e>//  MOVEMENT_FOCUS,   /* Fixed motion to a single segment. */
</span><span style=color:#75715e>//  MOVEMENT_BROADCAST,  /* Broadcast motion. */
</span><span style=color:#75715e>//  MOVEMENT_REPARTITION, /* Hash motion */
</span><span style=color:#75715e>//  MOVEMENT_LIM_RESTRUCT, /* Restructure a Limit node into three stages */
</span><span style=color:#75715e>//  MOVEMENT_EXPLICIT  /* Move tuples to the segments specified in the segid column */
</span><span style=color:#75715e>// } Movement;
</span><span style=color:#75715e></span> Movement req_move;       <span style=color:#75715e>// What motion (including none) should be applied to this Plan&#39;s output. 
</span><span style=color:#75715e></span>
 CdbLocusType locustype;  <span style=color:#75715e>// Locus type (optimizer flow characterization). 表示数据的分布方式，用于生成执行计划是确定motion的节点
</span><span style=color:#75715e></span> <span style=color:#66d9ef>int</span>   segindex;          <span style=color:#75715e>// Segment index of singleton flow. 
</span><span style=color:#75715e></span> <span style=color:#66d9ef>int</span>   numsegments;
 List  <span style=color:#f92672>*</span>hashExprs;  
 List  <span style=color:#f92672>*</span>hashOpfamilies;
 AttrNumber segidColIdx;
 <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Flow</span>  <span style=color:#f92672>*</span>flow_before_req_move;
} Flow;
</code></pre></div><p>这里做个总结，所有的执行计划中，涉及到motion算子的路径大致如下图</p>
<p><img src=/posts/postgres/images/planall.svg alt=planall></p>
<p>上图中使用颜色标记的模块就是gp的主要的改动模块
可以看到，相比于原生pg，他在join和聚合算子这里一类的block算子的操作上修改的比较多</p>
<p>关于执行计划的生成，简单的理解大致就是需要在block算子上进行分析，看是否需要添加额外的数据重分布操作，常见的block操作有join，sort，以及一些聚合操作等，然后在具体的细节上进行分析，且使用计算代价和数据分布等方式决定具体的并发度</p>
<ul>
<li>普通计划生成</li>
<li>处理block算子
<ol>
<li>语义分析是否需要并发</li>
<li>代价计算多少并发度</li>
</ol>
</li>
</ul>
<h3 id=antdb-vs-greenplum>
AntDB VS GreenPlum
<a href=#antdb-vs-greenplum class=h-anchor aria-hidden=true>#</a>
</h3>
<p>上面对一个稍微复杂的语句为例，可以回答了执行计划怎么解释，执行计划怎么执行，以及执行计划怎么生成</p>
<p>⏰ 关于执行计划的生成方式，还有细节需要调研</p>
<p>这里使用几个例子，对比下AntDB和GreenPlum的差别</p>
<p>这里使用的例子都没有进行特殊的配置，其中AntDB<code>set pgxc_enable_remote_query=false;</code>，记录的是前5次的执行计划，换言之，是使用到<code>boundParams</code>的执行计划，而不是“普遍”的执行计划。GreenPlum没有使用ORCA优化器，使用的优化器是PG的原生优化器，具体的信息如下</p>
<table>
<thead>
<tr>
<th>AntDB</th>
<th>GreenPlum</th>
</tr>
</thead>
<tbody>
<tr>
<td>ADB6_2_STABLE</td>
<td>6X_STABLE</td>
</tr>
<tr>
<td>PostgreSQL 13.3</td>
<td>PostgreSQL 9.4.26</td>
</tr>
</tbody>
</table>
<blockquote>
<ol>
<li>部分执行计划由于postgres的内核差异可能有所不同</li>
<li>GreenPlum的6X_STABLE是上一个发行时间是2019-03-20</li>
</ol>
</blockquote>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>table</span> t1 <span style=color:#66d9ef>AS</span> <span style=color:#66d9ef>SELECT</span> <span style=color:#66d9ef>g</span> c1, <span style=color:#66d9ef>g</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>as</span> c2 <span style=color:#66d9ef>FROM</span> 
generate_series(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>3000</span>) <span style=color:#66d9ef>g</span> DISTRIBUTED <span style=color:#66d9ef>BY</span> (c1);  

<span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>table</span> t2 <span style=color:#66d9ef>AS</span> <span style=color:#66d9ef>SELECT</span> <span style=color:#66d9ef>g</span> c1, <span style=color:#66d9ef>g</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>as</span> c2 <span style=color:#66d9ef>FROM</span> 
generate_series(<span style=color:#ae81ff>500</span>, <span style=color:#ae81ff>3500</span>) <span style=color:#66d9ef>g</span> DISTRIBUTED <span style=color:#66d9ef>BY</span> (c1);  

                          <span style=color:#66d9ef>Table</span> <span style=color:#e6db74>&#34;public.t1&#34;</span>
 <span style=color:#66d9ef>Column</span> <span style=color:#f92672>|</span>  <span style=color:#66d9ef>Type</span>   <span style=color:#f92672>|</span> Modifiers <span style=color:#f92672>|</span> <span style=color:#66d9ef>Storage</span> <span style=color:#f92672>|</span> Stats target <span style=color:#f92672>|</span> Description 
<span style=color:#75715e>--------+---------+-----------+---------+--------------+-------------
</span><span style=color:#75715e></span> c1     <span style=color:#f92672>|</span> integer <span style=color:#f92672>|</span>           <span style=color:#f92672>|</span> plain   <span style=color:#f92672>|</span>              <span style=color:#f92672>|</span> 
 c2     <span style=color:#f92672>|</span> integer <span style=color:#f92672>|</span>           <span style=color:#f92672>|</span> plain   <span style=color:#f92672>|</span>              <span style=color:#f92672>|</span> 
Distributed <span style=color:#66d9ef>by</span>: (c1)
                                    <span style=color:#66d9ef>Table</span> <span style=color:#e6db74>&#34;public.t1&#34;</span>
 <span style=color:#66d9ef>Column</span> <span style=color:#f92672>|</span>  <span style=color:#66d9ef>Type</span>   <span style=color:#f92672>|</span> <span style=color:#66d9ef>Collation</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>Nullable</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>Default</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>Storage</span> <span style=color:#f92672>|</span> Stats target <span style=color:#f92672>|</span> Description 
<span style=color:#75715e>--------+---------+-----------+----------+---------+---------+--------------+-------------
</span><span style=color:#75715e></span> c1     <span style=color:#f92672>|</span> integer <span style=color:#f92672>|</span>           <span style=color:#f92672>|</span>          <span style=color:#f92672>|</span>         <span style=color:#f92672>|</span> plain   <span style=color:#f92672>|</span>              <span style=color:#f92672>|</span> 
 c2     <span style=color:#f92672>|</span> integer <span style=color:#f92672>|</span>           <span style=color:#f92672>|</span>          <span style=color:#f92672>|</span>         <span style=color:#f92672>|</span> plain   <span style=color:#f92672>|</span>              <span style=color:#f92672>|</span> 
DISTRIBUTE <span style=color:#66d9ef>BY</span> HASH(c1) <span style=color:#66d9ef>TO</span> NODE(dn1, dn2)
<span style=color:#66d9ef>Access</span> <span style=color:#66d9ef>method</span>: heap

<span style=color:#66d9ef>create</span> <span style=color:#66d9ef>table</span> t1 (c1 integer, c2 integer) DISTRIBUTE <span style=color:#66d9ef>BY</span> HASH(c1) <span style=color:#66d9ef>TO</span> NODE(dn1, dn2);  
<span style=color:#66d9ef>create</span> <span style=color:#66d9ef>table</span> t2 (c1 integer, c2 integer) DISTRIBUTE <span style=color:#66d9ef>BY</span> HASH(c1) <span style=color:#66d9ef>TO</span> NODE(dn1, dn2);  

<span style=color:#66d9ef>insert</span> <span style=color:#66d9ef>into</span> t1 <span style=color:#66d9ef>SELECT</span> <span style=color:#66d9ef>g</span> c1, <span style=color:#66d9ef>g</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>as</span> c2 <span style=color:#66d9ef>FROM</span> generate_series(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>3000</span>) <span style=color:#66d9ef>g</span> ;  
<span style=color:#66d9ef>insert</span> <span style=color:#66d9ef>into</span> t2 <span style=color:#66d9ef>SELECT</span> <span style=color:#66d9ef>g</span> c1, <span style=color:#66d9ef>g</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>as</span> c2 <span style=color:#66d9ef>FROM</span> generate_series(<span style=color:#ae81ff>500</span>, <span style=color:#ae81ff>3500</span>) <span style=color:#66d9ef>g</span> ;  
</code></pre></div><p>首先分析简单的SQL语句，这里的gp默认使用hash分布，但是和AntDB使用hash函数不一样，所以在具体的节点上的数据不一样，但是总的数据是一样的</p>
<h5 id=sql1-分区键join>
SQL1 分区键join
<a href=#sql1-%e5%88%86%e5%8c%ba%e9%94%aejoin class=h-anchor aria-hidden=true>#</a>
</h5>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> t1, t2 <span style=color:#66d9ef>where</span> t1.c1 <span style=color:#f92672>=</span> t2.c1;  

                               QUERY PLAN                               
<span style=color:#75715e>---------------------------------------------------------------------------------------
</span><span style=color:#75715e></span> <span style=color:#66d9ef>Cluster</span> Gather  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>179</span>.<span style=color:#ae81ff>81</span>..<span style=color:#ae81ff>2196</span>.<span style=color:#ae81ff>42</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>6384</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>16</span>)
   <span style=color:#f92672>-&gt;</span>  Merge <span style=color:#66d9ef>Join</span>  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>179</span>.<span style=color:#ae81ff>81</span>..<span style=color:#ae81ff>281</span>.<span style=color:#ae81ff>22</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>3192</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>16</span>)
         Merge Cond: (t1.c1 <span style=color:#f92672>=</span> t2.c1)
         <span style=color:#f92672>-&gt;</span>  Sort  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>89</span>.<span style=color:#ae81ff>90</span>..<span style=color:#ae81ff>92</span>.<span style=color:#ae81ff>73</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1130</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>)
               Sort <span style=color:#66d9ef>Key</span>: t1.c1
               <span style=color:#f92672>-&gt;</span>  Seq Scan <span style=color:#66d9ef>on</span> t1  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span>..<span style=color:#ae81ff>32</span>.<span style=color:#ae81ff>60</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1130</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>)
         <span style=color:#f92672>-&gt;</span>  Sort  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>89</span>.<span style=color:#ae81ff>90</span>..<span style=color:#ae81ff>92</span>.<span style=color:#ae81ff>73</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1130</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>)
               Sort <span style=color:#66d9ef>Key</span>: t2.c1
               <span style=color:#f92672>-&gt;</span>  Seq Scan <span style=color:#66d9ef>on</span> t2  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span>..<span style=color:#ae81ff>32</span>.<span style=color:#ae81ff>60</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1130</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>)
(<span style=color:#ae81ff>9</span> <span style=color:#66d9ef>rows</span>)

                                  QUERY PLAN                                  
<span style=color:#75715e>---------------------------------------------------------------------------------------
</span><span style=color:#75715e></span> Gather Motion <span style=color:#ae81ff>2</span>:<span style=color:#ae81ff>1</span>  (slice1; segments: <span style=color:#ae81ff>2</span>)  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>.<span style=color:#ae81ff>23</span>..<span style=color:#ae81ff>4</span>.<span style=color:#ae81ff>48</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>10</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>16</span>)
   <span style=color:#f92672>-&gt;</span>  Hash <span style=color:#66d9ef>Join</span>  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>.<span style=color:#ae81ff>23</span>..<span style=color:#ae81ff>4</span>.<span style=color:#ae81ff>48</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>5</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>16</span>)
         Hash Cond: (t2.c1 <span style=color:#f92672>=</span> t1.c1)
         <span style=color:#f92672>-&gt;</span>  Seq Scan <span style=color:#66d9ef>on</span> t2  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span>..<span style=color:#ae81ff>2</span>.<span style=color:#ae81ff>11</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>6</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>)
         <span style=color:#f92672>-&gt;</span>  Hash  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>.<span style=color:#ae81ff>10</span>..<span style=color:#ae81ff>2</span>.<span style=color:#ae81ff>10</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>5</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>)
               <span style=color:#f92672>-&gt;</span>  Seq Scan <span style=color:#66d9ef>on</span> t1  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span>..<span style=color:#ae81ff>2</span>.<span style=color:#ae81ff>10</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>5</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>)
 Optimizer: Postgres query optimizer
(<span style=color:#ae81ff>7</span> <span style=color:#66d9ef>rows</span>)

</code></pre></div><p>分布方式一样的表使用分区键进行join，相同的数据都在同一个节点上，所以除了<code>Gather</code>之外，不需要额外的<code>motion</code>操作</p>
<h5 id=sql2-分区键join非分区键>
SQL2 分区键join非分区键
<a href=#sql2-%e5%88%86%e5%8c%ba%e9%94%aejoin%e9%9d%9e%e5%88%86%e5%8c%ba%e9%94%ae class=h-anchor aria-hidden=true>#</a>
</h5>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> t1, t2 <span style=color:#66d9ef>where</span> t1.c1 <span style=color:#f92672>=</span> t2.c2;  

                                               QUERY PLAN      
<span style=color:#75715e>---------------------------------------------------------------------------------------
</span><span style=color:#75715e></span> <span style=color:#66d9ef>Cluster</span> Gather  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>1047</span>.<span style=color:#ae81ff>72</span>..<span style=color:#ae81ff>3575</span>.<span style=color:#ae81ff>80</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>6384</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>16</span>)
   Remote node: <span style=color:#ae81ff>16386</span>,<span style=color:#ae81ff>16387</span>
   <span style=color:#f92672>-&gt;</span>  Hash <span style=color:#66d9ef>Join</span>  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>47</span>.<span style=color:#ae81ff>73</span>..<span style=color:#ae81ff>660</span>.<span style=color:#ae81ff>60</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>3192</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>16</span>)
         <span style=color:#66d9ef>Output</span>: t1.c1, t1.c2, t2.c1, t2.c2
         Hash Cond: (t2.c2 <span style=color:#f92672>=</span> t1.c1)
         <span style=color:#f92672>-&gt;</span>  <span style=color:#66d9ef>Cluster</span> Reduce  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>.<span style=color:#ae81ff>00</span>..<span style=color:#ae81ff>387</span>.<span style=color:#ae81ff>60</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1130</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>)
               Reduce: (<span style=color:#e6db74>&#39;[0:1]={16386,16387}&#39;</span>::oid[])[COALESCE(hash_combin_mod(<span style=color:#ae81ff>2</span>, hashint4(t2.c2)), <span style=color:#ae81ff>0</span>)]
               <span style=color:#f92672>-&gt;</span>  Seq Scan <span style=color:#66d9ef>on</span> <span style=color:#66d9ef>public</span>.t2  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span>..<span style=color:#ae81ff>32</span>.<span style=color:#ae81ff>60</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1130</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>)
                     <span style=color:#66d9ef>Output</span>: t2.c1, t2.c2
                     Remote node: <span style=color:#ae81ff>16386</span>,<span style=color:#ae81ff>16387</span>
         <span style=color:#f92672>-&gt;</span>  Hash  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>32</span>.<span style=color:#ae81ff>60</span>..<span style=color:#ae81ff>32</span>.<span style=color:#ae81ff>60</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1130</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>)
               <span style=color:#66d9ef>Output</span>: t1.c1, t1.c2
               <span style=color:#f92672>-&gt;</span>  Seq Scan <span style=color:#66d9ef>on</span> <span style=color:#66d9ef>public</span>.t1  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span>..<span style=color:#ae81ff>32</span>.<span style=color:#ae81ff>60</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1130</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>)
                     <span style=color:#66d9ef>Output</span>: t1.c1, t1.c2
                     Remote node: <span style=color:#ae81ff>16386</span>,<span style=color:#ae81ff>16387</span>
(<span style=color:#ae81ff>15</span> <span style=color:#66d9ef>rows</span>)

                                          QUERY PLAN         
<span style=color:#75715e>---------------------------------------------------------------------------------------
</span><span style=color:#75715e></span> Gather Motion <span style=color:#ae81ff>2</span>:<span style=color:#ae81ff>1</span>  (slice2; segments: <span style=color:#ae81ff>2</span>)  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>.<span style=color:#ae81ff>23</span>..<span style=color:#ae81ff>4</span>.<span style=color:#ae81ff>70</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>10</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>16</span>)
   <span style=color:#66d9ef>Output</span>: t1.c1, t1.c2, t2.c1, t2.c2
   <span style=color:#f92672>-&gt;</span>  Hash <span style=color:#66d9ef>Join</span>  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>.<span style=color:#ae81ff>23</span>..<span style=color:#ae81ff>4</span>.<span style=color:#ae81ff>70</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>5</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>16</span>)
         <span style=color:#66d9ef>Output</span>: t1.c1, t1.c2, t2.c1, t2.c2
         Hash Cond: (t2.c2 <span style=color:#f92672>=</span> t1.c1)
         <span style=color:#f92672>-&gt;</span>  Redistribute Motion <span style=color:#ae81ff>2</span>:<span style=color:#ae81ff>2</span>  (slice1; segments: <span style=color:#ae81ff>2</span>)  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span>..<span style=color:#ae81ff>2</span>.<span style=color:#ae81ff>33</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>6</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>)
               <span style=color:#66d9ef>Output</span>: t2.c1, t2.c2
               Hash <span style=color:#66d9ef>Key</span>: t2.c2
               <span style=color:#f92672>-&gt;</span>  Seq Scan <span style=color:#66d9ef>on</span> <span style=color:#66d9ef>public</span>.t2  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span>..<span style=color:#ae81ff>2</span>.<span style=color:#ae81ff>11</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>6</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>)
                     <span style=color:#66d9ef>Output</span>: t2.c1, t2.c2
         <span style=color:#f92672>-&gt;</span>  Hash  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>.<span style=color:#ae81ff>10</span>..<span style=color:#ae81ff>2</span>.<span style=color:#ae81ff>10</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>5</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>)
               <span style=color:#66d9ef>Output</span>: t1.c1, t1.c2
               <span style=color:#f92672>-&gt;</span>  Seq Scan <span style=color:#66d9ef>on</span> <span style=color:#66d9ef>public</span>.t1  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span>..<span style=color:#ae81ff>2</span>.<span style=color:#ae81ff>10</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>5</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>)
                     <span style=color:#66d9ef>Output</span>: t1.c1, t1.c2
 Optimizer: Postgres query optimizer
(<span style=color:#ae81ff>15</span> <span style=color:#66d9ef>rows</span>)

</code></pre></div><p>分区键join非分区键，对于使用非分区键的表，需要进行数据重分布，使得每个节点上key数据相同</p>
<h5 id=sql3-非分区键join非分区键>
SQL3 非分区键join非分区键
<a href=#sql3-%e9%9d%9e%e5%88%86%e5%8c%ba%e9%94%aejoin%e9%9d%9e%e5%88%86%e5%8c%ba%e9%94%ae class=h-anchor aria-hidden=true>#</a>
</h5>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> t1, t2 <span style=color:#66d9ef>where</span> t1.c2 <span style=color:#f92672>=</span> t2.c2;  

                                         QUERY PLAN                               
<span style=color:#75715e>---------------------------------------------------------------------------------------
</span><span style=color:#75715e></span> Gather Motion <span style=color:#ae81ff>2</span>:<span style=color:#ae81ff>1</span>  (slice2; <span style=color:#f92672>`</span>segment<span style=color:#f92672>`</span>s: <span style=color:#ae81ff>2</span>)  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>.<span style=color:#ae81ff>25</span>..<span style=color:#ae81ff>4</span>.<span style=color:#ae81ff>82</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>10</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>16</span>)
   <span style=color:#66d9ef>Output</span>: t1.c1, t1.c2, t2.c1, t2.c2
   <span style=color:#f92672>-&gt;</span>  Hash <span style=color:#66d9ef>Join</span>  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>.<span style=color:#ae81ff>25</span>..<span style=color:#ae81ff>4</span>.<span style=color:#ae81ff>82</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>5</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>16</span>)
         <span style=color:#66d9ef>Output</span>: t1.c1, t1.c2, t2.c1, t2.c2
         Hash Cond: (t1.c2 <span style=color:#f92672>=</span> t2.c2)
         <span style=color:#f92672>-&gt;</span>  Broadcast Motion <span style=color:#ae81ff>2</span>:<span style=color:#ae81ff>2</span>  (slice1; <span style=color:#f92672>`</span>segment<span style=color:#f92672>`</span>s: <span style=color:#ae81ff>2</span>)  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span>..<span style=color:#ae81ff>2</span>.<span style=color:#ae81ff>40</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>10</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>)
               <span style=color:#66d9ef>Output</span>: t1.c1, t1.c2
               <span style=color:#f92672>-&gt;</span>  Seq Scan <span style=color:#66d9ef>on</span> <span style=color:#66d9ef>public</span>.t1  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span>..<span style=color:#ae81ff>2</span>.<span style=color:#ae81ff>10</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>5</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>)
                     <span style=color:#66d9ef>Output</span>: t1.c1, t1.c2
         <span style=color:#f92672>-&gt;</span>  Hash  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>.<span style=color:#ae81ff>11</span>..<span style=color:#ae81ff>2</span>.<span style=color:#ae81ff>11</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>6</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>)
               <span style=color:#66d9ef>Output</span>: t2.c1, t2.c2
               <span style=color:#f92672>-&gt;</span>  Seq Scan <span style=color:#66d9ef>on</span> <span style=color:#66d9ef>public</span>.t2  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span>..<span style=color:#ae81ff>2</span>.<span style=color:#ae81ff>11</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>6</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>)
                     <span style=color:#66d9ef>Output</span>: t2.c1, t2.c2
 Optimizer: Postgres query optimizer
(<span style=color:#ae81ff>14</span> <span style=color:#66d9ef>rows</span>)

                                  QUERY PLAN                               
<span style=color:#75715e>-------------------------------------------------------------------------------
</span><span style=color:#75715e></span> <span style=color:#66d9ef>Cluster</span> Gather  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>1047</span>.<span style=color:#ae81ff>72</span>..<span style=color:#ae81ff>3802</span>.<span style=color:#ae81ff>09</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>6384</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>16</span>)
   Remote node: <span style=color:#ae81ff>16386</span>,<span style=color:#ae81ff>16387</span>
   <span style=color:#f92672>-&gt;</span>  Hash <span style=color:#66d9ef>Join</span>  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>47</span>.<span style=color:#ae81ff>73</span>..<span style=color:#ae81ff>886</span>.<span style=color:#ae81ff>89</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>3192</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>16</span>)
         <span style=color:#66d9ef>Output</span>: t1.c1, t1.c2, t2.c1, t2.c2
         Hash Cond: (t1.c2 <span style=color:#f92672>=</span> t2.c2)
         <span style=color:#f92672>-&gt;</span>  <span style=color:#66d9ef>Cluster</span> Reduce  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>.<span style=color:#ae81ff>00</span>..<span style=color:#ae81ff>387</span>.<span style=color:#ae81ff>60</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>2260</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>)
               Reduce: <span style=color:#66d9ef>unnest</span>(<span style=color:#e6db74>&#39;[0:1]={16386,16387}&#39;</span>::oid[])
               <span style=color:#f92672>-&gt;</span>  Seq Scan <span style=color:#66d9ef>on</span> <span style=color:#66d9ef>public</span>.t1  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span>..<span style=color:#ae81ff>32</span>.<span style=color:#ae81ff>60</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1130</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>)
                     <span style=color:#66d9ef>Output</span>: t1.c1, t1.c2
                     Remote node: <span style=color:#ae81ff>16386</span>,<span style=color:#ae81ff>16387</span>
         <span style=color:#f92672>-&gt;</span>  Hash  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>32</span>.<span style=color:#ae81ff>60</span>..<span style=color:#ae81ff>32</span>.<span style=color:#ae81ff>60</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1130</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>)
               <span style=color:#66d9ef>Output</span>: t2.c1, t2.c2
               <span style=color:#f92672>-&gt;</span>  Seq Scan <span style=color:#66d9ef>on</span> <span style=color:#66d9ef>public</span>.t2  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span>..<span style=color:#ae81ff>32</span>.<span style=color:#ae81ff>60</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1130</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>)
                     <span style=color:#66d9ef>Output</span>: t2.c1, t2.c2
                     Remote node: <span style=color:#ae81ff>16386</span>,<span style=color:#ae81ff>16387</span>
(<span style=color:#ae81ff>15</span> <span style=color:#66d9ef>rows</span>)
</code></pre></div><p>非分区键join非分区键，需要在同一个节点上得到相同的数据，要么两表使用相同的hash方式重分布，要么一个表<code>存在在每一个节点上</code>，这里选择对t1进行广播。</p>
<h5 id=sql4-聚合操作>
SQL4 聚合操作
<a href=#sql4-%e8%81%9a%e5%90%88%e6%93%8d%e4%bd%9c class=h-anchor aria-hidden=true>#</a>
</h5>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql>benchmarksql<span style=color:#f92672>=#</span> <span style=color:#66d9ef>explain</span> <span style=color:#66d9ef>select</span>  <span style=color:#66d9ef>sum</span>(c2) <span style=color:#66d9ef>from</span> t1 <span style=color:#66d9ef>group</span> <span style=color:#66d9ef>by</span> c2;
                                  QUERY PLAN                                  
<span style=color:#75715e>------------------------------------------------------------------------------
</span><span style=color:#75715e></span> Finalize GroupAggregate  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>183</span>.<span style=color:#ae81ff>13</span>..<span style=color:#ae81ff>239</span>.<span style=color:#ae81ff>38</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1500</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>12</span>)
   <span style=color:#66d9ef>Group</span> <span style=color:#66d9ef>Key</span>: c2
   <span style=color:#f92672>-&gt;</span>  <span style=color:#66d9ef>Cluster</span> Merge Gather  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>183</span>.<span style=color:#ae81ff>13</span>..<span style=color:#ae81ff>209</span>.<span style=color:#ae81ff>38</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>3000</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>12</span>)
         Sort <span style=color:#66d9ef>Key</span>: c2
         <span style=color:#f92672>-&gt;</span>  <span style=color:#66d9ef>Partial</span> GroupAggregate  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>123</span>.<span style=color:#ae81ff>13</span>..<span style=color:#ae81ff>149</span>.<span style=color:#ae81ff>38</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1500</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>12</span>)
               <span style=color:#66d9ef>Group</span> <span style=color:#66d9ef>Key</span>: c2
               <span style=color:#f92672>-&gt;</span>  Sort  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>123</span>.<span style=color:#ae81ff>13</span>..<span style=color:#ae81ff>126</span>.<span style=color:#ae81ff>88</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1500</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>)
                     Sort <span style=color:#66d9ef>Key</span>: c2
                     <span style=color:#f92672>-&gt;</span>  Seq Scan <span style=color:#66d9ef>on</span> t1  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span>..<span style=color:#ae81ff>44</span>.<span style=color:#ae81ff>00</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1500</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>)

                                             QUERY PLAN                                              
<span style=color:#75715e>-----------------------------------------------------------------------------------------------------
</span><span style=color:#75715e></span> Gather Motion <span style=color:#ae81ff>2</span>:<span style=color:#ae81ff>1</span>  (slice2; segments: <span style=color:#ae81ff>2</span>)  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>154</span>.<span style=color:#ae81ff>00</span>..<span style=color:#ae81ff>184</span>.<span style=color:#ae81ff>00</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>3000</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>12</span>)
   <span style=color:#f92672>-&gt;</span>  HashAggregate  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>154</span>.<span style=color:#ae81ff>00</span>..<span style=color:#ae81ff>184</span>.<span style=color:#ae81ff>00</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1500</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>12</span>)
         <span style=color:#66d9ef>Group</span> <span style=color:#66d9ef>Key</span>: t1.c2
         <span style=color:#f92672>-&gt;</span>  Redistribute Motion <span style=color:#ae81ff>2</span>:<span style=color:#ae81ff>2</span>  (slice1; segments: <span style=color:#ae81ff>2</span>)  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>49</span>.<span style=color:#ae81ff>00</span>..<span style=color:#ae81ff>109</span>.<span style=color:#ae81ff>00</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1500</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>12</span>)
               Hash <span style=color:#66d9ef>Key</span>: t1.c2
               <span style=color:#f92672>-&gt;</span>  HashAggregate  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>49</span>.<span style=color:#ae81ff>00</span>..<span style=color:#ae81ff>49</span>.<span style=color:#ae81ff>00</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1500</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>12</span>)
                     <span style=color:#66d9ef>Group</span> <span style=color:#66d9ef>Key</span>: t1.c2
                     <span style=color:#f92672>-&gt;</span>  Seq Scan <span style=color:#66d9ef>on</span> t1  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span>..<span style=color:#ae81ff>34</span>.<span style=color:#ae81ff>00</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1500</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>)

</code></pre></div><p>这里的聚合操作两者之间有了明显的区别，AntDB在最后选择数据在master汇总，然后再进行了<code>GroupAggregate</code>操作，但是GP在这之前， 选择使用<code>Redistribute Motion</code>操作，把数据重分布之后，计算之后再进行汇总，前面提到master上只有一个<code>Gather</code>这就是一个佐证，master上的<code>Gather</code>操作最多的操作是对收集的数据进行排序，且这不是一个显示的算子操作</p>
<p>这里可以看出，对于执行计划，两者之间在关键路径的选择上没有太多的差别，但是由于在具体的算子的实现差异，导致执行计划在细节上有所不同</p>
<p>另外，这里对join的执行计划关于motion进行简单的总结</p>
<ul>
<li>join两边的字段都是分布键，没有motion操作，<code>FQS此时应该是把语句直接发送到DN，而不是使用`_REMOTE_TABLE_QUERY_`把数据读到master再join </code>
<ol>
<li>如果使用条件，则对表达式进行hash计算执行节点，如果能计算到一个执行节点，则限定一个节点执行</li>
</ol>
</li>
<li>大表join大表
<ol>
<li>其中一个join字段是分布键，另一个不是，此时非分布键的表会被重分布。</li>
<li>都不是分区键，两表都需要重分布</li>
<li>如果join字段使用条件，则对表达式进行hash计算执行节点，如果能计算到一个执行节点，则限定一个节点执行，重分布的motion还是继续在多个节点执行</li>
</ol>
</li>
<li>小表join大表
<ol>
<li>小表用了分布键，小表广播</li>
<li>大表用了分布键，小表重分布</li>
<li>都不是分布键，小表广播</li>
<li>如果join字段使用条件，则对表达式进行hash计算执行节点，如果能计算到一个执行节点，则限定一个节点执行，重分布的motion还是继续在多个节点执行，这里需要考虑大表。</li>
</ol>
</li>
</ul>
<hr>
<h2 id=简单的性能对比>
简单的性能对比
<a href=#%e7%ae%80%e5%8d%95%e7%9a%84%e6%80%a7%e8%83%bd%e5%af%b9%e6%af%94 class=h-anchor aria-hidden=true>#</a>
</h2>
<p>AntDB<br>
单机集群，2dn，虚拟机
GP
单机集群，2Segment，虚拟机中的docker</p>
<ol>
<li>前面的例子中的语句，时间对比为<code>Execution Time: 3404.429 ms</code>和<code> Execution time: 1043.784 ms</code></li>
<li>来自TIDB的<a href=https://www.bookstack.cn/read/tidb-5.0-zh/benchmark-v5.0-performance-benchmarking-with-tpch.md>性能测试</a>，对比了gp和TiFlash和spark的性能，GP在多数场景下弱于其他两个</li>
<li>[ClickBench] (<a href=https://benchmark.clickhouse.com/>https://benchmark.clickhouse.com/</a>)</li>
<li><a href=https://zhuanlan.zhihu.com/p/54907288>开源OLAP引擎哪个快？ (Presto、HAWQ、ClickHouse、GreenPlum)</a></li>
</ol>
<h2 id=总结>
总结
<a href=#%e6%80%bb%e7%bb%93 class=h-anchor aria-hidden=true>#</a>
</h2>
<p>🥪 两者之间最终目标一致，执行器框架类似<code>Volcano</code>，但是GP实现的更优雅，简洁<br>
🥙 AntDBcluster算子实现复杂，特别是reduce操作，在执行的时候甚至会启动额外的进程<br>
🍚 gp代码直接嵌入到pg内核中，代码结构清晰，逻辑简单易懂，层次分明。但是可能对pg内核升级有一定的阻碍<br>
🍙 AntDB代码使用宏控制，和pg的代码具有更强的割裂感，也许是借鉴的pg-xc，个人感觉类似插件，优点是内核升级稍微简单一点点 <br>
🍥 GP使用额外的网络模块来进行数据传输，libpq只是用来传输一些控制信息，且单独的网络模块，对于问题的排查定位分析更有利<br>
🥮 AntDB使用libpq进行数据传输，且传输模块和reduce算子紧耦合，分析难度大，暂时没有深入分析<br>
🍱 GP主打AP，在当前分析的版本中，对于AP而言，还有提升的空间，例如向量化，codegen等<br>
🍛 GP默认优化器是基于cascades框架的ORCA，号称是最先经的执行器<br>
🍠 AntDB中FQS快，我觉得不能说他好，只能说我们Cluster做的不够好，例如更精细的执行调度</p>
<p>越总结越迷糊，但是AntDB可以在GP上借鉴到许多东西，GP看下来更多得只是PG得扩展，我们则更类似插件，只看执行器和优化器得话，改动得目标很明确，代码量估计也不多，麻烦得是单独得网络模块，这个需要从零开始，但是我觉得是有必得，因为从单机到分布式执行，最大得瓶颈就是网络传输，如果想要性能提升或者为了以后支持更多得功能，这个工作是值得的，但是也是艰难的，因为不知道在哪里看见的话，有人想模仿GP，但是在interconnet这一步失败了。这次没有太深入调查这个模块，这里不发表评论~~~<br>
另外还有一个好处就是AntDB 的 PG内核版本高，比起GP有更高的起点，有部分GP在规划中得实现，PG已经完全支持或者部分支持，典型得就是AP得大杀器JIT</p>
<p><del>个人觉得一个项目对于性能得追求有几个重点，一是确定方向，确定架构的性能上限。二是实现这个架构，然后达到架构性能上限。此时有两种选择，要么在单点上挣扎，从细节挤出时间，运用一切可能的技术，例如对于AP，什么向量化，什么JIT，能用就用。要么重新审视架构，确定架构是否有改进的可能，架构上带来的收益肯可能有10，而单点优化，则更多的是针尖上的那么一点点而已</del></p>
<blockquote>
<p><a href=https://zhuanlan.zhihu.com/p/54907288>开源OLAP引擎哪个快？ (Presto、HAWQ、ClickHouse、GreenPlum)</a><br>
<a href=https://cn.greenplum.org/greenplum-distributed-database-kernel-1/>Greenplum 分布式数据库内核揭秘(上篇)</a><br>
<a href=https://cn.greenplum.org/greenplum-distributed-database-kernel-2/>Greenplum 分布式数据库内核揭秘(下篇)</a><br>
<a href=https://blog.csdn.net/chrisy521/article/details/122355490>聊聊Greenplum的那些事</a></p>
</blockquote>
<blockquote>
<p><a href="https://baijiahao.baidu.com/s?id=1707690199529405725">超融合时序数据库 定义未来记忆——MatrixDB4.0发布会实录</a></p>
</blockquote>
<hr>
<h4 id=some-qs>
Some QS
<a href=#some-qs class=h-anchor aria-hidden=true>#</a>
</h4>
<ol>
<li>MPP做TP可行？MPP做TP上限在哪里，再或者超融合？</li>
<li>pg优化器能否有优化标准，ORCA的特点之一就是使用模拟的统计信息和代价模型量化执行计划，保证每一个代码改动都能最优</li>
<li>是否可以仿照GP进行内核优化，当前觉得reduce模块太复杂，性能也不高</li>
<li>GP和AntDB在关于代价这一块都没有太细节的处理，cluster或者motion算子的代价是否需要更详细的模型</li>
<li>其他AP执行器的技术细节</li>
<li>更多的基于pg的产品有哪些</li>
</ol>
<h4 id=some-todo>
Some TODO
<a href=#some-todo class=h-anchor aria-hidden=true>#</a>
</h4>
<p>[] 事务<br>
[] 存储<br>
[] ORCA<br>
[] GP没做的其他AP做了的，或者GP框架下做不了的
[] 对pg的更多可行性的探究</p>
<p><del>数据处理过程上拉到计算层</del>
<del>全局死锁检测</del>
<del>容器化</del>
<del>多态存储</del>
<del>向量化</del>
<del>多周边</del>
<del>进程池</del>
<del>执行进程复用</del></p>
</div>
<div class=pagination>
<div class=pagination__title>
<span class=pagination__title-h>Read other posts</span>
<hr>
</div>
<div class=pagination__buttons>
<span class="button previous">
<a href=https://Esoye.github.io/posts/postgres/remotequery/>
<span class=button__icon>←</span>
<span class=button__text>Postgres RemoteQuery 扩展</span>
</a>
</span>
<span class="button next">
<a href=https://Esoye.github.io/posts/postgres/pgenvbuild/>
<span class=button__text>Postgres 系列数据库搭建</span>
<span class=button__icon>→</span>
</a>
</span>
</div>
</div>
</div>
</div>
<footer class=footer>
<div class=footer__inner>
<a href=/ class=logo style=text-decoration:none>
<span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg>
</span>
<span class=logo__text>Esoye</span>
<span class=logo__cursor></span>
</a>
<div class=copyright>
<span>© 2022 Powered by
<a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span>
<span>Theme created by
<a href=https://twitter.com/panr target=_blank rel=noopener>panr</a></span>
</div>
</div>
</footer>
<script src=https://Esoye.github.io/assets/main.js></script>
<script src=https://Esoye.github.io/assets/prism.js></script>
</div>
</body>
</html>