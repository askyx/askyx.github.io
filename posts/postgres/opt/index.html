<!doctype html><html lang=zh-Hans x-data :class=$store.darkMode.class() :data-theme=$store.darkMode.theme()><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Postgres Optimizer | Askyx's Blog</title>
<link rel=icon href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%2210 0 100 100%22><text y=%22.90em%22 font-size=%2290%22>ğŸŒ±</text></svg>"></link>
<link rel=canonical href=https://askyx.github.io/posts/postgres/opt/><meta name=author content="Askyx"><meta name=description content="æœ¬æ–‡ä»æºç çº§åˆ«è¿›è¡Œä¼˜åŒ–å™¨çš„åˆ†æï¼Œå¯¹Postgresä¼˜åŒ–å™¨ä»£ç è°ƒç ”ï¼Œå…·ä½“åŒ…æ‹¬ä»–çš„æ•°æ®ç»“æ„ï¼Œä»¥åŠå…·ä½“çš„ä»£ç æ¶æ„å®ç°ä»¥åŠæ ¸å¿ƒç®—æ³•ç­‰"><meta name=keywords content="æ•°æ®åº“,Postgres,ä¼˜åŒ–å™¨"><meta name=generator content="Hugo 0.121.0"><meta property="og:title" content="Postgres Optimizer"><meta property="og:description" content="æœ¬æ–‡ä»æºç çº§åˆ«è¿›è¡Œä¼˜åŒ–å™¨çš„åˆ†æï¼Œå¯¹Postgresä¼˜åŒ–å™¨ä»£ç è°ƒç ”ï¼Œå…·ä½“åŒ…æ‹¬ä»–çš„æ•°æ®ç»“æ„ï¼Œä»¥åŠå…·ä½“çš„ä»£ç æ¶æ„å®ç°ä»¥åŠæ ¸å¿ƒç®—æ³•ç­‰"><meta property="og:type" content="article"><meta property="og:url" content="https://askyx.github.io/posts/postgres/opt/"><meta property="og:image" content="https://askyx.github.io/img/global-background.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-22T09:24:24+08:00"><meta property="article:modified_time" content="2025-07-16T00:21:58+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://askyx.github.io/img/global-background.jpg"><meta name=twitter:title content="Postgres Optimizer"><meta name=twitter:description content="æœ¬æ–‡ä»æºç çº§åˆ«è¿›è¡Œä¼˜åŒ–å™¨çš„åˆ†æï¼Œå¯¹Postgresä¼˜åŒ–å™¨ä»£ç è°ƒç ”ï¼Œå…·ä½“åŒ…æ‹¬ä»–çš„æ•°æ®ç»“æ„ï¼Œä»¥åŠå…·ä½“çš„ä»£ç æ¶æ„å®ç°ä»¥åŠæ ¸å¿ƒç®—æ³•ç­‰"><link rel=stylesheet href=/css/output.min.css><style>pre{padding:1em;overflow:auto}</style><link rel=stylesheet href=/css/custom.css><script defer src=https://cdn.jsdelivr.net/npm/alpinejs@3/dist/cdn.min.js integrity="sha256-PtHu0lJIiSHfZeNj1nFd6wTX+Squ255SGZ/fc8seCtM=" crossorigin=anonymous></script></head><body x-data="{
    flip: false,
  }"><div id=dream-global-bg></div><nav x-data="{ isSticky: false }" x-init="window.addEventListener('scroll', () => { isSticky = window.scrollY > 30 })" class="sticky top-0 z-30 mt-4 lg:mt-8 py-4" :class="{ 'bg-base-100 shadow-lg dark:border-b dark:border-base-content/30': isSticky }"><div class="container flex justify-between px-4"><section class="flex items-center gap-4"><div class="avatar cursor-pointer hover:avatar-online" @click="flip = !flip" title="Flip it!"><div class="h-10 rounded-full"><img src=/img/personal/avatar.jpg alt="Askyx's Blog"></div></div><div><a href=https://askyx.github.io/ class="text-lg font-semibold cursor-pointer">Askyx's Blog</a><div class="text-base-content/60 text-sm">life is short, use Python</div></div></section><div class="dropdown dropdown-end sm:hidden"><div tabindex=0 role=button class="btn btn-ghost btn-square" aria-label="Select an option"><ion-icon name=menu class=text-2xl></ion-icon></div><ul tabindex=0 class="dropdown-content menu w-36 bg-base-100 rounded-box z-1 shadow-md"><li><div role=link tabindex=0 class="inline-flex items-center p-2 cursor-pointer" @click="flip = !flip" title=About><ion-icon name=information-circle></ion-icon>About</div></li><li><a class="group inline-flex items-center p-2 cursor-pointer" href=/search title=Search><ion-icon name=search></ion-icon>Search</a></li><li><a class="inline-flex items-center p-2 cursor-pointer" href=https://github.com/askyx target=_blank title=GitHub><ion-icon name=logo-github></ion-icon>GitHub</a></li><li><a class="inline-flex items-center p-2 cursor-pointer" href=/posts title=Archives><ion-icon name=archive></ion-icon>Archives</a></li><li><a class="inline-flex items-center p-2 cursor-pointer" href=/tags title="All Tags"><ion-icon name=pricetags></ion-icon>All Tags</a></li><li><a class="inline-flex items-center p-2 cursor-pointer" href=/index.xml title=RSS><ion-icon name=logo-rss></ion-icon>RSS</a></li></ul></div><section class="hidden sm:flex sm:items-center sm:gap-2 md:gap-4"><div role=link tabindex=0 class="text-sm font-semibold cursor-pointer hover:underline" @click="flip = !flip" title=About>About</div><a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary" href=/search title=Search><ion-icon class=group-hover:text-primary-content name=search></ion-icon></a><a class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary" href=https://github.com/askyx target=_blank title=GitHub><ion-icon class=group-hover:text-primary-content name=logo-github></ion-icon></a><div class="dropdown dropdown-end dropdown-hover"><div tabindex=0 role=button class="group inline-flex items-center p-2 rounded-full cursor-pointer hover:bg-primary" aria-label="Select an option"><ion-icon class="group-hover:text-primary-content text-xl" name=menu></ion-icon></div><ul tabindex=0 class="dropdown-content menu w-36 bg-base-100 rounded-box z-1 shadow-xl"><li><a class="inline-flex items-center p-2 cursor-pointer" href=/posts title=Archives><ion-icon name=archive></ion-icon>Archives</a></li><li><a class="inline-flex items-center p-2 cursor-pointer" href=/tags title="All Tags"><ion-icon name=pricetags></ion-icon>All Tags</a></li><li><a class="inline-flex items-center p-2 cursor-pointer" href=/index.xml title=RSS><ion-icon name=logo-rss></ion-icon>RSS</a></li></ul></div></section></div></nav><div class=flip-container :class="{ 'flip-it': flip }"><div class=flipper><div class=front><div class=container><div class="lg:grid lg:grid-cols-4 gap-4 mt-4 px-4"><div class="hidden lg:block"></div><div class=lg:col-span-2><article class="mx-auto prose prose-quoteless dark:prose-invert" id=dream-single-post-main itemscope itemtype=http://schema.org/Article><meta itemprop=name content="Postgres Optimizer"><meta itemprop=description content="æœ¬æ–‡ä»æºç çº§åˆ«è¿›è¡Œä¼˜åŒ–å™¨çš„åˆ†æï¼Œå¯¹Postgresä¼˜åŒ–å™¨ä»£ç è°ƒç ”ï¼Œå…·ä½“åŒ…æ‹¬ä»–çš„æ•°æ®ç»“æ„ï¼Œä»¥åŠå…·ä½“çš„ä»£ç æ¶æ„å®ç°ä»¥åŠæ ¸å¿ƒç®—æ³•ç­‰"><meta itemprop=datePublished content="2022-07-22T09:24:24+08:00"><meta itemprop=dateModified content="2025-07-16T00:21:58+08:00"><meta itemprop=wordCount content="18579"><meta itemprop=image content="https://askyx.github.io/img/global-background.jpg"><meta itemprop=keywords content="æ•°æ®åº“,Postgres,ä¼˜åŒ–å™¨,"><header><h1 itemprop=headline>Postgres Optimizer</h1><p class=text-sm><span data-format=luxon>2022-07-22T09:24:24+08:00</span>
| <span>38 minute read</span>
| <span>Updated at
<span data-format=luxon>2025-07-16T00:21:58+08:00</span></span></p><div class="flex justify-between"><div class="flex items-center"><span>@</span>
<span itemprop=author itemscope itemtype=https://schema.org/Person><span itemprop=name>Askyx</span></span></div></div></header><section id=dream-single-post-content itemprop=articleBody><h1 id=postgres-optimizer-extend>Postgres Optimizer Extend</h1><p>å¯¹æ–‡ç« çš„æŠ€æœ¯æ€§éªŒè¯</p><p>These directories take the Query structure returned by the parser, and
generate a plan used by the executor. The /plan directory generates the
actual output plan, the /path code generates all possible ways to join the
tables, and /prep handles various preprocessing steps for special cases.
/util is utility stuff. /geqo is the separate &ldquo;genetic optimization&rdquo; planner
&mdash; it does a semi-random search through the join tree space, rather than
exhaustively considering all possible join trees. (But each join considered
by /geqo is given to /path to create paths for, so we consider all possible
implementation paths for each specific join pair even in GEQO mode.)</p><ul><li>/plan directory generates the actual output plan</li><li>/path code generates all possible ways to join the tables</li><li>/prep handles various preprocessing steps for special cases</li><li>/util is utility stuff</li><li>/geqo is the separate &ldquo;genetic optimization&rdquo; planner</li></ul><h2 id=paths-and-join-pairs>Paths and Join Pairs</h2><p>During the planning/optimizing process, we build &ldquo;Path&rdquo; trees representing
the different ways of doing a query. We select the cheapest Path that
generates the desired relation and turn it into a Plan to pass to the
executor. (There is pretty nearly a one-to-one correspondence between the
Path and Plan trees, but Path nodes omit info that won&rsquo;t be needed during
planning, and include info needed for planning that won&rsquo;t be needed by the
executor.)</p><ul><li>path æœ€ç»ˆæŒ‡å¯¼ç”Ÿæˆ å…·ä½“çš„ æ‰§è¡Œç®—å­</li></ul><p>The optimizer builds a RelOptInfo structure for each base relation used in
the query. Base rels are either primitive tables, or subquery subselects
that are planned via a separate recursive invocation of the planner. A
RelOptInfo is also built for each join relation that is considered during
planning. A join rel is simply a combination of base rels. There is only
one join RelOptInfo for any given set of baserels &mdash; for example, the join
<code>{A B C}</code> is represented by the same RelOptInfo no matter whether we build it
by joining A and B first and then adding C, or joining B and C first and
then adding A, etc. These different means of building the joinrel are
represented as Paths. For each RelOptInfo we build a list of Paths that
represent plausible ways to implement the scan or join of that relation.
Once we&rsquo;ve considered all the plausible Paths for a rel, we select the one
that is cheapest according to the planner&rsquo;s cost estimates. The final plan
is derived from the cheapest Path for the RelOptInfo that includes all the
base rels of the query.</p><ul><li>RelOptInfo åŸºç¡€çš„ä¼˜åŒ–å•ä½ï¼ŒSPJ ä¼˜åŒ–çš„æœ€ç»ˆç›®çš„å°±æ˜¯ä¼˜åŒ–å‡ºä¸€ä¸ª RelOptInfo ï¼Œ å®ƒåŒ…å«ä¸€ä¸ª path list ï¼Œä¸”å…¶æœ€ä¼˜ path åœ¨ä¼˜åŒ–è¿‡ç¨‹ä¸­å·²ç»è®¡ç®—å®Œæˆï¼Œåç»­è¿˜ä¼šå¯¹
æ­¤ path è¿›è¡Œå‰©ä¸‹çš„ä¸€äº›èšåˆä¼˜åŒ–ç­‰æ“ä½œ</li></ul><p>Possible Paths for a primitive table relation include plain old sequential
scan, plus index scans for any indexes that exist on the table, plus bitmap
index scans using one or more indexes. Specialized RTE types, such as
function RTEs, may have only one possible Path.</p><p>Joins always occur using two RelOptInfos. One is outer, the other inner.
Outers drive lookups of values in the inner. In a nested loop, lookups of
values in the inner occur by scanning the inner path once per outer tuple
to find each matching inner row. In a mergejoin, inner and outer rows are
ordered, and are accessed in order, so only one scan is required to perform
the entire join: both inner and outer paths are scanned in-sync. (There&rsquo;s
not a lot of difference between inner and outer in a mergejoin&mldr;) In a
hashjoin, the inner is scanned first and all its rows are entered in a
hashtable, then the outer is scanned and for each row we lookup the join
key in the hashtable.</p><ul><li>nest loop join<br>å°è¡¨é©±åŠ¨å¤§è¡¨ï¼Œå°è¡¨ä¸ºå¤–è¡¨ï¼Œå¤§è¡¨ä¸ºå†…è¡¨ï¼Œå¤–è¡¨çš„æ¯ä¸€è¡Œéƒ½ä¼šå¯¼è‡´å†…è¡¨è¢«é©±åŠ¨ä¸€æ¬¡ï¼Œä»£ä»·ç®€å•æè¿°ä¸º n*m + nï¼Œå¯ä»¥ä½¿ç”¨ç‰©åŒ–æˆ–è€… index scan åŠ é€Ÿ</li><li>merge join
è¦æ±‚å·¦å³è¾“å…¥æœ‰åºï¼Œä¼˜åŒ–ä¸­å¦‚æœè¾“å…¥æ— åºï¼Œåˆ™ä¼šæ„é€  pathkey ï¼Œè®¡ç®—ä»£ä»·çš„æ—¶å€™ä¼šåˆ¤æ–­æ˜¯å¦éœ€è¦åŠ ä¸Š sort ç®—å­ï¼Œå¦‚æœéœ€è¦ï¼Œä»£ä»·ä¼šåŠ ä¸Š sort çš„ä»£ä»·ï¼Œåé¢ create plan çš„æ—¶å€™æ„é€  sort path</li><li>hash join<br>å¤–è¡¨ä½œä¸ºé©±åŠ¨è¡¨ï¼Œæ„é€ hashè¡¨ï¼Œç„¶åå¯¹å†…è¡¨æ‰«æä¸‰åprobe|æ¢æµ‹æ„é€ çš„ hash table ã€‚ä»£ä»·ä¸»è¦æ˜¯ä¸¤ä¸ªè¡¨çš„full scanå’Œhashè¡¨çš„å†…å­˜ä»¥åŠå»ºç«‹hash çš„æ—¶é—´</li></ul><p>A Path for a join relation is actually a tree structure, with the topmost
Path node representing the last-applied join method. It has left and right
subpaths that represent the scan or join methods used for the two input
relations.</p><h2 id=join-tree-construction>Join Tree Construction</h2><p>The optimizer generates optimal query plans by doing a more-or-less
exhaustive search through the ways of executing the query. The best Path
tree is found by a recursive process:</p><p>Take each base relation in the query, and make a RelOptInfo structure
for it. Find each potentially useful way of accessing the relation,
including sequential and index scans, and make Paths representing those
ways. All the Paths made for a given relation are placed in its
RelOptInfo.pathlist. (Actually, we discard Paths that are obviously
inferior alternatives before they ever get into the pathlist &mdash; what
ends up in the pathlist is the cheapest way of generating each potentially
useful sort ordering and parameterization of the relation.) Also create a
RelOptInfo.joininfo list including all the join clauses that involve this
relation. For example, the WHERE clause <code>tab1.col1 = tab2.col1</code> generates
entries in both tab1 and tab2&rsquo;s joininfo lists.</p><p>If we have only a single base relation in the query, we are done.
Otherwise we have to figure out how to join the base relations into a
single join relation.</p><ul><li>æ„é€ åŸºè¡¨çš„ path ï¼Œæ­¤æ—¶å·²ç»å¼€å§‹ä¼˜åŒ–ï¼Œä»£ä»·è¾ƒé«˜çš„ path åœ¨æ­¤è¿‡ç¨‹ä¸­ä¼šè¢«æ·˜æ±°æ‰</li></ul><p>Normally, any explicit JOIN clauses are &ldquo;flattened&rdquo; so that we just
have a list of relations to join. However, FULL OUTER JOIN clauses are
never flattened, and other kinds of JOIN might not be either, if the
flattening process is stopped by join_collapse_limit or from_collapse_limit
restrictions. Therefore, we end up with a planning problem that contains
lists of relations to be joined in any order, where any individual item
might be a sub-list that has to be joined together before we can consider
joining it to its siblings. We process these sub-problems recursively,
bottom up. Note that the join list structure constrains the possible join
orders, but it doesn&rsquo;t constrain the join implementation method at each
join (nestloop, merge, hash), nor does it say which rel is considered outer
or inner at each join. We consider all these possibilities in building
Paths. We generate a Path for each feasible join method, and select the
cheapest Path.</p><p>For each planning problem, therefore, we will have a list of relations
that are either base rels or joinrels constructed per sub-join-lists.
We can join these rels together in any order the planner sees fit.
The standard (non-GEQO) planner does this as follows:</p><p>Consider joining each RelOptInfo to each other RelOptInfo for which there
is a usable joinclause, and generate a Path for each possible join method
for each such pair. (If we have a RelOptInfo with no join clauses, we have
no choice but to generate a clauseless Cartesian-product join; so we
consider joining that rel to each other available rel. But in the presence
of join clauses we will only consider joins that use available join
clauses. Note that join-order restrictions induced by outer joins and
IN/EXISTS clauses are also checked, to ensure that we find a workable join
order in cases where those restrictions force a clauseless join to be done.)</p><p>If we only had two relations in the list, we are done: we just pick
the cheapest path for the join RelOptInfo. If we had more than two, we now
need to consider ways of joining join RelOptInfos to each other to make
join RelOptInfos that represent more than two list items.</p><p>The join tree is constructed using a &ldquo;dynamic programming&rdquo; algorithm:
in the first pass (already described) we consider ways to create join rels
representing exactly two list items. The second pass considers ways
to make join rels that represent exactly three list items; the next pass,
four items, etc. The last pass considers how to make the final join
relation that includes all list items &mdash; obviously there can be only one
join rel at this top level, whereas there can be more than one join rel
at lower levels. At each level we use joins that follow available join
clauses, if possible, just as described for the first level.</p><p>For example:</p><pre><code>SELECT  *
FROM    tab1, tab2, tab3, tab4
WHERE   tab1.col = tab2.col AND
    tab2.col = tab3.col AND
    tab3.col = tab4.col

Tables 1, 2, 3, and 4 are joined as:
{1 2},{2 3},{3 4}
{1 2 3},{2 3 4}
{1 2 3 4}
(other possibilities will be excluded for lack of join clauses)

SELECT  *
FROM    tab1, tab2, tab3, tab4
WHERE   tab1.col = tab2.col AND
    tab1.col = tab3.col AND
    tab1.col = tab4.col

Tables 1, 2, 3, and 4 are joined as:
{1 2},{1 3},{1 4}
{1 2 3},{1 3 4},{1 2 4}
{1 2 3 4}
</code></pre><p>We consider left-handed plans (the outer rel of an upper join is a joinrel,
but the inner is always a single list item); right-handed plans (outer rel
is always a single item); and bushy plans (both inner and outer can be
joins themselves). For example, when building <code>{1 2 3 4}</code> we consider
joining <code>{1 2 3}</code> to <code>{4}</code> (left-handed), <code>{4}</code> to <code>{1 2 3}</code> (right-handed), and
<code>{1 2}</code> to <code>{3 4}</code> (bushy), among other choices. Although the jointree
scanning code produces these potential join combinations one at a time,
all the ways to produce the same set of joined base rels will share the
same RelOptInfo, so the paths produced from different join combinations
that produce equivalent joinrels will compete in add_path().</p><p>The dynamic-programming approach has an important property that&rsquo;s not
immediately obvious: we will finish constructing all paths for a given
relation before we construct any paths for relations containing that rel.
This means that we can reliably identify the &ldquo;cheapest path&rdquo; for each rel
before higher-level relations need to know that. Also, we can safely
discard a path when we find that another path for the same rel is better,
without worrying that maybe there is already a reference to that path in
some higher-level join path. Without this, memory management for paths
would be much more complicated.</p><p>Once we have built the final join rel, we use either the cheapest path
for it or the cheapest path with the desired ordering (if that&rsquo;s cheaper
than applying a sort to the cheapest other path).</p><p>If the query contains one-sided outer joins (LEFT or RIGHT joins), or
IN or EXISTS WHERE clauses that were converted to semijoins or antijoins,
then some of the possible join orders may be illegal. These are excluded
by having join_is_legal consult a side list of such &ldquo;special&rdquo; joins to see
whether a proposed join is illegal. (The same consultation allows it to
see which join style should be applied for a valid join, ie, JOIN_INNER,
JOIN_LEFT, etc.)</p><h2 id=valid-outer-join-optimizations>Valid OUTER JOIN Optimizations</h2><p>The planner&rsquo;s treatment of outer join reordering is based on the following
identities:</p><ol><li>(A leftjoin B on (Pab)) innerjoin C on (Pac)
= (A innerjoin C on (Pac)) leftjoin B on (Pab)</li></ol><p>where Pac is a predicate referencing A and C, etc (in this case, clearly
Pac cannot reference B, or the transformation is nonsensical).</p><ol start=2><li><p>(A leftjoin B on (Pab)) leftjoin C on (Pac)
= (A leftjoin C on (Pac)) leftjoin B on (Pab)</p></li><li><p>(A leftjoin B on (Pab)) leftjoin C on (Pbc)
= A leftjoin (B leftjoin C on (Pbc)) on (Pab)</p></li></ol><p>Identity 3 only holds if predicate Pbc must fail for all-null B rows
(that is, Pbc is strict for at least one column of B). If Pbc is not
strict, the first form might produce some rows with nonnull C columns
where the second form would make those entries null.</p><ul><li>å‡è®¾ B åœ¨ Pbc ä¸Šçš„æ¡ä»¶ä¸‹æ²¡æœ‰è¾“å‡ºï¼Œåœ¨ Pab ä¸‹æœ‰è¾“å‡ºï¼Œåœ¨ è¯­å¥ 3.1 ä¸‹ AjB çš„è¾“å‡ºå¯èƒ½åœ¨ Pbc ä¼šè¾“å‡ºéƒ¨åˆ† C</li><li>ä½†æ˜¯è¯­å¥ 3.2 æ­¤æ—¶ BjC æ˜¯å®Œå…¨æ— è¾“å‡ºï¼Œæœ€ç»ˆçš„ç»“æœä¸­ä¸å­˜åœ¨ä»»ä½• Cï¼Œæ‰€ä»¥æ­¤æ—¶è¦æ±‚ Pbc ä¸¥æ ¼æ˜¾ç¤ºå¿…é¡»æœ‰è¾“å‡º</li><li><a href=https://blog.csdn.net/gp_community/article/details/106860699 target=_blank>å¤–è¿æ¥æ¶ˆé™¤</a></li></ul><p>RIGHT JOIN is equivalent to LEFT JOIN after switching the two input
tables, so the same identities work for right joins.</p><p>An example of a case that does <em>not</em> work is moving an innerjoin into or
out of the nullable side of an outer join:</p><pre><code>A leftjoin (B join C on (Pbc)) on (Pab)
!= (A leftjoin B on (Pab)) join C on (Pbc)
</code></pre><p>SEMI joins work a little bit differently. A semijoin can be reassociated
into or out of the lefthand side of another semijoin, left join, or
antijoin, but not into or out of the righthand side. Likewise, an inner
join, left join, or antijoin can be reassociated into or out of the
lefthand side of a semijoin, but not into or out of the righthand side.</p><p>ANTI joins work approximately like LEFT joins, except that identity 3
fails if the join to C is an antijoin (even if Pbc is strict, and in
both the cases where the other join is a leftjoin and where it is an
antijoin). So we can&rsquo;t reorder antijoins into or out of the RHS of a
leftjoin or antijoin, even if the relevant clause is strict.</p><p>The current code does not attempt to re-order FULL JOINs at all.
FULL JOIN ordering is enforced by not collapsing FULL JOIN nodes when
translating the jointree to &ldquo;joinlist&rdquo; representation. Other types of
JOIN nodes are normally collapsed so that they participate fully in the
join order search. To avoid generating illegal join orders, the planner
creates a SpecialJoinInfo node for each non-inner join, and join_is_legal
checks this list to decide if a proposed join is legal.</p><p>What we store in SpecialJoinInfo nodes are the minimum sets of Relids
required on each side of the join to form the outer join. Note that
these are minimums; there&rsquo;s no explicit maximum, since joining other
rels to the OJ&rsquo;s syntactic rels may be legal. Per identities 1 and 2,
non-FULL joins can be freely associated into the lefthand side of an
OJ, but in some cases they can&rsquo;t be associated into the righthand side.
So the restriction enforced by join_is_legal is that a proposed join
can&rsquo;t join a rel within or partly within an RHS boundary to one outside
the boundary, unless the proposed join is a LEFT join that can associate
into the SpecialJoinInfo&rsquo;s RHS using identity 3.</p><p>The use of minimum Relid sets has some pitfalls; consider a query like</p><pre><code>A leftjoin (B leftjoin (C innerjoin D) on (Pbcd)) on Pa
</code></pre><p>where Pa doesn&rsquo;t mention B/C/D at all. In this case a naive computation
would give the upper leftjoin&rsquo;s min LHS as {A} and min RHS as {C,D} (since
we know that the innerjoin can&rsquo;t associate out of the leftjoin&rsquo;s RHS, and
enforce that by including its relids in the leftjoin&rsquo;s min RHS). And the
lower leftjoin has min LHS of {B} and min RHS of {C,D}. Given such
information, join_is_legal would think it&rsquo;s okay to associate the upper
join into the lower join&rsquo;s RHS, transforming the query to</p><pre><code>B leftjoin (A leftjoin (C innerjoin D) on Pa) on (Pbcd)
</code></pre><p>which yields totally wrong answers. We prevent that by forcing the min RHS
for the upper join to include B. This is perhaps overly restrictive, but
such cases don&rsquo;t arise often so it&rsquo;s not clear that it&rsquo;s worth developing a
more complicated system.</p><h2 id=pulling-up-subqueries>Pulling Up Subqueries</h2><p>As we described above, a subquery appearing in the range table is planned
independently and treated as a &ldquo;black box&rdquo; during planning of the outer
query. This is necessary when the subquery uses features such as
aggregates, GROUP, or DISTINCT. But if the subquery is just a simple
scan or join, treating the subquery as a black box may produce a poor plan
compared to considering it as part of the entire plan search space.
Therefore, at the start of the planning process the planner looks for
simple subqueries and pulls them up into the main query&rsquo;s jointree.</p><p>Pulling up a subquery may result in FROM-list joins appearing below the top
of the join tree. Each FROM-list is planned using the dynamic-programming
search method described above.</p><p>If pulling up a subquery produces a FROM-list as a direct child of another
FROM-list, then we can merge the two FROM-lists together. Once that&rsquo;s
done, the subquery is an absolutely integral part of the outer query and
will not constrain the join tree search space at all. However, that could
result in unpleasant growth of planning time, since the dynamic-programming
search has runtime exponential in the number of FROM-items considered.
Therefore, we don&rsquo;t merge FROM-lists if the result would have too many
FROM-items in one list.</p><h2 id=optimizer-functions>Optimizer Functions</h2><p>The primary entry point is planner().</p><p>planner()
set up for recursive handling of subqueries
-subquery_planner()
pull up sublinks and subqueries from rangetable, if possible
canonicalize qual
Attempt to simplify WHERE clause to the most useful form; this includes
flattening nested AND/ORs and detecting clauses that are duplicated in
different branches of an OR.
simplify constant expressions
process sublinks
convert Vars of outer query levels into Params
&ndash;grouping_planner()
preprocess target list for non-SELECT queries
handle UNION/INTERSECT/EXCEPT, GROUP BY, HAVING, aggregates,
ORDER BY, DISTINCT, LIMIT
&mdash;query_planner()
make list of base relations used in query
split up the qual into restrictions (a=1) and joins (b=c)
find qual clauses that enable merge and hash joins
&mdash;-make_one_rel()
set_base_rel_pathlists()
find seqscan and all index paths for each base relation
find selectivity of columns used in joins
make_rel_from_joinlist()
hand off join subproblems to a plugin, GEQO, or standard_join_search()
&mdash;&mdash;standard_join_search()
call join_search_one_level() for each level of join tree needed
join_search_one_level():
For each joinrel of the prior level, do make_rels_by_clause_joins()
if it has join clauses, or make_rels_by_clauseless_joins() if not.
Also generate &ldquo;bushy plan&rdquo; joins between joinrels of lower levels.
Back at standard_join_search(), generate gather paths if needed for
each newly constructed joinrel, then apply set_cheapest() to extract
the cheapest path for it.
Loop back if this wasn&rsquo;t the top join level.
Back at grouping_planner:
do grouping (GROUP BY) and aggregation
do window functions
make unique (DISTINCT)
do sorting (ORDER BY)
do limit (LIMIT/OFFSET)
Back at planner():
convert finished Path tree into a Plan tree
do final cleanup after planning</p><h2 id=optimizer-data-structures>Optimizer Data Structures</h2><p>PlannerGlobal - global information for a single planner invocation</p><p>PlannerInfo - information for planning a particular Query (we make
a separate PlannerInfo node for each sub-Query)</p><p>RelOptInfo - a relation or joined relations</p><p>RestrictInfo - WHERE clauses, like &ldquo;x = 3&rdquo; or &ldquo;y = z&rdquo;
(note the same structure is used for restriction and
join clauses)</p><p>Path - every way to generate a RelOptInfo(sequential,index,joins)
A plain Path node can represent several simple plans, per its pathtype:
T_SeqScan - sequential scan
T_SampleScan - tablesample scan
T_FunctionScan - function-in-FROM scan
T_TableFuncScan - table function scan
T_ValuesScan - VALUES scan
T_CteScan - CTE (WITH) scan
T_NamedTuplestoreScan - ENR scan
T_WorkTableScan - scan worktable of a recursive CTE
T_Result - childless Result plan node (used for FROM-less SELECT)
IndexPath - index scan
BitmapHeapPath - top of a bitmapped index scan
TidPath - scan by CTID
TidRangePath - scan a contiguous range of CTIDs
SubqueryScanPath - scan a subquery-in-FROM
ForeignPath - scan a foreign table, foreign join or foreign upper-relation
CustomPath - for custom scan providers
AppendPath - append multiple subpaths together
MergeAppendPath - merge multiple subpaths, preserving their common sort order
GroupResultPath - childless Result plan node (used for degenerate grouping)
MaterialPath - a Material plan node
MemoizePath - a Memoize plan node for caching tuples from sub-paths
UniquePath - remove duplicate rows (either by hashing or sorting)
GatherPath - collect the results of parallel workers
GatherMergePath - collect parallel results, preserving their common sort order
ProjectionPath - a Result plan node with child (used for projection)
ProjectSetPath - a ProjectSet plan node applied to some sub-path
SortPath - a Sort plan node applied to some sub-path
IncrementalSortPath - an IncrementalSort plan node applied to some sub-path
GroupPath - a Group plan node applied to some sub-path
UpperUniquePath - a Unique plan node applied to some sub-path
AggPath - an Agg plan node applied to some sub-path
GroupingSetsPath - an Agg plan node used to implement GROUPING SETS
MinMaxAggPath - a Result plan node with subplans performing MIN/MAX
WindowAggPath - a WindowAgg plan node applied to some sub-path
SetOpPath - a SetOp plan node applied to some sub-path
RecursiveUnionPath - a RecursiveUnion plan node applied to two sub-paths
LockRowsPath - a LockRows plan node applied to some sub-path
ModifyTablePath - a ModifyTable plan node applied to some sub-path(s)
LimitPath - a Limit plan node applied to some sub-path
NestPath - nested-loop joins
MergePath - merge joins
HashPath - hash joins</p><p>EquivalenceClass - a data structure representing a set of values known equal</p><p>PathKey - a data structure representing the sort ordering of a path</p><p>The optimizer spends a good deal of its time worrying about the ordering
of the tuples returned by a path. The reason this is useful is that by
knowing the sort ordering of a path, we may be able to use that path as
the left or right input of a mergejoin and avoid an explicit sort step.
Nestloops and hash joins don&rsquo;t really care what the order of their inputs
is, but mergejoin needs suitably ordered inputs. Therefore, all paths
generated during the optimization process are marked with their sort order
(to the extent that it is known) for possible use by a higher-level merge.</p><p>It is also possible to avoid an explicit sort step to implement a user&rsquo;s
ORDER BY clause if the final path has the right ordering already, so the
sort ordering is of interest even at the top level. grouping_planner() will
look for the cheapest path with a sort order matching the desired order,
then compare its cost to the cost of using the cheapest-overall path and
doing an explicit sort on that.</p><p>When we are generating paths for a particular RelOptInfo, we discard a path
if it is more expensive than another known path that has the same or better
sort order. We will never discard a path that is the only known way to
achieve a given sort order (without an explicit sort, that is). In this
way, the next level up will have the maximum freedom to build mergejoins
without sorting, since it can pick from any of the paths retained for its
inputs.</p><h2 id=equivalenceclasses>EquivalenceClasses</h2><p>During the deconstruct_jointree() scan of the query&rsquo;s qual clauses, we look
for mergejoinable equality clauses A = B whose applicability is not delayed
by an outer join; these are called &ldquo;equivalence clauses&rdquo;. When we find
one, we create an EquivalenceClass containing the expressions A and B to
record this knowledge. If we later find another equivalence clause B = C,
we add C to the existing EquivalenceClass for {A B}; this may require
merging two existing EquivalenceClasses. At the end of the scan, we have
sets of values that are known all transitively equal to each other. We can
therefore use a comparison of any pair of the values as a restriction or
join clause (when these values are available at the scan or join, of
course); furthermore, we need test only one such comparison, not all of
them. Therefore, equivalence clauses are removed from the standard qual
distribution process. Instead, when preparing a restriction or join clause
list, we examine each EquivalenceClass to see if it can contribute a
clause, and if so we select an appropriate pair of values to compare. For
example, if we are trying to join A&rsquo;s relation to C&rsquo;s, we can generate the
clause A = C, even though this appeared nowhere explicitly in the original
query. This may allow us to explore join paths that otherwise would have
been rejected as requiring Cartesian-product joins.</p><p>Sometimes an EquivalenceClass may contain a pseudo-constant expression
(i.e., one not containing Vars or Aggs of the current query level, nor
volatile functions). In this case we do not follow the policy of
dynamically generating join clauses: instead, we dynamically generate
restriction clauses &ldquo;var = const&rdquo; wherever one of the variable members of
the class can first be computed. For example, if we have A = B and B = 42,
we effectively generate the restriction clauses A = 42 and B = 42, and then
we need not bother with explicitly testing the join clause A = B when the
relations are joined. In effect, all the class members can be tested at
relation-scan level and there&rsquo;s never a need for join tests.</p><p>The precise technical interpretation of an EquivalenceClass is that it
asserts that at any plan node where more than one of its member values
can be computed, output rows in which the values are not all equal may
be discarded without affecting the query result. (We require all levels
of the plan to enforce EquivalenceClasses, hence a join need not recheck
equality of values that were computable by one of its children.) For an
ordinary EquivalenceClass that is &ldquo;valid everywhere&rdquo;, we can further infer
that the values are all non-null, because all mergejoinable operators are
strict. However, we also allow equivalence clauses that appear below the
nullable side of an outer join to form EquivalenceClasses; for these
classes, the interpretation is that either all the values are equal, or
all (except pseudo-constants) have gone to null. (This requires a
limitation that non-constant members be strict, else they might not go
to null when the other members do.) Consider for example</p><pre><code>SELECT *
  FROM a LEFT JOIN
       (SELECT * FROM b JOIN c ON b.y = c.z WHERE b.y = 10) ss
       ON a.x = ss.y
  WHERE a.x = 42;
</code></pre><p>We can form the below-outer-join EquivalenceClass {b.y c.z 10} and thereby
apply c.z = 10 while scanning c. (The reason we disallow outerjoin-delayed
clauses from forming EquivalenceClasses is exactly that we want to be able
to push any derived clauses as far down as possible.) But once above the
outer join it&rsquo;s no longer necessarily the case that b.y = 10, and thus we
cannot use such EquivalenceClasses to conclude that sorting is unnecessary
(see discussion of PathKeys below).</p><p>In this example, notice also that a.x = ss.y (really a.x = b.y) is not an
equivalence clause because its applicability to b is delayed by the outer
join; thus we do not try to insert b.y into the equivalence class {a.x 42}.
But since we see that a.x has been equated to 42 above the outer join, we
are able to form a below-outer-join class {b.y 42}; this restriction can be
added because no b/c row not having b.y = 42 can contribute to the result
of the outer join, and so we need not compute such rows. Now this class
will get merged with {b.y c.z 10}, leading to the contradiction 10 = 42,
which lets the planner deduce that the b/c join need not be computed at all
because none of its rows can contribute to the outer join. (This gets
implemented as a gating Result filter, since more usually the potential
contradiction involves Param values rather than just Consts, and thus has
to be checked at runtime.)</p><p>To aid in determining the sort ordering(s) that can work with a mergejoin,
we mark each mergejoinable clause with the EquivalenceClasses of its left
and right inputs. For an equivalence clause, these are of course the same
EquivalenceClass. For a non-equivalence mergejoinable clause (such as an
outer-join qualification), we generate two separate EquivalenceClasses for
the left and right inputs. This may result in creating single-item
equivalence &ldquo;classes&rdquo;, though of course these are still subject to merging
if other equivalence clauses are later found to bear on the same
expressions.</p><p>Another way that we may form a single-item EquivalenceClass is in creation
of a PathKey to represent a desired sort order (see below). This is a bit
different from the above cases because such an EquivalenceClass might
contain an aggregate function or volatile expression. (A clause containing
a volatile function will never be considered mergejoinable, even if its top
operator is mergejoinable, so there is no way for a volatile expression to
get into EquivalenceClasses otherwise. Aggregates are disallowed in WHERE
altogether, so will never be found in a mergejoinable clause.) This is just
a convenience to maintain a uniform PathKey representation: such an
EquivalenceClass will never be merged with any other. Note in particular
that a single-item EquivalenceClass {a.x} is <em>not</em> meant to imply an
assertion that a.x = a.x; the practical effect of this is that a.x could
be NULL.</p><p>An EquivalenceClass also contains a list of btree opfamily OIDs, which
determines what the equalities it represents actually &ldquo;mean&rdquo;. All the
equivalence clauses that contribute to an EquivalenceClass must have
equality operators that belong to the same set of opfamilies. (Note: most
of the time, a particular equality operator belongs to only one family, but
it&rsquo;s possible that it belongs to more than one. We keep track of all the
families to ensure that we can make use of an index belonging to any one of
the families for mergejoin purposes.)</p><p>An EquivalenceClass can contain &ldquo;em_is_child&rdquo; members, which are copies
of members that contain appendrel parent relation Vars, transposed to
contain the equivalent child-relation variables or expressions. These
members are <em>not</em> full-fledged members of the EquivalenceClass and do not
affect the class&rsquo;s overall properties at all. They are kept only to
simplify matching of child-relation expressions to EquivalenceClasses.
Most operations on EquivalenceClasses should ignore child members.</p><h2 id=pathkeys>PathKeys</h2><p>The PathKeys data structure represents what is known about the sort order
of the tuples generated by a particular Path. A path&rsquo;s pathkeys field is a
list of PathKey nodes, where the n&rsquo;th item represents the n&rsquo;th sort key of
the result. Each PathKey contains these fields:</p><pre><code>* a reference to an EquivalenceClass
* a btree opfamily OID (must match one of those in the EC)
* a sort direction (ascending or descending)
* a nulls-first-or-last flag
</code></pre><p>The EquivalenceClass represents the value being sorted on. Since the
various members of an EquivalenceClass are known equal according to the
opfamily, we can consider a path sorted by any one of them to be sorted by
any other too; this is what justifies referencing the whole
EquivalenceClass rather than just one member of it.</p><p>In single/base relation RelOptInfo&rsquo;s, the Paths represent various ways
of scanning the relation and the resulting ordering of the tuples.
Sequential scan Paths have NIL pathkeys, indicating no known ordering.
Index scans have Path.pathkeys that represent the chosen index&rsquo;s ordering,
if any. A single-key index would create a single-PathKey list, while a
multi-column index generates a list with one element per key index column.
Non-key columns specified in the INCLUDE clause of covering indexes don&rsquo;t
have corresponding PathKeys in the list, because the have no influence on
index ordering. (Actually, since an index can be scanned either forward or
backward, there are two possible sort orders and two possible PathKey lists
it can generate.)</p><p>Note that a bitmap scan has NIL pathkeys since we can say nothing about
the overall order of its result. Also, an indexscan on an unordered type
of index generates NIL pathkeys. However, we can always create a pathkey
by doing an explicit sort. The pathkeys for a Sort plan&rsquo;s output just
represent the sort key fields and the ordering operators used.</p><p>Things get more interesting when we consider joins. Suppose we do a
mergejoin between A and B using the mergeclause A.X = B.Y. The output
of the mergejoin is sorted by X &mdash; but it is also sorted by Y. Again,
this can be represented by a PathKey referencing an EquivalenceClass
containing both X and Y.</p><p>With a little further thought, it becomes apparent that nestloop joins
can also produce sorted output. For example, if we do a nestloop join
between outer relation A and inner relation B, then any pathkeys relevant
to A are still valid for the join result: we have not altered the order of
the tuples from A. Even more interesting, if there was an equivalence clause
A.X=B.Y, and A.X was a pathkey for the outer relation A, then we can assert
that B.Y is a pathkey for the join result; X was ordered before and still
is, and the joined values of Y are equal to the joined values of X, so Y
must now be ordered too. This is true even though we used neither an
explicit sort nor a mergejoin on Y. (Note: hash joins cannot be counted
on to preserve the order of their outer relation, because the executor
might decide to &ldquo;batch&rdquo; the join, so we always set pathkeys to NIL for
a hashjoin path.) Exception: a RIGHT or FULL join doesn&rsquo;t preserve the
ordering of its outer relation, because it might insert nulls at random
points in the ordering.</p><p>In general, we can justify using EquivalenceClasses as the basis for
pathkeys because, whenever we scan a relation containing multiple
EquivalenceClass members or join two relations each containing
EquivalenceClass members, we apply restriction or join clauses derived from
the EquivalenceClass. This guarantees that any two values listed in the
EquivalenceClass are in fact equal in all tuples emitted by the scan or
join, and therefore that if the tuples are sorted by one of the values,
they can be considered sorted by any other as well. It does not matter
whether the test clause is used as a mergeclause, or merely enforced
after-the-fact as a qpqual filter.</p><p>Note that there is no particular difficulty in labeling a path&rsquo;s sort
order with a PathKey referencing an EquivalenceClass that contains
variables not yet joined into the path&rsquo;s output. We can simply ignore
such entries as not being relevant (yet). This makes it possible to
use the same EquivalenceClasses throughout the join planning process.
In fact, by being careful not to generate multiple identical PathKey
objects, we can reduce comparison of EquivalenceClasses and PathKeys
to simple pointer comparison, which is a huge savings because add_path
has to make a large number of PathKey comparisons in deciding whether
competing Paths are equivalently sorted.</p><p>Pathkeys are also useful to represent an ordering that we wish to achieve,
since they are easily compared to the pathkeys of a potential candidate
path. So, SortGroupClause lists are turned into pathkeys lists for use
inside the optimizer.</p><p>An additional refinement we can make is to insist that canonical pathkey
lists (sort orderings) do not mention the same EquivalenceClass more than
once. For example, in all these cases the second sort column is redundant,
because it cannot distinguish values that are the same according to the
first sort column:
SELECT &mldr; ORDER BY x, x
SELECT &mldr; ORDER BY x, x DESC
SELECT &mldr; WHERE x = y ORDER BY x, y
Although a user probably wouldn&rsquo;t write &ldquo;ORDER BY x,x&rdquo; directly, such
redundancies are more probable once equivalence classes have been
considered. Also, the system may generate redundant pathkey lists when
computing the sort ordering needed for a mergejoin. By eliminating the
redundancy, we save time and improve planning, since the planner will more
easily recognize equivalent orderings as being equivalent.</p><p>Another interesting property is that if the underlying EquivalenceClass
contains a constant and is not below an outer join, then the pathkey is
completely redundant and need not be sorted by at all! Every row must
contain the same constant value, so there&rsquo;s no need to sort. (If the EC is
below an outer join, we still have to sort, since some of the rows might
have gone to null and others not. In this case we must be careful to pick
a non-const member to sort by. The assumption that all the non-const
members go to null at the same plan level is critical here, else they might
not produce the same sort order.) This might seem pointless because users
are unlikely to write &ldquo;&mldr; WHERE x = 42 ORDER BY x&rdquo;, but it allows us to
recognize when particular index columns are irrelevant to the sort order:
if we have &ldquo;&mldr; WHERE x = 42 ORDER BY y&rdquo;, scanning an index on (x,y)
produces correctly ordered data without a sort step. We used to have very
ugly ad-hoc code to recognize that in limited contexts, but discarding
constant ECs from pathkeys makes it happen cleanly and automatically.</p><p>You might object that a below-outer-join EquivalenceClass doesn&rsquo;t always
represent the same values at every level of the join tree, and so using
it to uniquely identify a sort order is dubious. This is true, but we
can avoid dealing with the fact explicitly because we always consider that
an outer join destroys any ordering of its nullable inputs. Thus, even
if a path was sorted by {a.x} below an outer join, we&rsquo;ll re-sort if that
sort ordering was important; and so using the same PathKey for both sort
orderings doesn&rsquo;t create any real problem.</p><h2 id=order-of-processing-for-equivalenceclasses-and-pathkeys>Order of processing for EquivalenceClasses and PathKeys</h2><p>As alluded to above, there is a specific sequence of phases in the
processing of EquivalenceClasses and PathKeys during planning. During the
initial scanning of the query&rsquo;s quals (deconstruct_jointree followed by
reconsider_outer_join_clauses), we construct EquivalenceClasses based on
mergejoinable clauses found in the quals. At the end of this process,
we know all we can know about equivalence of different variables, so
subsequently there will be no further merging of EquivalenceClasses.
At that point it is possible to consider the EquivalenceClasses as
&ldquo;canonical&rdquo; and build canonical PathKeys that reference them. At this
time we construct PathKeys for the query&rsquo;s ORDER BY and related clauses.
(Any ordering expressions that do not appear elsewhere will result in
the creation of new EquivalenceClasses, but this cannot result in merging
existing classes, so canonical-ness is not lost.)</p><p>Because all the EquivalenceClasses are known before we begin path
generation, we can use them as a guide to which indexes are of interest:
if an index&rsquo;s column is not mentioned in any EquivalenceClass then that
index&rsquo;s sort order cannot possibly be helpful for the query. This allows
short-circuiting of much of the processing of create_index_paths() for
irrelevant indexes.</p><p>There are some cases where planner.c constructs additional
EquivalenceClasses and PathKeys after query_planner has completed.
In these cases, the extra ECs/PKs are needed to represent sort orders
that were not considered during query_planner. Such situations should be
minimized since it is impossible for query_planner to return a plan
producing such a sort order, meaning an explicit sort will always be needed.
Currently this happens only for queries involving multiple window functions
with different orderings, for which extra sorts are needed anyway.</p><h2 id=parameterized-paths>Parameterized Paths</h2><p>The naive way to join two relations using a clause like WHERE A.X = B.Y
is to generate a nestloop plan like this:</p><pre><code>NestLoop
	Filter: A.X = B.Y
	-&gt; Seq Scan on A
	-&gt; Seq Scan on B
</code></pre><p>We can make this better by using a merge or hash join, but it still
requires scanning all of both input relations. If A is very small and B is
very large, but there is an index on B.Y, it can be enormously better to do
something like this:</p><pre><code>NestLoop
	-&gt; Seq Scan on A
	-&gt; Index Scan using B_Y_IDX on B
		Index Condition: B.Y = A.X
</code></pre><p>Here, we are expecting that for each row scanned from A, the nestloop
plan node will pass down the current value of A.X into the scan of B.
That allows the indexscan to treat A.X as a constant for any one
invocation, and thereby use it as an index key. This is the only plan type
that can avoid fetching all of B, and for small numbers of rows coming from
A, that will dominate every other consideration. (As A gets larger, this
gets less attractive, and eventually a merge or hash join will win instead.
So we have to cost out all the alternatives to decide what to do.)</p><p>It can be useful for the parameter value to be passed down through
intermediate layers of joins, for example:</p><pre><code>NestLoop
	-&gt; Seq Scan on A
	Hash Join
		Join Condition: B.Y = C.W
		-&gt; Seq Scan on B
		-&gt; Index Scan using C_Z_IDX on C
			Index Condition: C.Z = A.X
</code></pre><p>If all joins are plain inner joins then this is usually unnecessary,
because it&rsquo;s possible to reorder the joins so that a parameter is used
immediately below the nestloop node that provides it. But in the
presence of outer joins, such join reordering may not be possible.</p><p>Also, the bottom-level scan might require parameters from more than one
other relation. In principle we could join the other relations first
so that all the parameters are supplied from a single nestloop level.
But if those other relations have no join clause in common (which is
common in star-schema queries for instance), the planner won&rsquo;t consider
joining them directly to each other. In such a case we need to be able
to create a plan like</p><pre><code>NestLoop
    -&gt; Seq Scan on SmallTable1 A
    NestLoop
        -&gt; Seq Scan on SmallTable2 B
        -&gt; Index Scan using XYIndex on LargeTable C
             Index Condition: C.X = A.AID and C.Y = B.BID
</code></pre><p>so we should be willing to pass down A.AID through a join even though
there is no join order constraint forcing the plan to look like this.</p><p>Before version 9.2, Postgres used ad-hoc methods for planning and
executing nestloop queries of this kind, and those methods could not
handle passing parameters down through multiple join levels.</p><p>To plan such queries, we now use a notion of a &ldquo;parameterized path&rdquo;,
which is a path that makes use of a join clause to a relation that&rsquo;s not
scanned by the path. In the example two above, we would construct a
path representing the possibility of doing this:</p><pre><code>-&gt; Index Scan using C_Z_IDX on C
	Index Condition: C.Z = A.X
</code></pre><p>This path will be marked as being parameterized by relation A. (Note that
this is only one of the possible access paths for C; we&rsquo;d still have a
plain unparameterized seqscan, and perhaps other possibilities.) The
parameterization marker does not prevent joining the path to B, so one of
the paths generated for the joinrel {B C} will represent</p><pre><code>Hash Join
	Join Condition: B.Y = C.W
	-&gt; Seq Scan on B
	-&gt; Index Scan using C_Z_IDX on C
		Index Condition: C.Z = A.X
</code></pre><p>This path is still marked as being parameterized by A. When we attempt to
join {B C} to A to form the complete join tree, such a path can only be
used as the inner side of a nestloop join: it will be ignored for other
possible join types. So we will form a join path representing the query
plan shown above, and it will compete in the usual way with paths built
from non-parameterized scans.</p><p>While all ordinary paths for a particular relation generate the same set
of rows (since they must all apply the same set of restriction clauses),
parameterized paths typically generate fewer rows than less-parameterized
paths, since they have additional clauses to work with. This means we
must consider the number of rows generated as an additional figure of
merit. A path that costs more than another, but generates fewer rows,
must be kept since the smaller number of rows might save work at some
intermediate join level. (It would not save anything if joined
immediately to the source of the parameters.)</p><p>To keep cost estimation rules relatively simple, we make an implementation
restriction that all paths for a given relation of the same parameterization
(i.e., the same set of outer relations supplying parameters) must have the
same rowcount estimate. This is justified by insisting that each such path
apply <em>all</em> join clauses that are available with the named outer relations.
Different paths might, for instance, choose different join clauses to use
as index clauses; but they must then apply any other join clauses available
from the same outer relations as filter conditions, so that the set of rows
returned is held constant. This restriction doesn&rsquo;t degrade the quality of
the finished plan: it amounts to saying that we should always push down
movable join clauses to the lowest possible evaluation level, which is a
good thing anyway. The restriction is useful in particular to support
pre-filtering of join paths in add_path_precheck. Without this rule we
could never reject a parameterized path in advance of computing its rowcount
estimate, which would greatly reduce the value of the pre-filter mechanism.</p><p>To limit planning time, we have to avoid generating an unreasonably large
number of parameterized paths. We do this by only generating parameterized
relation scan paths for index scans, and then only for indexes for which
suitable join clauses are available. There are also heuristics in join
planning that try to limit the number of parameterized paths considered.</p><p>In particular, there&rsquo;s been a deliberate policy decision to favor hash
joins over merge joins for parameterized join steps (those occurring below
a nestloop that provides parameters to the lower join&rsquo;s inputs). While we
do not ignore merge joins entirely, joinpath.c does not fully explore the
space of potential merge joins with parameterized inputs. Also, add_path
treats parameterized paths as having no pathkeys, so that they compete
only on cost and rowcount; they don&rsquo;t get preference for producing a
special sort order. This creates additional bias against merge joins,
since we might discard a path that could have been useful for performing
a merge without an explicit sort step. Since a parameterized path must
ultimately be used on the inside of a nestloop, where its sort order is
uninteresting, these choices do not affect any requirement for the final
output order of a query &mdash; they only make it harder to use a merge join
at a lower level. The savings in planning work justifies that.</p><p>Similarly, parameterized paths do not normally get preference in add_path
for having cheap startup cost; that&rsquo;s seldom of much value when on the
inside of a nestloop, so it seems not worth keeping extra paths solely for
that. An exception occurs for parameterized paths for the RHS relation of
a SEMI or ANTI join: in those cases, we can stop the inner scan after the
first match, so it&rsquo;s primarily startup not total cost that we care about.</p><h2 id=lateral-subqueries>LATERAL subqueries</h2><p>As of 9.3 we support SQL-standard LATERAL references from subqueries in
FROM (and also functions in FROM). The planner implements these by
generating parameterized paths for any RTE that contains lateral
references. In such cases, <em>all</em> paths for that relation will be
parameterized by at least the set of relations used in its lateral
references. (And in turn, join relations including such a subquery might
not have any unparameterized paths.) All the other comments made above for
parameterized paths still apply, though; in particular, each such path is
still expected to enforce any join clauses that can be pushed down to it,
so that all paths of the same parameterization have the same rowcount.</p><p>We also allow LATERAL subqueries to be flattened (pulled up into the parent
query) by the optimizer, but only when this does not introduce lateral
references into JOIN/ON quals that would refer to relations outside the
lowest outer join at/above that qual. The semantics of such a qual would
be unclear. Note that even with this restriction, pullup of a LATERAL
subquery can result in creating PlaceHolderVars that contain lateral
references to relations outside their syntactic scope. We still evaluate
such PHVs at their syntactic location or lower, but the presence of such a
PHV in the quals or targetlist of a plan node requires that node to appear
on the inside of a nestloop join relative to the rel(s) supplying the
lateral reference. (Perhaps now that that stuff works, we could relax the
pullup restriction?)</p><h2 id=security-level-constraints-on-qual-clauses>Security-level constraints on qual clauses</h2><p>To support row-level security and security-barrier views efficiently,
we mark qual clauses (RestrictInfo nodes) with a &ldquo;security_level&rdquo; field.
The basic concept is that a qual with a lower security_level must be
evaluated before one with a higher security_level. This ensures that
&ldquo;leaky&rdquo; quals that might expose sensitive data are not evaluated until
after the security barrier quals that are supposed to filter out
security-sensitive rows. However, many qual conditions are &ldquo;leakproof&rdquo;,
that is we trust the functions they use to not expose data. To avoid
unnecessarily inefficient plans, a leakproof qual is not delayed by
security-level considerations, even if it has a higher syntactic
security_level than another qual.</p><p>In a query that contains no use of RLS or security-barrier views, all
quals will have security_level zero, so that none of these restrictions
kick in; we don&rsquo;t even need to check leakproofness of qual conditions.</p><p>If there are security-barrier quals, they get security_level zero (and
possibly higher, if there are multiple layers of barriers). Regular quals
coming from the query text get a security_level one more than the highest
level used for barrier quals.</p><p>When new qual clauses are generated by EquivalenceClass processing,
they must be assigned a security_level. This is trickier than it seems.
One&rsquo;s first instinct is that it would be safe to use the largest level
found among the source quals for the EquivalenceClass, but that isn&rsquo;t
safe at all, because it allows unwanted delays of security-barrier quals.
Consider a barrier qual &ldquo;t.x = t.y&rdquo; plus a query qual &ldquo;t.x = constant&rdquo;,
and suppose there is another query qual &ldquo;leaky_function(t.z)&rdquo; that
we mustn&rsquo;t evaluate before the barrier qual has been checked.
We will have an EC {t.x, t.y, constant} which will lead us to replace
the EC quals with &ldquo;t.x = constant AND t.y = constant&rdquo;. (We do not want
to give up that behavior, either, since the latter condition could allow
use of an index on t.y, which we would never discover from the original
quals.) If these generated quals are assigned the same security_level as
the query quals, then it&rsquo;s possible for the leaky_function qual to be
evaluated first, allowing leaky_function to see data from rows that
possibly don&rsquo;t pass the barrier condition.</p><p>Instead, our handling of security levels with ECs works like this:</p><ul><li>Quals are not accepted as source clauses for ECs in the first place
unless they are leakproof or have security_level zero.</li><li>EC-derived quals are assigned the minimum (not maximum) security_level
found among the EC&rsquo;s source clauses.</li><li>If the maximum security_level found among the EC&rsquo;s source clauses is
above zero, then the equality operators selected for derived quals must
be leakproof. When no such operator can be found, the EC is treated as
&ldquo;broken&rdquo; and we fall back to emitting its source clauses without any
additional derived quals.</li></ul><p>These rules together ensure that an untrusted qual clause (one with
security_level above zero) cannot cause an EC to generate a leaky derived
clause. This makes it safe to use the minimum not maximum security_level
for derived clauses. The rules could result in poor plans due to not
being able to generate derived clauses at all, but the risk of that is
small in practice because most btree equality operators are leakproof.
Also, by making exceptions for level-zero quals, we ensure that there is
no plan degradation when no barrier quals are present.</p><p>Once we have security levels assigned to all clauses, enforcement
of barrier-qual ordering restrictions boils down to two rules:</p><ul><li><p>Table scan plan nodes must not select quals for early execution
(for example, use them as index qualifiers in an indexscan) unless
they are leakproof or have security_level no higher than any other
qual that is due to be executed at the same plan node. (Use the
utility function restriction_is_securely_promotable() to check
whether it&rsquo;s okay to select a qual for early execution.)</p></li><li><p>Normal execution of a list of quals must execute them in an order
that satisfies the same security rule, ie higher security_levels must
be evaluated later unless leakproof. (This is handled in a single place
by order_qual_clauses() in createplan.c.)</p></li></ul><p>order_qual_clauses() uses a heuristic to decide exactly what to do with
leakproof clauses. Normally it sorts clauses by security_level then cost,
being careful that the sort is stable so that we don&rsquo;t reorder clauses
without a clear reason. But this could result in a very expensive qual
being done before a cheaper one that is of higher security_level.
If the cheaper qual is leaky we have no choice, but if it is leakproof
we could put it first. We choose to sort leakproof quals as if they
have security_level zero, but only when their cost is less than 10X
cpu_operator_cost; that restriction alleviates the opposite problem of
doing expensive quals first just because they&rsquo;re leakproof.</p><p>Additional rules will be needed to support safe handling of join quals
when there is a mix of security levels among join quals; for example, it
will be necessary to prevent leaky higher-security-level quals from being
evaluated at a lower join level than other quals of lower security level.
Currently there is no need to consider that since security-prioritized
quals can only be single-table restriction quals coming from RLS policies
or security-barrier views, and security-barrier view subqueries are never
flattened into the parent query. Hence enforcement of security-prioritized
quals only happens at the table scan level. With extra rules for safe
handling of security levels among join quals, it should be possible to let
security-barrier views be flattened into the parent query, allowing more
flexibility of planning while still preserving required ordering of qual
evaluation. But that will come later.</p><h2 id=post-scanjoin-planning>Post scan/join planning</h2><p>So far we have discussed only scan/join planning, that is, implementation
of the FROM and WHERE clauses of a SQL query. But the planner must also
determine how to deal with GROUP BY, aggregation, and other higher-level
features of queries; and in many cases there are multiple ways to do these
steps and thus opportunities for optimization choices. These steps, like
scan/join planning, are handled by constructing Paths representing the
different ways to do a step, then choosing the cheapest Path.</p><p>Since all Paths require a RelOptInfo as &ldquo;parent&rdquo;, we create RelOptInfos
representing the outputs of these upper-level processing steps. These
RelOptInfos are mostly dummy, but their pathlist lists hold all the Paths
considered useful for each step. Currently, we may create these types of
additional RelOptInfos during upper-level planning:</p><p>UPPERREL_SETOP result of UNION/INTERSECT/EXCEPT, if any
UPPERREL_PARTIAL_GROUP_AGG result of partial grouping/aggregation, if any
UPPERREL_GROUP_AGG result of grouping/aggregation, if any
UPPERREL_WINDOW result of window functions, if any
UPPERREL_PARTIAL_DISTINCT result of partial &ldquo;SELECT DISTINCT&rdquo;, if any
UPPERREL_DISTINCT result of &ldquo;SELECT DISTINCT&rdquo;, if any
UPPERREL_ORDERED result of ORDER BY, if any
UPPERREL_FINAL result of any remaining top-level actions</p><p>UPPERREL_FINAL is used to represent any final processing steps, currently
LockRows (SELECT FOR UPDATE), LIMIT/OFFSET, and ModifyTable. There is no
flexibility about the order in which these steps are done, and thus no need
to subdivide this stage more finely.</p><p>These &ldquo;upper relations&rdquo; are identified by the UPPERREL enum values shown
above, plus a relids set, which allows there to be more than one upperrel
of the same kind. We use NULL for the relids if there&rsquo;s no need for more
than one upperrel of the same kind. Currently, in fact, the relids set
is vestigial because it&rsquo;s always NULL, but that&rsquo;s expected to change in
the future. For example, in planning set operations, we might need the
relids to denote which subset of the leaf SELECTs has been combined in a
particular group of Paths that are competing with each other.</p><p>The result of subquery_planner() is always returned as a set of Paths
stored in the UPPERREL_FINAL rel with NULL relids. The other types of
upperrels are created only if needed for the particular query.</p><h2 id=parallel-query-and-partial-paths>Parallel Query and Partial Paths</h2><p>Parallel query involves dividing up the work that needs to be performed
either by an entire query or some portion of the query in such a way that
some of that work can be done by one or more worker processes, which are
called parallel workers. Parallel workers are a subtype of dynamic
background workers; see src/backend/access/transam/README.parallel for a
fuller description. The academic literature on parallel query suggests
that parallel execution strategies can be divided into essentially two
categories: pipelined parallelism, where the execution of the query is
divided into multiple stages and each stage is handled by a separate
process; and partitioning parallelism, where the data is split between
multiple processes and each process handles a subset of it. The
literature, however, suggests that gains from pipeline parallelism are
often very limited due to the difficulty of avoiding pipeline stalls.
Consequently, we do not currently attempt to generate query plans that
use this technique.</p><p>Instead, we focus on partitioning parallelism, which does not require
that the underlying table be partitioned. It only requires that (1)
there is some method of dividing the data from at least one of the base
tables involved in the relation across multiple processes, (2) allowing
each process to handle its own portion of the data, and then (3)
collecting the results. Requirements (2) and (3) are satisfied by the
executor node Gather (or GatherMerge), which launches any number of worker
processes and executes its single child plan in all of them, and perhaps
in the leader also, if the children aren&rsquo;t generating enough data to keep
the leader busy. Requirement (1) is handled by the table scan node: when
invoked with parallel_aware = true, this node will, in effect, partition
the table on a block by block basis, returning a subset of the tuples from
the relation in each worker where that scan node is executed.</p><p>Just as we do for non-parallel access methods, we build Paths to
represent access strategies that can be used in a parallel plan. These
are, in essence, the same strategies that are available in the
non-parallel plan, but there is an important difference: a path that
will run beneath a Gather node returns only a subset of the query
results in each worker, not all of them. To form a path that can
actually be executed, the (rather large) cost of the Gather node must be
accounted for. For this reason among others, paths intended to run
beneath a Gather node - which we call &ldquo;partial&rdquo; paths since they return
only a subset of the results in each worker - must be kept separate from
ordinary paths (see RelOptInfo&rsquo;s partial_pathlist and the function
add_partial_path).</p><p>One of the keys to making parallel query effective is to run as much of
the query in parallel as possible. Therefore, we expect it to generally
be desirable to postpone the Gather stage until as near to the top of the
plan as possible. Expanding the range of cases in which more work can be
pushed below the Gather (and costing them accurately) is likely to keep us
busy for a long time to come.</p><h2 id=partitionwise-joins>Partitionwise joins</h2><p>A join between two similarly partitioned tables can be broken down into joins
between their matching partitions if there exists an equi-join condition
between the partition keys of the joining tables. The equi-join between
partition keys implies that all join partners for a given row in one
partitioned table must be in the corresponding partition of the other
partitioned table. Because of this the join between partitioned tables to be
broken into joins between the matching partitions. The resultant join is
partitioned in the same way as the joining relations, thus allowing an N-way
join between similarly partitioned tables having equi-join condition between
their partition keys to be broken down into N-way joins between their matching
partitions. This technique of breaking down a join between partitioned tables
into joins between their partitions is called partitionwise join. We will use
term &ldquo;partitioned relation&rdquo; for either a partitioned table or a join between
compatibly partitioned tables.</p><p>Even if the joining relations don&rsquo;t have exactly the same partition bounds,
partitionwise join can still be applied by using an advanced
partition-matching algorithm. For both the joining relations, the algorithm
checks whether every partition of one joining relation only matches one
partition of the other joining relation at most. In such a case the join
between the joining relations can be broken down into joins between the
matching partitions. The join relation can then be considered partitioned.
The algorithm produces the pairs of the matching partitions, plus the
partition bounds for the join relation, to allow partitionwise join for
computing the join. The algorithm is implemented in partition_bounds_merge().
For an N-way join relation considered partitioned this way, not every pair of
joining relations can use partitionwise join. For example:</p><pre><code>(A leftjoin B on (Pab)) innerjoin C on (Pac)
</code></pre><p>where A, B, and C are partitioned tables, and A has an extra partition
compared to B and C. When considering partitionwise join for the join {A B},
the extra partition of A doesn&rsquo;t have a matching partition on the nullable
side, which is the case that the current implementation of partitionwise join
can&rsquo;t handle. So {A B} is not considered partitioned, and the pair of {A B}
and C considered for the 3-way join can&rsquo;t use partitionwise join. On the
other hand, the pair of {A C} and B can use partitionwise join because {A C}
is considered partitioned by eliminating the extra partition (see identity 1
on outer join reordering). Whether an N-way join can use partitionwise join
is determined based on the first pair of joining relations that are both
partitioned and can use partitionwise join.</p><p>The partitioning properties of a partitioned relation are stored in its
RelOptInfo. The information about data types of partition keys are stored in
PartitionSchemeData structure. The planner maintains a list of canonical
partition schemes (distinct PartitionSchemeData objects) so that RelOptInfo of
any two partitioned relations with same partitioning scheme point to the same
PartitionSchemeData object. This reduces memory consumed by
PartitionSchemeData objects and makes it easy to compare the partition schemes
of joining relations.</p><h2 id=partitionwise-aggregatesgrouping>Partitionwise aggregates/grouping</h2><p>If the GROUP BY clause contains all of the partition keys, all the rows
that belong to a given group must come from a single partition; therefore,
aggregation can be done completely separately for each partition. Otherwise,
partial aggregates can be computed for each partition, and then finalized
after appending the results from the individual partitions. This technique of
breaking down aggregation or grouping over a partitioned relation into
aggregation or grouping over its partitions is called partitionwise
aggregation. Especially when the partition keys match the GROUP BY clause,
this can be significantly faster than the regular method.</p><p>ä½†æ˜¯ä»ä»Šå¤©çš„è§†è§’ï¼ŒPostgreSQL ä¼˜åŒ–å™¨ä¸æ˜¯ä¸€ä¸ªå¥½çš„å®ç°</p><ol><li>å®ƒç”¨Cè¯­è¨€å®ç°ï¼Œæ‰€ä»¥æ‰©å±•æ€§ä¸å¥½</li><li>å®ƒä¸æ˜¯ Volcano ä¼˜åŒ–æ¨¡å‹çš„ï¼Œæ‰€ä»¥çµæ´»æ€§ä¸å¥½</li><li>å®ƒçš„å¾ˆå¤šä¼˜åŒ–å¤æ‚åº¦å¾ˆé«˜ï¼ˆä¾‹å¦‚Joiné‡æ’æ˜¯System Ré£æ ¼çš„åŠ¨æ€è§„åˆ’ç®—æ³•ï¼‰ï¼Œæ‰€ä»¥æ€§èƒ½ä¸å¥½</li></ol><p><a href=https://www.cnblogs.com/xiaohuizhenyoucai/p/10983783.html target=_blank>Nested Loopï¼ŒHash Joinï¼ŒMerge Join</a></p><pre tabindex=0><code>pg_plan_query æ‰§è¡Œè®¡åˆ’å…¥å£

planner å®é™…æ‰§è¡Œè®¡åˆ’è°ƒç”¨
  è¿™é‡Œæä¾›ä¸€ä¸ªplanner_hookï¼Œä»¥ä¾›è‡ªå®šä¹‰æ‰§è¡Œè®¡åˆ’ä½¿ç”¨

standard_planner é»˜è®¤planner hook
  å…¥å£å¤„ï¼Œåˆ¤æ–­SQLæ˜¯å¦æ˜¯å¯ä»¥å¹¶è¡ŒæŸ¥è¯¢çš„
    åˆ¤æ–­æ¡ä»¶
    (cursorOptions &amp; CURSOR_OPT_PARALLEL_OK) != 0 &amp;&amp; å½“å‰æ¸¸æ ‡å…è®¸å¹¶è¡ŒæŸ¥è¯¢
    IsUnderPostmaster &amp;&amp; å½“å‰æ˜¯ç›´æ¥è°ƒç”¨çš„ç”¨æˆ·è¿›ç¨‹ï¼ˆpostmasterçš„å­è¿›ç¨‹ï¼‰ï¼Œ
    parse-&gt;commandType == CMD_SELECT &amp;&amp; å½“å‰æ˜¯select
    !parse-&gt;hasModifyingCTE &amp;&amp; å½“å‰CTEæ˜¯ä¸å¯å˜é›†åˆ
    max_parallel_workers_per_gather &gt; 0 &amp;&amp; parallel worker è®¾ç½®å¤§äº0
    !IsParallelWorker() å½“å‰ä¸æ˜¯workerçš„æ‰§è¡Œè¿›ç¨‹

    ä¹‹ååˆ¤å®š glob-&gt;parallelModeNeeded = glob-&gt;parallelModeOK &amp;&amp;
    (force_parallel_mode != FORCE_PARALLEL_OFF);
    å¦‚æœå¯ç”¨äº†force_parallel_modeï¼Œä½†æŸ¥è¯¢ä¸æ”¯æŒå¹¶è¡ŒæŸ¥è¯¢ï¼Œåˆ™ä¾ç„¶ä¸ä½¿ç”¨å¹¶è¡ŒæŸ¥è¯¢
    å¦‚æœä½¿ç”¨äº†CURSOR_OPT_FAST_PLAN
      å¤„ç† tuple_fraction
      å¦‚æœtuple_fraction&gt;= 1 åˆ™è®¾ç½®ä¸º0
      å¦‚æœtuple_fraction &lt;=0 è®¾ç½®ä¸º 1e-10;
    å¦åˆ™ tuple_fraction=0

    ä¹‹åæ‰§è¡Œsubquery_planner è·å–æ‰§è¡Œè®¡åˆ’

    fetch_upper_rel è·å–ä¸Šå±‚releation
    get_cheapest_fractional_path  é€‰å–æœ€ä½³æ‰§è¡Œè·¯å¾„
    create_plan åˆ›å»ºæ‰§è¡Œè®¡åˆ’

    å¯¹äºCURSOR_OPT_SCROLL
      å¦‚æœä¸æ”¯æŒåå°æ‰§è¡ŒExecSupportsBackwardScan
      åˆ™é™„åŠ ä¸€ä¸ªç‰©åŒ–æŸ¥è¯¢è®¡åˆ’ materialize_finished_plan

    å¯¹äºå¯ä»¥å¹¶è¡Œçš„æŸ¥è¯¢ï¼Œè¿™é‡Œå¤„ç†gatherè¿›è¡Œå¯è¡Œæ€§æµ‹è¯•ï¼ˆä¸å®é™…æ‰§è¡Œï¼Œä½†éœ€è¦éªŒè¯gatherå¯ä»¥åˆ›å»ºï¼‰
      åˆ›å»ºgather
        æ‰§è¡Œåˆ—è¡¨
        workeræ•°é‡
        å¹¶è¡Œæ‰§è¡Œè®¡åˆ’
        gather-&gt;plan.startup_cost = top_plan-&gt;startup_cost + parallel_setup_cost;
        gather-&gt;plan.total_cost = top_plan-&gt;total_cost + parallel_setup_cost + parallel_tuple_cost * top_plan-&gt;plan_rows;
        æ‰§è¡Œä»£ä»·è®¡ç®—
    æœ€åæ‰§è¡Œä¸€ç³»åˆ—èµ‹å€¼ï¼Œå®Œæˆplan

  subquery_planner
    å­æŸ¥è¯¢è®¡åˆ’ï¼Œæ‰€æœ‰æŸ¥è¯¢éƒ½æ˜¯å­æŸ¥è¯¢è¿­ä»£ï¼Œè¿™ä¸ªå‡½æ•°å¤„ç†å®é™…çš„plan
    
    å¦‚æœå­˜åœ¨cteå®šä¹‰ï¼Œåˆ™è®¾ç½®å…¥SS_process_ctes
    å¦‚æœæ²¡æœ‰fromå®šä¹‰ï¼Œä½¿ç”¨replace_empty_jointreeè®¾ç½®ä¸€ä¸ªç©ºå€¼
    å¯¹äºANYä»¥åŠ EXISTS ï¼Œæ‰§è¡Œpull_up_sublinksï¼Œä¹Ÿå°±æ˜¯æ‰§è¡ŒæŸ¥è¯¢è€Œéä¸‹æ¨åˆ°å­æŸ¥è¯¢
    å¯¹äºå¯ä»¥é¢„å…ˆå¤„ç†çš„å‡½æ•°ï¼Œæ‰§è¡Œinline_set_returning_functions è®¾ç½®ä¸ºinlineçŠ¶æ€
    æ£€æŸ¥å¹¶åˆå¹¶æ‰€æœ‰å¯ä»¥åˆå¹¶çš„å­æŸ¥è¯¢pull_up_subqueries
    å¯¹äºunion allï¼Œæ‰§è¡Œflatten_simple_union_allåˆå¹¶åˆ°append relã€‚

    å¤„ç†joinçš„æƒ…å†µï¼Œé€ä¸ªè¡¨è¿›è¡Œè¿­ä»£ï¼Œæ ¹æ®rtekindè¿›è¡Œåˆ¤æ–­
      RTE_RELATION
        å¦‚æœè®¾ç½®äº†inhï¼Œæ£€æŸ¥æ˜¯å¦ä¸ºæœ‰å­æŸ¥è¯¢çš„é¡¹ç›®ï¼Œå¦‚æœæ²¡æœ‰ï¼Œæ¸…ç†inhæ ‡è®°
      RTE_JOIN
        å¦‚æœæ˜¯å¤–æŸ¥è¯¢ï¼Œåˆ™è®¾ç½®å¤–æŸ¥è¯¢æ ‡è®°
      RTE_RESULT
        å¦‚æœæ˜¯ç»“æœï¼Œè®¾ç½®hasResultRTEsä¸ºtrueï¼Œè¿™æ˜¯æ‰§è¡Œè®¡åˆ’å…¨å±€è®¾ç½®
      å¦‚æœè®¾äº†lateralï¼Œåˆ™hasLateralRTEsä¸ºtrue
      
      æœ€åè®¾ç½®å®‰å…¨æŸ¥è¯¢çº§åˆ«

    æ‰§è¡ŒRowMarkçš„å‰ç½®ä»»åŠ¡ preprocess_rowmarks

    å¦‚æœè®¾ç½®äº†having è®¾ç½®hasHavingQualæ ‡è®°

    æ¸…ç†hasPseudoConstantQualsæ ‡è®°ï¼Œ
      
    å¤„ç†preprocess_expressionè¡¨è¾¾å¼

    å¯¹äºhasTargetSRFsé»˜è®¤ä¸ºtrue(å‡½æ•°ä¼šè¿”å›ä¸€ç»„è¿”å›å€¼çš„æƒ…å†µï¼‰ï¼Œé€šè¿‡expression_returns_setè®¡ç®—å¾—åˆ°å…¶å®é™…æ˜¯å¦å­˜åœ¨

    å¯¹äºä½¿ç”¨äº†WITH CHECK OPTIONçš„æƒ…å†µï¼Œä½¿ç”¨WithCheckOptionå¤„ç†æ‰€æœ‰è¡¨è¾¾å¼çš„qualåˆ°withCheckOptions

    è®¡ç®—returningListçš„è¿”å›æƒ…å†µï¼Œç¡®å®šå…¶è¿”å›å•å€¼è¿˜æ˜¯list

    preprocess_qual_conditionsé€ä¸ªè®¡ç®—æ‰€æœ‰å­æŸ¥è¯¢çš„qualï¼ˆçº¦æŸï¼‰

    preprocess_expressionè®¡ç®—å½“å‰æŸ¥è¯¢çš„havingQual

    å¯¹äºæ‰€æœ‰çš„windowsè°ƒç”¨
      è®¾ç½®windowsèµ·ç‚¹
      è®¾ç½®windowç»ˆç‚¹
    
    è®¾ç½®limitçš„offsetå’Œcount

    å¯¹äºè®¾ç½®äº†onConflictçš„æƒ…å†µ
      å¤„ç†è®¾å®šçš„å¯èƒ½å†²çªçš„å‚æ•°ï¼Œå†²çªwhereæ¡ä»¶ï¼Œsetæ“ä½œï¼Œä»¥åŠsetå…³è”çš„whereæ¡ä»¶

    åˆå§‹åŒ–append_rel_listï¼ˆæ ¹æ®å½“å‰append_rel_listé¢„è®¡ç®—è®¡ç®—è¡¨è¾¾å¼ï¼‰

    å¤„ç†æ‰€æœ‰å­è¡¨çš„RTEè¡¨è¾¾å¼
      RTE_RELATION å¯¹è±¡æ˜¯è¡¨ è®¾ç½®ä¸ºç®€å•è¡¨æŸ¥è¯¢
      RTE_SUBQUERY å¯¹è±¡æ˜¯å­æŸ¥è¯¢ å¤„ç†å­æŸ¥è¯¢çš„åˆ«åé—®é¢˜
      RTE_FUNCTION å¯¹è±¡æ˜¯å‡½æ•° ç›´æ¥è°ƒç”¨preprocess_expressionå¤„ç†
      RTE_TABLEFUNC å¯¹è±¡æ˜¯è¡¨å‡½æ•°ï¼ˆåˆ—çš„åˆ—è¡¨ï¼‰ç›´æ¥è°ƒç”¨preprocess_expressionå¤„ç†
      RTE_VALUES å¯¹è±¡æ˜¯valuesåˆ—è¡¨ï¼Œä½¿ç”¨preprocess_expressionå¤„ç†
      
      æœ€åå¤„ç†å®‰å…¨è®¾ç½®rte-&gt;securityQuals

    å¯¹äºå­˜åœ¨hasJoinRTEsçš„æƒ…å†µï¼Œæ¸…ç†æ‰æ‰€æœ‰joinaliasvarsï¼ˆå‰é¢å·²ç»é€šè¿‡è¡¨è¾¾å¼é¢„å¤„ç†å¤„ç†æ‰äº†åˆ«åçš„æƒ…å†µï¼‰

    å°è¯•å¤„ç†havingæ“ä½œåˆ°whereæ¡ä»¶é‡Œé¢
      å¯¹äº
        åŒ…å«å­æŸ¥è¯¢
        å­˜åœ¨group set
        å­˜åœ¨å‡½æ•°è®¡ç®—
        å­˜åœ¨ç»Ÿè®¡è®¡ç®—
      çš„æ¡ä»¶ï¼Œä¸å¤„ç†
      å¯¹äºæ²¡æœ‰group setçš„æƒ…å†µï¼Œå¤„ç†havingæ¡ä»¶åˆ°where 
      å…¶ä»–æ¡ä»¶havingå’Œwhereéƒ½å¤åˆ¶ä¸€ä»½
    
    å»æ‰ä¸å¿…è¦çš„groupingåˆ— remove_useless_groupby_columns

    reduce_outer_joinså°è¯•å»æ‰å¤–æŸ¥è¯¢ï¼Œå˜æˆå†…è”æŸ¥è¯¢
    remove_useless_result_rtes å°è¯•åˆ é™¤æ²¡æœ‰è¢«ç”¨åˆ°çš„ç»“æœè¡¨è¾¾å¼

    å¯¹äºç»§æ‰¿è¡¨æ‰§è¡Œinheritance_planner
    é»˜è®¤æ‰§è¡Œgrouping_planner
    
    SS_identify_outer_params æ‰¾åˆ°æ‰€éœ€è¦å¤–å±‚ä¼ å…¥çš„å‚æ•°

    SS_charge_for_initplans ä¿®æ”¹initè®¡åˆ’
      é‡æ–°è®¡ç®—initplan_costï¼š æ¯ä¸ªå­æŸ¥è¯¢çš„initsubplan-&gt;startup_cost + initsubplan-&gt;per_call_cost;
      å½“å‰path-&gt;startup_costï¼Œpath-&gt;total_costéƒ½ä¼šåŠ ä¸Šinitplan_cost
    set_cheapest æœ€ç»ˆç¡®è®¤å½“å‰æ˜¯æœ€ä¼˜æ‰§è¡Œè®¡åˆ’
      é€ä¸ªæ£€æŸ¥æ‰€æœ‰æ‰§è¡Œè·¯å¾„ï¼Œæ¯”è¾ƒé€‰æ‹©å‡ºæ¥æœ€å°ä»£ä»·path
  
  grouping_planner å®é™…æ‰§è¡Œplannerçš„å†…éƒ¨
    è®¾ç½®limitå’Œoffsetï¼Œå¯¹äºoffsetæ²¡æœ‰è®¾ç½®çš„è¯ï¼Œé»˜è®¤ä¸º0
    å¯¹äºUNION/INTERSECT/EXCEPT 
      å¯¹äºsortClause å­˜åœ¨sortçš„æƒ…å†µï¼Œè®¾ç½®tuple_fraction=0.0

      plan_set_operations
        ä½¿ç”¨æœ€å·¦ï¼ˆç¬¬ä¸€ä¸ªï¼‰æŸ¥è¯¢çš„åˆ—ä½œä¸ºé¡ºåº
        å¯¹äºé€’å½’union
          ç”Ÿæˆé€’å½’è·¯å¾„ generate_recursion_path ï¼Ÿ 
        é»˜è®¤æ‰§è¡Œ recurse_set_operationsï¼Ÿ
      æ£€æŸ¥æ˜¯å¦å¯ä»¥å¹¶è¡Œis_parallel_safe(root, (Node *) final_target-&gt;exprs);
      è¿™é‡Œå†æ¬¡æ£€æŸ¥ä¸å…è®¸ä½¿ç”¨for updateï¼Œfor shareå…³é”®å­—ï¼ˆè¯­æ³•å±‚å·²ç»æ£€æŸ¥ï¼Œè¿™é‡Œå†æ£€æŸ¥ä¸€éï¼‰
      æœ€åè®¾ç½®æ’åºçš„é¡ºåºmake_pathkeys_for_sortclauses
    å¯¹äºgroupingè®¾ç½®äº†setsçš„æƒ…å†µ
      æ‰§è¡Œpreprocess_grouping_setsé¢„å…ˆå¤„ç†
    å¦åˆ™æ­£å¸¸å¤„ç†groupè¯­æ³• preprocess_groupclause

    è®¾ç½®æŸ¥è¯¢ç›®æ ‡åˆ—è¡¨ï¼Œæ–¹ä¾¿ä¸Šå±‚ä½¿ç”¨ preprocess_targetlist

    å¤„ç†æ‰§è¡Œä»£ä»·
      get_agg_clause_costs

    å¯¹äºwindowså‡½æ•°
      find_window_functionsæ‰¾åˆ°æ‰€æœ‰å‡½æ•°ï¼Œä¹‹åselect_active_windowsè®¾ç½®åˆ°activeWindows

    å¯¹äºmaxï¼Œminè®¡ç®—ï¼Œæ‰§è¡Œpreprocess_minmax_aggregates ï¼ˆè¿™é‡Œä»£ç ä¸query_planneré‡å¤ï¼Œå¦‚æœéœ€è¦å˜æ›´minã€maxé€»è¾‘ï¼Œåˆ™éœ€è¦ä¸¤è¾¹ä¸€èµ·æ”¹ï¼‰

    ç¡®è®¤æ˜¯å¦æœ‰å†™æ­»çš„limit_tuplesä»¥åŠéä¾‹å¤–ï¼Œå¦‚æœæœ‰ï¼Œé‡‡ç”¨å†™æ­»çš„limit_tuplesï¼ˆä¾‹å¤–ä¸ºè¿™äº›ï¼š groupï¼Œgroup setï¼Œdistinctï¼Œaggregationï¼ˆèšåˆæ“ä½œï¼‰ï¼Œwindowså‡½æ•°ï¼Œhavingæ¡ä»¶ï¼Œå‡½æ•°è°ƒç”¨     è®¾ç½®root-&gt;limit_tuples = -1.0ï¼‰

    è®¾ç½®windowså›è°ƒactiveWindowsä»¥åŠgroupå›è°ƒgroupClauseï¼ŒåŒ…æ‹¬rollups

    æ‰§è¡Œquery_planner standard_qp_callback å¤„ç†æ‰§è¡Œè·¯å¾„ï¼Œå¹¶å¤„ç†sortï¼Œdistinctçš„æƒ…å†µ

    è½¬æ¢processed_tliståˆ°final_target create_pathtarget

    å¯¹äºorder byåˆ¤æ–­æ˜¯å¦å¯ä»¥è·³è¿‡æ’åºé˜¶æ®µ make_sort_input_target
      æ¯”å¦‚distinctï¼Œunionçš„æƒ…å†µ
    å¯¹äºwindowså‡½æ•°ï¼Œåˆ¤æ–­æ˜¯å¦å¯ä»¥è·³è¿‡groupèšåˆæ“ä½œ make_window_input_target
      å¦‚æœå·²ç»æœ‰é¢„å…ˆçš„å¤„ç†
    å¯¹äºhaving groupï¼ˆåŒ…æ‹¬havingï¼Œgroupï¼Œèšåˆå‡½æ•°ï¼Œgroup setçš„æƒ…å†µï¼‰
      è§„åˆ’æ˜¯å¦éœ€è¦è®¡ç®—
    å¯¹äºè¿”å›é›†åˆçš„å‡½æ•° SRF set-returning functions
      åˆ‡å‰²å‡ºæ¥stfs split_pathtarget_at_srfs
        final_target
        sort_input_target
        grouping_target
        scanjoin_target
    apply_scanjoin_target_to_paths å¤„ç†æ‰€æœ‰scanï¼Œjoin è¡¨ï¼Œå¹¶éå†å…¶å­ä»£ç”Ÿæˆæœ€ç»ˆçš„æ‰«æç›®æ ‡

    ä¿å­˜å¯¹è±¡ä¿¡æ¯
      root-&gt;upper_targets[UPPERREL_FINAL] = final_target;
      root-&gt;upper_targets[UPPERREL_ORDERED] = final_target;
      root-&gt;upper_targets[UPPERREL_DISTINCT] = sort_input_target;
      root-&gt;upper_targets[UPPERREL_WINDOW] = sort_input_target;
      root-&gt;upper_targets[UPPERREL_GROUP_AGG] = grouping_target;
    
    create_grouping_pathsåˆ›å»ºgroupingè·¯å¾„ï¼Œå¯¹äºSRFå•ç‹¬å¤„ç†adjust_paths_for_srfs

    create_window_pathsåˆ›å»ºwindowsæ‰§è¡Œè·¯å¾„ï¼Œå¯¹äºSRFå•ç‹¬å¤„ç†adjust_paths_for_srfs

    create_distinct_pathsåˆ›å»ºdistinctæ‰§è¡Œè·¯å¾„ï¼Œå¯¹äºsrfå•ç‹¬å¤„ç†adjust_paths_for_srfs

    create_ordered_pathsåˆ›å»ºorder byæ‰§è¡Œè·¯å¾„ï¼Œå¯¹äºsrfå•ç‹¬å¤„ç†adjust_paths_for_srfs

    è·å–ä¸Šå±‚rel fetch_upper_rel
      å¦‚æœä¸Šå±‚å…è®¸å¹¶è¡Œï¼Œåˆ™æ­¤å¤„å…è®¸å¹¶è¡Œ
      final_rel-&gt;consider_parallel = true;
    å¼€å§‹å¤„ç†æœ€ç»ˆæŸ¥è¯¢ éå†å½“å‰æ‰€æœ‰path
      å¯¹äºfor updateï¼Œshare åˆ›å»ºcreate_lockrows_path
      è®¾ç½®limit create_limit_path
      å¯¹äºéselectï¼ˆinsertï¼Œupdateï¼Œdeleteï¼‰æ–°å¢ModifyTableèŠ‚ç‚¹ parse-&gt;commandType != CMD_SELECT &amp;&amp; !inheritance_update
        ä½¿ç”¨ç´¢å¼•
        æ£€æŸ¥check option withCheckOptionLists
        è¿”å›åˆ—è¡¨ returningLists
        è¡Œæ ‡è®°ï¼ˆåŠ é”ï¼‰ rowMarks
        å¯¹äºåˆ†åŒºè¡¨å•ç‹¬æ ‡è®° rootRelation

        åˆ›å»ºcreate_modifytable_path æ–°å¢ModifyTableèŠ‚ç‚¹

        æ–°å¢åˆ°æ‰§è¡Œpath
    å¤„ç†partial add_partial_path
      å¯¹äºå¹¶è¡ŒæŸ¥è¯¢è®¤ä¸ºå¹¶ä¸å®‰å…¨ï¼Œå•ç‹¬å¤„ç†
    
    è®°å½•é¢å¤–ä¿¡æ¯
      extra.limit_needed = limit_needed(parse);
      extra.limit_tuples = limit_tuples;
      extra.count_est = count_est;
      extra.offset_est = offset_est;
    
    å¯¹äºfdw
      GetForeignUpperPaths æ–°å¢fdwæ‰§è¡Œè·¯å¾„

    create_upper_paths_hook
      æœ€åæ‰§è¡Œå…¶ä»–hook



  is_parallel_safe å¹¶è¡Œæ˜¯å¦å®‰å…¨
    å¯¹äºå‚æ•°æ¥æºä¸ºæœ¬æŸ¥è¯¢ï¼Œæˆ–è€…ä¸Šå±‚æŸ¥è¯¢çš„æƒ…å†µï¼Œè®¤ä¸ºå¯ä»¥å¹¶è¡ŒæŸ¥è¯¢
    max_parallel_hazard_walker
      è°ƒç”¨å‡½æ•°æ˜¯è‡ªå·±èŠ‚ç‚¹ä¸Šçš„ï¼Œå®‰å…¨
      å¯¹äºmax minæ¥è¯´ï¼Œå¹¶è¡ŒæŸ¥è¯¢æ˜¯å®‰å…¨çš„
      proparallel
        PROPARALLEL_SAFEï¼šfalse
        PROPARALLEL_RESTRICTED è¿”å› context-&gt;max_interesting == proparallel 
        PROPARALLEL_UNSAFE false context-&gt;max_hazard = proparallel;
      CoerceToDomainå…è®¸å¹¶è¡Œ domainç±»å‹ä¸å»ºè®®ä½¿ç”¨ä¸å¯å¹¶è¡ŒåŒ–çš„å‡½æ•°
      å¯¹äºè·å–åºåˆ—ä¸‹ä¸€ä¸ªå·çš„æƒ…å†µï¼Œè®¤ä¸ºä¸å®‰å…¨
      windowså‡½æ•°è®¤ä¸ºæ˜¯å®‰å…¨çš„
      SubLinkï¼ˆanyä¹‹ç±»ï¼‰å®‰å…¨ //ç›®å‰åº”è¯¥ä¸ä¼šæœ‰è¿™ä¸ªæ‰§è¡Œè·¯å¾„
      å¯¹äºå­æŸ¥è¯¢ï¼Œåªæœ‰å®‰å…¨çš„å­æŸ¥è¯¢æ‰ä¼šè¢«æ ‡è®°ä¸ºå¯å¹¶è¡Œ
      å‚æ•°æ¥è‡ªæœ¬æŸ¥è¯¢ï¼Œè®¤ä¸ºå®‰å…¨ï¼Œå¦‚æœæ˜¯ä¸å¯æ§ï¼Œè®¤ä¸ºä¸å®‰å…¨
      for updateã€share è®¤ä¸ºä¸å®‰å…¨
      å¦‚æœä»¥ä¸Šæƒ…å†µéƒ½æœªå‘½ä¸­ï¼Œè¿­ä»£æ£€æŸ¥å­æŸ¥è¯¢ï¼Œä»¥åŠå‚æ•°


  apply_scanjoin_target_to_paths
    å¤„ç†æ‰€æœ‰scanï¼Œjoin è¡¨ï¼Œå¹¶éå†å…¶å­ä»£ç”Ÿæˆæœ€ç»ˆçš„æ‰«æç›®æ ‡
    å¯¹äºåˆ†åŒºè¡¨ï¼Œé‡æ–°ç”Ÿæˆæ‰«æå¯¹è±¡
    å¯¹äºä¸å¯ä»¥å¹¶è¡Œçš„æŸ¥è¯¢ï¼Œå…³é—­å¹¶è¡ŒæŸ¥è¯¢
    é€ä¸ªå¤„ç†ä¸æ¶‰åŠSRFçš„æ‰«æ
      å¯¹äºtlist_same_exprsï¼ˆè¡¨è¾¾å¼åº”ç”¨äºå½“å‰å¯¹è±¡ï¼‰
        ä»…å¢åŠ sort group é¿å…é¢å¤–çš„æ‰§è¡Œè®¡åˆ’åˆ›å»ºä»£ä»·
        å¦åˆ™ create_projection_path
          åˆ›å»ºä¸€ä¸ªé¢„æµ‹æ‰§è¡Œpathï¼Œ
    å¯¹äºpartialè¿›è¡ŒåŒæ ·å¤„ç†
    å¯¹äºsrfï¼Œé€ä¸ªå¤„ç†adjust_paths_for_srfs
    è®¾ç½®å½“å‰å¯¹è±¡ä¸ºæœ€ç»ˆçš„scan/joinç›®æ ‡ï¼ˆå³ä¾¿æ˜¯SRFï¼‰
    
    å¯¹äºåˆ†åŒºè¡¨
      ç”ŸæˆAppend scanã€joinå‘ç”Ÿåœ¨appendä¸‹è€Œéå…¶ä¸Šï¼Œæœ€ç»ˆèšåˆåˆ°å•ç‹¬çš„resultå¤„ç†
      é€ä¸ªåˆ†åŒºéå†
        æŠŠæ¯ä¸ªåˆ†åŒºçš„æ‰«æè·¯å¾„è®¾ç½®ä¸ºåˆ†åŒºè·¯å¾„è€Œéè¡¨è·¯å¾„
          PathTarget *target = lfirst_node(PathTarget, lc);
          target = copy_pathtarget(target);
        é™„åŠ æ‰«æç‚¹åˆ°child_scanjoin_targets
        apply_scanjoin_target_to_pathsæ›¿æ¢åŸå…ˆçš„æ‰§è¡Œè·¯å¾„
        add_paths_to_append_relæ–°å¢æ‰§è¡Œè·¯å¾„
        apply_scanjoin_target_to_pathsæ­¤å¤„å‘å†…è¿­ä»£
        live_children ä»…å¤„ç†å®é™…å­˜åœ¨çš„å­åˆ†åŒºï¼ˆæœ‰å¯èƒ½æ˜¯dummyå¯¹è±¡ï¼‰
    å¯¹äºå¯ä»¥å¹¶è¡Œçš„æŸ¥è¯¢ï¼ˆå¯¹è±¡ä¸æ˜¯å¤–æŸ¥è¯¢å¯¹è±¡ï¼‰
      generate_gather_pathsç”Ÿæˆå¹¶è¡ŒæŸ¥è¯¢è®¡åˆ’
        create_gather_pathç”Ÿæˆsimple_gather_path
        å¯¹äºæ¯ä¸ªpathå†…çš„åˆ—è¡¨
          ç”Ÿæˆcreate_gather_merge_path
    æœ€åé‡æ–°é€‰å–ä»£ä»·æœ€ä½çš„æ‰§è¡Œè®¡åˆ’
      set_cheapest

  query_planner
    å¤„ç†æ‰§è¡Œè·¯å¾„
  create_pathtarget
    åˆ›å»ºæ‰§è¡Œè·¯å¾„
  get_agg_clause_costs è®¡ç®—èšåˆä»£ä»·
  create_projection_path åˆ›å»ºæ‰§è¡Œé¢„æµ‹path
  make_sort_input_target åˆ¤æ–­æ˜¯å¦å¯ä»¥è·³è¿‡sort
  make_window_input_target åˆ¤æ–­æ˜¯å¦å¯ä»¥è·³è¿‡groupingæ“ä½œ    
</code></pre><h3 id=paths-and-join-pairs-1>Paths and Join Pairs</h3><ul><li>ä¼˜åŒ–ä¸­ç”Ÿæˆçš„å…·ä½“çš„æ‰§è¡Œè®¡åˆ’çš„å…·ä½“ç»“æ„ï¼ŒåªåŒ…å«æ‰§è¡Œå™¨çš„å¿…è¦ä¿¡æ¯ï¼Œå’Œé€»è¾‘ç®—å­ä¸€ä¸€å¯¹åº”</li><li>ä¼˜åŒ–è¿‡ç¨‹ä¸­å¯¹è¡¨æˆ–è€…joinï¼Œè‡ªæŸ¥è¯¢ç”Ÿæˆ reloptinfo ç»“æ„ä½“ï¼Œæ˜¯ä¸€ä¸ªé«˜å±‚æ¬¡çš„æŠ½è±¡ç»“æ„ï¼ŒåŒ…å«åŸºç¡€çš„ reloptinfo çš„ç»„åˆï¼Œè¿˜ä¼šç”ŸæˆåŒ…å«çš„ reloptinfo çš„pathï¼Œæœ€ç»ˆä¼šè¾“å‡º ä»£ä»·æœ€å°çš„ path</li><li>ä¸€ä¸ª reloptinfo å¯èƒ½åŒ…å«å¤šæ¡ path</li><li>A Path for a join relation is actually a tree structure</li></ul><h3 id=join-tree-construction-1>Join Tree Construction</h3><p>å½“å‰çœ‹ä¸‹æ¥ï¼Œä»–çš„ä¸»è¦æµç¨‹æ˜¯å…ˆä½¿ç”¨prepä¸­çš„æ–¹æ³•å¯¹queryå…ˆè¿›è¡Œé¢„å¤„ç†ï¼Œæ‰§è¡Œå¸¸è§„çš„åŸºäºè§„åˆ™çš„ä¼˜åŒ–ï¼Œä¹‹åä½¿ç”¨pathä¸­çš„æ–¹æ³•ï¼Œå¯¹å¤„ç†ä¹‹åçš„è¯­æ³•æ ‘è¿›è¡Œå¤„ç†ï¼Œæ‰¾åˆ°ä»£ä»·æœ€å°çš„pathã€‚
å¯¹äºpathçš„ï¼Œå¦‚æœæ²¡æœ‰joinï¼Œåˆ™ç›´æ¥æŸ¥æ‰¾tableçš„pathå³å¯ï¼Œå¦‚æœæœ‰å¤šè¡¨joinçš„åœºæ™¯ï¼Œåˆ™éœ€è¦è¿›è¡Œpathçš„ç»„åˆï¼Œä½¿ç”¨ä¸€å®šçš„æœç´¢ç­–ç•¥æ¥è¿›è¡Œè·¯å¾„æœç´¢ï¼Œ
å½“å‰æœ‰ä¸‰ç§ä¸»æµçš„ä¼˜åŒ–æ–¹æ³•</p><ol><li>system-R</li><li>cascades</li><li>gen
pgä½¿ç”¨è‡ªåº•å‘ä¸Šçš„åŠ¨æ€è§„åˆ’ç®—æ³•å’ŒåŸºå› ç®—æ³•ï¼Œé»˜è®¤è¡¨æ•°é‡å¤§äº12çš„æ—¶å€™ï¼Œä½¿ç”¨åŸºå› ç®—æ³•ï¼Œæ‰€ä»¥è¿™é‡Œæˆ‘åªå…³æ³¨system-Rç®—æ³•</li></ol><h3 id=ä¼˜åŒ–å™¨ä»£ç ç»†èŠ‚>ä¼˜åŒ–å™¨ä»£ç ç»†èŠ‚</h3><p>å…·ä½“çš„ä»£ç å…¥å£åœ¨exec_simple_queryä¸­ï¼Œæ¥å—è¯­å¥ä½¿ç”¨pg_parse_queryç¼–è¯‘ï¼Œè¾“å‡ºæ˜¯ä¸€ä¸ªlistï¼Œå…·ä½“çš„ä¾‹å­å¯ä»¥æŸ¥çœ‹ä¸‹é¢çš„è¯­å¥ï¼Œgdbä¸­ä½¿ç”¨ <code>p pprint(parsetree_list)</code>å¯ä»¥æ‰“å°listï¼Œå¯¹äºå…·ä½“çš„å†…éƒ¨çš„æ•°æ®ç»“æ„ï¼Œä¾‹å¦‚List,Nodeç­‰ï¼Œå¯ä»¥gdbè°ƒè¯•pprintï¼Œå¯ä»¥æŸ¥çœ‹ä»–ä»¬ä¹‹é—´çš„ç»“æ„å…³ç³»</p><p>parserå‡ºæ¥æ˜¯listï¼Œåœ¨æ‰“å°çš„æ—¶å€™ï¼Œä½¿ç”¨pprintï¼Œåœ¨å†…éƒ¨åˆ¤æ–­listç±»å‹ï¼Œå–å‡ºå®é™…çš„æ•°æ®ï¼Œç„¶åæŒ‰ç…§NodeTagè¿›è¡Œè½¬æ¢ï¼ŒNodeTagåœ¨å‡ ä¹æ‰€æœ‰çš„æ•°æ®ç»“æ„ä¸­éƒ½åœ¨ç¬¬ä¸€ä½ï¼Œç›®çš„æ˜¯ä¸ºäº†ä¾¿æ·eiderè¿›è¡Œè½¬æ¢ï¼Œä»¥selectä¸ºä¾‹<br>åœ¨è¯­æ³•æ–‡ä»¶ä¸­ï¼Œselectstmtæ˜¯ä¸€ä¸ªç»“æ„ä½“ï¼Œå…·ä½“ç”Ÿæˆå¦‚ä¸‹ï¼Œ</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>simple_select:
</span></span><span style=display:flex><span>      SELECT opt_all_clause opt_target_list
</span></span><span style=display:flex><span>      into_clause from_clause where_clause
</span></span><span style=display:flex><span>      group_clause having_clause window_clause
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          SelectStmt <span style=color:#f92672>*</span>n <span style=color:#f92672>=</span> makeNode(SelectStmt);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          n<span style=color:#f92672>-&gt;</span>targetList <span style=color:#f92672>=</span> <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>          n<span style=color:#f92672>-&gt;</span>intoClause <span style=color:#f92672>=</span> <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>          n<span style=color:#f92672>-&gt;</span>fromClause <span style=color:#f92672>=</span> <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>          n<span style=color:#f92672>-&gt;</span>whereClause <span style=color:#f92672>=</span> <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>6</span>;
</span></span><span style=display:flex><span>          n<span style=color:#f92672>-&gt;</span>groupClause <span style=color:#f92672>=</span> (<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>7</span>)<span style=color:#f92672>-&gt;</span>list;
</span></span><span style=display:flex><span>          n<span style=color:#f92672>-&gt;</span>groupDistinct <span style=color:#f92672>=</span> (<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>7</span>)<span style=color:#f92672>-&gt;</span>distinct;
</span></span><span style=display:flex><span>          n<span style=color:#f92672>-&gt;</span>havingClause <span style=color:#f92672>=</span> <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>          n<span style=color:#f92672>-&gt;</span>windowClause <span style=color:#f92672>=</span> <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>9</span>;
</span></span><span style=display:flex><span>          <span style=color:#960050;background-color:#1e0010>$$</span> <span style=color:#f92672>=</span> (Node <span style=color:#f92672>*</span>) n;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>SelectStmt</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  NodeTag    type;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * These fields are used only in &#34;leaf&#34; SelectStmts.
</span></span></span><span style=display:flex><span><span style=color:#75715e>   */</span>
</span></span><span style=display:flex><span>  List     <span style=color:#f92672>*</span>distinctClause; <span style=color:#75715e>/* NULL, list of DISTINCT ON exprs, or
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * lcons(NIL,NIL) for all (SELECT DISTINCT) */</span>
</span></span><span style=display:flex><span>  IntoClause <span style=color:#f92672>*</span>intoClause;    <span style=color:#75715e>/* target for SELECT INTO */</span>
</span></span><span style=display:flex><span>  List     <span style=color:#f92672>*</span>targetList;    <span style=color:#75715e>/* the target list (of ResTarget) */</span>
</span></span><span style=display:flex><span>  List     <span style=color:#f92672>*</span>fromClause;    <span style=color:#75715e>/* the FROM clause */</span>
</span></span><span style=display:flex><span>  Node     <span style=color:#f92672>*</span>whereClause;  <span style=color:#75715e>/* WHERE qualification */</span>
</span></span><span style=display:flex><span>  List     <span style=color:#f92672>*</span>groupClause;  <span style=color:#75715e>/* GROUP BY clauses */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span>    groupDistinct;  <span style=color:#75715e>/* Is this GROUP BY DISTINCT? */</span>
</span></span><span style=display:flex><span>  Node     <span style=color:#f92672>*</span>havingClause;  <span style=color:#75715e>/* HAVING conditional-expression */</span>
</span></span><span style=display:flex><span>  List     <span style=color:#f92672>*</span>windowClause;  <span style=color:#75715e>/* WINDOW window_name AS (...), ... */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * In a &#34;leaf&#34; node representing a VALUES list, the above fields are all
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * null, and instead this field is set.  Note that the elements of the
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * sublists are just expressions, without ResTarget decoration. Also note
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * that a list element can be DEFAULT (represented as a SetToDefault
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * node), regardless of the context of the VALUES list. It&#39;s up to parse
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * analysis to reject that where not valid.
</span></span></span><span style=display:flex><span><span style=color:#75715e>   */</span>
</span></span><span style=display:flex><span>  List     <span style=color:#f92672>*</span>valuesLists;  <span style=color:#75715e>/* untransformed list of expression lists */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * These fields are used in both &#34;leaf&#34; SelectStmts and upper-level
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * SelectStmts.
</span></span></span><span style=display:flex><span><span style=color:#75715e>   */</span>
</span></span><span style=display:flex><span>  List     <span style=color:#f92672>*</span>sortClause;    <span style=color:#75715e>/* sort clause (a list of SortBy&#39;s) */</span>
</span></span><span style=display:flex><span>  Node     <span style=color:#f92672>*</span>limitOffset;  <span style=color:#75715e>/* # of result tuples to skip */</span>
</span></span><span style=display:flex><span>  Node     <span style=color:#f92672>*</span>limitCount;    <span style=color:#75715e>/* # of result tuples to return */</span>
</span></span><span style=display:flex><span>  LimitOption limitOption;  <span style=color:#75715e>/* limit type */</span>
</span></span><span style=display:flex><span>  List     <span style=color:#f92672>*</span>lockingClause;  <span style=color:#75715e>/* FOR UPDATE (list of LockingClause&#39;s) */</span>
</span></span><span style=display:flex><span>  WithClause <span style=color:#f92672>*</span>withClause;    <span style=color:#75715e>/* WITH clause */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * These fields are used only in upper-level SelectStmts.
</span></span></span><span style=display:flex><span><span style=color:#75715e>   */</span>
</span></span><span style=display:flex><span>  SetOperation op;      <span style=color:#75715e>/* type of set op */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span>    all;      <span style=color:#75715e>/* ALL specified? */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>SelectStmt</span> <span style=color:#f92672>*</span>larg;  <span style=color:#75715e>/* left child */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>SelectStmt</span> <span style=color:#f92672>*</span>rarg;  <span style=color:#75715e>/* right child */</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* Eventually add fields for CORRESPONDING spec here */</span>
</span></span><span style=display:flex><span>} SelectStmt;
</span></span></code></pre></div><p>ä¹‹åè¿›è¡Œä¼ é€’çš„æ—¶å€™ä½¿ç”¨çš„æ˜¯listæˆ–è€…nodeç±»å‹ï¼Œåœ¨printçš„æ—¶å€™ï¼Œä½¿ç”¨<code>switch (nodeTag(obj))</code>åˆ¤æ–­ç±»å‹ï¼Œæœ€åé€‰æ‹©<code>case T_SelectStmt:</code>åˆ†æ”¯ï¼Œæ‰§è¡Œ<code>_outSelectStmt</code>æ–¹æ³•ï¼Œå…·ä½“æ–¹æ³•å¦‚ä¸‹ï¼Œæœ€ç»ˆè§£æå„ä¸ªclause</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>_outSelectStmt</span>(StringInfo str, <span style=color:#66d9ef>const</span> SelectStmt <span style=color:#f92672>*</span>node)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  WRITE_NODE_TYPE(<span style=color:#e6db74>&#34;SELECTSTMT&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  WRITE_NODE_FIELD(distinctClause);
</span></span><span style=display:flex><span>  WRITE_NODE_FIELD(intoClause);
</span></span><span style=display:flex><span>  WRITE_NODE_FIELD(targetList);
</span></span><span style=display:flex><span>  WRITE_NODE_FIELD(fromClause);
</span></span><span style=display:flex><span>  WRITE_NODE_FIELD(whereClause);
</span></span><span style=display:flex><span>  WRITE_NODE_FIELD(groupClause);
</span></span><span style=display:flex><span>  WRITE_BOOL_FIELD(groupDistinct);
</span></span><span style=display:flex><span>  WRITE_NODE_FIELD(havingClause);
</span></span><span style=display:flex><span>  WRITE_NODE_FIELD(windowClause);
</span></span><span style=display:flex><span>  WRITE_NODE_FIELD(valuesLists);
</span></span><span style=display:flex><span>  WRITE_NODE_FIELD(sortClause);
</span></span><span style=display:flex><span>  WRITE_NODE_FIELD(limitOffset);
</span></span><span style=display:flex><span>  WRITE_NODE_FIELD(limitCount);
</span></span><span style=display:flex><span>  WRITE_ENUM_FIELD(limitOption, LimitOption);
</span></span><span style=display:flex><span>  WRITE_NODE_FIELD(lockingClause);
</span></span><span style=display:flex><span>  WRITE_NODE_FIELD(withClause);
</span></span><span style=display:flex><span>  WRITE_ENUM_FIELD(op, SetOperation);
</span></span><span style=display:flex><span>  WRITE_BOOL_FIELD(all);
</span></span><span style=display:flex><span>  WRITE_NODE_FIELD(larg);
</span></span><span style=display:flex><span>  WRITE_NODE_FIELD(rarg);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>ä»¥å‰é˜…è¯»è¿‡oceanbaseä»¥åŠtidbçš„ä»£ç ï¼Œç°åœ¨æƒ³æ¥ä¹Ÿæ˜¯ä¼¼æ›¾ç›¸è¯†ï¼Œä»–ä»¬çš„åšæ³•éƒ½æ˜¯ç±»ä¼¼çš„ï¼Œåœ¨parseré˜¶æ®µï¼Œè¯­æ³•æŒ‰ç…§stmtç»„ç»‡ç»“æ„ï¼Œç°åœ¨åªæ˜¯æš‚æ—¶æ¥è§¦pgï¼Œå°šä¸æ¸…æ¥šä¼˜ç‚¹æ˜¯ä»€ä¹ˆï¼Œåç»­æœ‰æ·±å…¥çš„äº†è§£ä¹‹åå†è¯¦ç»†æ¢ç©¶</p></blockquote><p>stmtæ˜¯ç‰¹å®šçš„æ•°æ®ç»“æ„ï¼Œåç»­çš„å¤„ç†éœ€è¦ç»Ÿä¸€çš„æ•°æ®ç»“æ„queryï¼Œæ‰€ä»¥éœ€è¦è¿›è¡Œè½¬æ¢ï¼Œå…¥å£ä¸º<code>parse_analyze_fixedparams</code></p><ol><li>å…ˆå¤„ç†select into ï¼Œè½¬æ¢ä¸ºcreate table as ,å¤„ç†å‡½æ•°å†transformOptionalSelectIntoï¼Œä¸»è¦æ˜¯å»ºç«‹CreateTableAsStmtï¼Œç„¶åæŠŠintoä¸Šæ‹‰åˆ°CreateTableAsStmtä¸­</li><li>ä¹‹åä½¿ç”¨transformStmtå¤„ç†stmtï¼Œ<code>switch (nodeTag(parseTree))</code>é€‰æ‹©åˆé€‚çš„åˆ†æ”¯ï¼Œè¿™é‡Œä»¥selectä¸ºä¾‹å­</li><li>è¿›å…¥transformSelectStmtåˆ†æ”¯</li><li>å…ˆè½¬æ¢transformWithClause</li><li>è½¬æ¢transformFromClause
&mldr;</li></ol><p>æœ€ç»ˆå¾—åˆ°ä¸€ä¸ªqueryï¼Œä¸€ä¸ªå®Œæ•´çš„ç»“æ„ä½“ï¼ŒåŒ…å«è¯­å¥çš„æ‰€æœ‰ä¿¡æ¯ï¼Œåç»­è¿›è¡Œrewriteï¼Œ
å¯¹äºrewriteã€‚è²Œä¼¼æ˜¯å’Œä¹‹å‰äº†è§£çš„ä¸å¤ªä¸€æ¨ï¼Œä¹‹å‰çš„ç†è§£æ˜¯è¿›è¡ŒåŸºäºè§„åˆ™çš„é‡å†™ï¼Œä½†æ˜¯è¿™é‡Œå¥½åƒæ˜¯ä½¿ç”¨è‡ªå®šä¹‰çš„ruleé‡å†™ï¼Œç±»ä¼¼äºè§¦å‘å™¨ï¼Œå…¶ä»–æ•°æ®åº“ä¸­ï¼Œåªæœ‰sql serveræœ‰ç±»ä¼¼çš„å®ç°ï¼Œä½†æ˜¯å·²ç»å£°æ˜åœ¨ä¹‹åçš„ç‰ˆæœ¬ä¸­ä¼šç§»é™¤è¿™ä¸ªä¸œè¥¿ï¼Œæ‰€ä»¥åœ¨ä»£ç ä¸­å æ®ç›¸å½“ä¸€éƒ¨åˆ†åˆ†é‡çš„åŠŸèƒ½æ˜¯å¦æ˜¯å¿…è¦çš„ï¼Œ</p><p>TODO: åç»­æˆ‘è‡ªèº«ä¼šè¿›è¡Œè°ƒç ”ï¼Œå¦‚æœç¡®å®šæ˜¯ä¸Šè¿°çš„ä¸œè¥¿ï¼Œæˆ–è®¸å¯ä»¥å°è¯•ç§»é™¤è¿™ä¸ªåŠŸèƒ½</p><p>ä¹‹åç»“æ„ä¸ºqueryï¼Œä¼šå‚ä¸åˆ°pg_plan_queriesä¸­</p><h3 id=ä¼˜åŒ–>ä¼˜åŒ–</h3><p>å¯¹äºutilityè¯­å¥ï¼Œç›´æ¥è·³è¿‡ï¼Œä»–åªæ˜¯ä»£ç å‡½æ•°çš„é›†åˆï¼Œå¯¹äºDMLï¼Œè¿›è¡Œpg_plan_queryä¼˜åŒ–ï¼Œåˆ†ä¸ºå‡ ä¸ªæ­¥éª¤</p><ol><li>åŸºäºè§„åˆ™çš„ä¼˜åŒ–</li><li>join è·¯å¾„ä¼˜åŒ–</li></ol><p>standard_planner
subquery_planner
SS_process_ctes
transform_MERGE_to_join
replace_empty_jointree
pull_up_sublinks
preprocess_function_rtes
pull_up_subqueries
flatten_simple_union_all
preprocess_rowmarks
preprocess_expression
preprocess_qual_conditions
remove_useless_groupby_columns
reduce_outer_joins
remove_useless_result_rtes
grouping_planner
query_planner
SS_identify_outer_params
fetch_upper_rel
get_cheapest_fractional_path
create_plan</p><ul><li><p>subquery_planner<br>ä½¿ç”¨ä¸€äº›è§„åˆ™å¯¹æ ‘è¿›è¡Œå˜æ¢ï¼Œè°ƒæ•´ä¸ºè§„åˆ™ä¸Šæ›´ä¼˜çš„æ‰§è¡Œè®¡åˆ’ï¼Œè¿™é‡Œå¤„ç†çš„æ•°æ®ç»“æ„ä¸»è¦æ˜¯Queryï¼Œä½¿ç”¨PlannerInfoåŒ…è£…Queryï¼Œä¿å­˜ä¸€äº›ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œæ‰€ä»¥ä»–çš„å¤„ç†è¿˜æ˜¯è¿‡ç¨‹å¼çš„ï¼ŒæŒ‰ç…§å…·ä½“çš„è¯­å¥åœºæ™¯è¿›è¡Œå¤„ç†ï¼Œå¯¹äºä¸æ˜¯å¤ªç†Ÿæ‚‰çš„ä»–æ•°æ®ç»“æ„çš„äººæ¥è¯´ï¼Œéœ€è¦å¤§é‡çš„è®°å¿†æ—¶é—´ï¼Œä¸ªäººçœ‹æ¥ï¼Œè¿™ç§ä¼˜åŒ–æ–¹å¼ä¸æ˜¯å¤ªå‹å¥½ï¼Œå¦‚æœæƒ³è¦è¿›è¡Œä¸€äº›æ‰©å±•ï¼Œå¯¹äººå‘˜çš„è¦æ±‚å¾ˆé«˜</p></li><li><p>path<br>make_one_rel<br>set_base_rel_pathlists
make_rel_from_joinlist
standard_join_search
è‡ªåº•å‘ä¸Šçš„åŠ¨æ€è§„åˆ’ï¼Œå…ˆç”ŸæˆåŸºç¡€è¡¨çš„pathï¼Œpathæ˜¯å½“å‰å±€éƒ¨æœ€ä¼˜çš„ï¼Œä¼šè€ƒè™‘å¯åŠ¨æœ€ä¼˜ï¼Œæ€»ä»£ä»·æœ€ä¼˜ï¼Œæœ€å¥½çš„æ’åºç»“æœï¼Œå…¶ä»–ä»£ä»·è¾ƒå¤§çš„pathç›´æ¥ä¸¢å¼ƒï¼Œè¿™ç±»ä¼¼åŠ¨æ€è§„åˆ’çš„ç¬¬ä¸€å±‚ï¼Œç„¶åè¿›è¡Œç»„åˆï¼Œç”Ÿæˆjoinçš„pathï¼Œä½¿ç”¨åçš„æ˜¯make_rel_from_joinlistï¼Œ</p></li><li><p>get_cheapest_fractional_path<br>ä½¿ç”¨é€‰æ‹©ç‡tuple_fractionï¼Œå¯¹RelOptInfo->cheapest_total_pathè¿›è¡ŒäºŒæ¬¡è°ƒæ•´</p></li><li><p>create_plan<br>æŒ‰ç…§Pathï¼Œä½¿ç”¨PlannerInfoç”Ÿæˆplanï¼Œplançš„ç»“æ„æ˜¯äºŒå‰æ ‘çš„å½¢å¼ï¼Œæ‰§è¡Œçš„æ—¶å€™æŒ‰ç…§èŠ‚ç‚¹ä¾æ¬¡æ‰§è¡Œ</p></li><li><p><code>SS_process_ctes</code>
å¤ªä¸‘ä¸çœ‹ï¼Œå¤§è‡´æ˜¯æŠŠwithè¯­å¥è§†ä¸ºä¸€ä¸ªinitplanï¼ŒåµŒå…¥åˆ°æ‰§è¡Œè®¡åˆ’ä¸­</p></li><li><p><code>pull_up_sublinks</code>
å­é“¾æ¥ä¸Šæ‹‰ï¼Œå­é“¾æ¥å’Œå­æŸ¥è¯¢çš„åŒºåˆ«æ˜¯å­é“¾æ¥æ˜¯å‡ºç°åœ¨è¡¨è¾¾å¼ä¸­çš„å­æŸ¥è¯¢ï¼Œä¼šä¸Šæ‹‰ä¸ºåŠè¿æ¥ï¼Œè¿˜æ˜¯å±äºå­æŸ¥è¯¢å¾—ä¸€ç§ï¼Œpgä¸­è¿›è¡ŒåŒºåˆ†ï¼Œç›®çš„æ˜¯ä¸ºäº†ä¾¿äºä¼˜åŒ–</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>explain</span> <span style=color:#66d9ef>select</span>
</span></span><span style=display:flex><span>  s_name,
</span></span><span style=display:flex><span>  s_address
</span></span><span style=display:flex><span><span style=color:#66d9ef>from</span>
</span></span><span style=display:flex><span>  supplier,
</span></span><span style=display:flex><span>  nation
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>  s_suppkey <span style=color:#66d9ef>in</span> (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>select</span>
</span></span><span style=display:flex><span>      ps_suppkey
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>from</span>
</span></span><span style=display:flex><span>      partsupp
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>      ps_partkey <span style=color:#66d9ef>in</span> ( <span style=color:#66d9ef>select</span> p_partkey <span style=color:#66d9ef>from</span> part <span style=color:#66d9ef>where</span> p_name <span style=color:#66d9ef>like</span> <span style=color:#e6db74>&#39;forest%&#39;</span> )
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>and</span> ps_availqty <span style=color:#f92672>&gt;</span> (
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>select</span>
</span></span><span style=display:flex><span>          <span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>5</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>sum</span>(l_quantity)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>from</span>
</span></span><span style=display:flex><span>          lineitem
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>          l_partkey <span style=color:#f92672>=</span> ps_partkey
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>and</span> l_suppkey <span style=color:#f92672>=</span> ps_suppkey
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>and</span> l_shipdate <span style=color:#f92672>&gt;=</span> date <span style=color:#e6db74>&#39;1994-01-01&#39;</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>and</span> l_shipdate <span style=color:#f92672>&lt;</span> date <span style=color:#e6db74>&#39;1994-01-01&#39;</span> <span style=color:#f92672>+</span> interval <span style=color:#e6db74>&#39;1&#39;</span> <span style=color:#66d9ef>year</span>
</span></span><span style=display:flex><span>      )
</span></span><span style=display:flex><span>  )
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>and</span> s_nationkey <span style=color:#f92672>=</span> n_nationkey
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>and</span> n_name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;CANADA&#39;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>order</span> <span style=color:#66d9ef>by</span>
</span></span><span style=display:flex><span>  s_name;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                                                                                                                     QUERY PLAN
</span></span><span style=display:flex><span> Sort  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>2431</span>.<span style=color:#ae81ff>82</span>..<span style=color:#ae81ff>2431</span>.<span style=color:#ae81ff>82</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>202</span>)
</span></span><span style=display:flex><span>   Sort <span style=color:#66d9ef>Key</span>: supplier.s_name
</span></span><span style=display:flex><span>   <span style=color:#f92672>-&gt;</span>  Hash <span style=color:#66d9ef>Join</span>  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>2419</span>.<span style=color:#ae81ff>62</span>..<span style=color:#ae81ff>2431</span>.<span style=color:#ae81ff>76</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>202</span>)
</span></span><span style=display:flex><span>         Hash Cond: (nation.n_nationkey <span style=color:#f92672>=</span> supplier.s_nationkey)
</span></span><span style=display:flex><span>         <span style=color:#f92672>-&gt;</span>  Seq Scan <span style=color:#66d9ef>on</span> nation  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span>..<span style=color:#ae81ff>12</span>.<span style=color:#ae81ff>12</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>)
</span></span><span style=display:flex><span>               Filter: (n_name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;CANADA&#39;</span>::bpchar)
</span></span><span style=display:flex><span>         <span style=color:#f92672>-&gt;</span>  Hash  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>2419</span>.<span style=color:#ae81ff>60</span>..<span style=color:#ae81ff>2419</span>.<span style=color:#ae81ff>60</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>206</span>)
</span></span><span style=display:flex><span>               <span style=color:#f92672>-&gt;</span>  Hash Semi <span style=color:#66d9ef>Join</span>  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>2407</span>.<span style=color:#ae81ff>70</span>..<span style=color:#ae81ff>2419</span>.<span style=color:#ae81ff>60</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>206</span>)
</span></span><span style=display:flex><span>                     Hash Cond: (supplier.s_suppkey <span style=color:#f92672>=</span> partsupp.ps_suppkey)
</span></span><span style=display:flex><span>                     <span style=color:#f92672>-&gt;</span>  Seq Scan <span style=color:#66d9ef>on</span> supplier  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span>..<span style=color:#ae81ff>11</span>.<span style=color:#ae81ff>50</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>150</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>210</span>)
</span></span><span style=display:flex><span>                     <span style=color:#f92672>-&gt;</span>  Hash  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>2407</span>.<span style=color:#ae81ff>69</span>..<span style=color:#ae81ff>2407</span>.<span style=color:#ae81ff>69</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>)
</span></span><span style=display:flex><span>                           <span style=color:#f92672>-&gt;</span>  Hash Semi <span style=color:#66d9ef>Join</span>  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>12</span>.<span style=color:#ae81ff>01</span>..<span style=color:#ae81ff>2407</span>.<span style=color:#ae81ff>69</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>)
</span></span><span style=display:flex><span>                                 Hash Cond: (partsupp.ps_partkey <span style=color:#f92672>=</span> part.p_partkey)
</span></span><span style=display:flex><span>                                 <span style=color:#f92672>-&gt;</span>  Seq Scan <span style=color:#66d9ef>on</span> partsupp  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span>..<span style=color:#ae81ff>2395</span>.<span style=color:#ae81ff>52</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>57</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>)
</span></span><span style=display:flex><span>                                       Filter: ((ps_availqty)::numeric <span style=color:#f92672>&gt;</span> (SubPlan <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>                                       SubPlan <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                                         <span style=color:#f92672>-&gt;</span>  <span style=color:#66d9ef>Aggregate</span>  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>14</span>.<span style=color:#ae81ff>00</span>..<span style=color:#ae81ff>14</span>.<span style=color:#ae81ff>02</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>32</span>)
</span></span><span style=display:flex><span>                                               <span style=color:#f92672>-&gt;</span>  Seq Scan <span style=color:#66d9ef>on</span> lineitem  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span>..<span style=color:#ae81ff>14</span>.<span style=color:#ae81ff>00</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>18</span>)
</span></span><span style=display:flex><span>                                                     Filter: ((l_shipdate <span style=color:#f92672>&gt;=</span> <span style=color:#e6db74>&#39;1994-01-01&#39;</span>::date) <span style=color:#66d9ef>AND</span> (l_shipdate <span style=color:#f92672>&lt;</span> <span style=color:#e6db74>&#39;1995-01-01 00:00:00&#39;</span>::<span style=color:#66d9ef>timestamp</span> <span style=color:#66d9ef>without</span> time <span style=color:#66d9ef>zone</span>) <span style=color:#66d9ef>AND</span> (l_partkey <span style=color:#f92672>=</span> partsupp.ps_partkey) <span style=color:#66d9ef>AND</span> (l_suppkey <span style=color:#f92672>=</span> partsupp.ps_suppkey))
</span></span><span style=display:flex><span>                                 <span style=color:#f92672>-&gt;</span>  Hash  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>12</span>.<span style=color:#ae81ff>00</span>..<span style=color:#ae81ff>12</span>.<span style=color:#ae81ff>00</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>)
</span></span><span style=display:flex><span>                                       <span style=color:#f92672>-&gt;</span>  Seq Scan <span style=color:#66d9ef>on</span> part  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span>..<span style=color:#ae81ff>12</span>.<span style=color:#ae81ff>00</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> width<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>)
</span></span><span style=display:flex><span>                                             Filter: ((p_name)::text <span style=color:#f92672>~~</span> <span style=color:#e6db74>&#39;forest%&#39;</span>::text)
</span></span><span style=display:flex><span>(<span style=color:#ae81ff>22</span> <span style=color:#66d9ef>rows</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>-&gt;</span> Sort: supplier.s_name
</span></span><span style=display:flex><span>    <span style=color:#f92672>-&gt;</span> Stream results  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>.<span style=color:#ae81ff>05</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#f92672>-&gt;</span> Nested loop semijoin  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>.<span style=color:#ae81ff>05</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>            <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Inner</span> hash <span style=color:#66d9ef>join</span> (nation.n_nationkey <span style=color:#f92672>=</span> supplier.s_nationkey)  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>70</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                <span style=color:#f92672>-&gt;</span> Filter: (nation.n_name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;CANADA&#39;</span>)  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>35</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                    <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Table</span> scan <span style=color:#66d9ef>on</span> nation  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>35</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                <span style=color:#f92672>-&gt;</span> Hash
</span></span><span style=display:flex><span>                    <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Table</span> scan <span style=color:#66d9ef>on</span> supplier  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>35</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>            <span style=color:#f92672>-&gt;</span> Nested loop <span style=color:#66d9ef>inner</span> <span style=color:#66d9ef>join</span>  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>70</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                <span style=color:#f92672>-&gt;</span> Filter: ((partsupp.ps_suppkey <span style=color:#f92672>=</span> supplier.s_suppkey) <span style=color:#66d9ef>and</span> (partsupp.ps_availqty <span style=color:#f92672>&gt;</span> (<span style=color:#66d9ef>select</span> <span style=color:#f92672>#</span><span style=color:#ae81ff>4</span>)))  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>35</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                    <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Table</span> scan <span style=color:#66d9ef>on</span> partsupp  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>35</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                    <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Select</span> <span style=color:#f92672>#</span><span style=color:#ae81ff>4</span> (subquery <span style=color:#66d9ef>in</span> condition; dependent)
</span></span><span style=display:flex><span>                        <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Aggregate</span>: <span style=color:#66d9ef>sum</span>(lineitem.l_quantity)  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>45</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                            <span style=color:#f92672>-&gt;</span> Filter: ((lineitem.l_partkey <span style=color:#f92672>=</span> partsupp.ps_partkey) <span style=color:#66d9ef>and</span> (lineitem.l_suppkey <span style=color:#f92672>=</span> partsupp.ps_suppkey) <span style=color:#66d9ef>and</span> (lineitem.l_shipdate <span style=color:#f92672>&gt;=</span> DATE<span style=color:#e6db74>&#39;1994-01-01&#39;</span>) <span style=color:#66d9ef>and</span> (lineitem.l_shipdate <span style=color:#f92672>&lt;</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>cache</span><span style=color:#f92672>&gt;</span>((DATE<span style=color:#e6db74>&#39;1994-01-01&#39;</span> <span style=color:#f92672>+</span> interval <span style=color:#e6db74>&#39;1&#39;</span> <span style=color:#66d9ef>year</span>))))  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>35</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                                <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Table</span> scan <span style=color:#66d9ef>on</span> lineitem  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>35</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                <span style=color:#f92672>-&gt;</span> Filter: ((part.p_partkey <span style=color:#f92672>=</span> partsupp.ps_partkey) <span style=color:#66d9ef>and</span> (part.p_name <span style=color:#66d9ef>like</span> <span style=color:#e6db74>&#39;forest%&#39;</span>))  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>35</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                    <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Table</span> scan <span style=color:#66d9ef>on</span> part  (cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>35</span> <span style=color:#66d9ef>rows</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
</span></span></code></pre></div><p>é‡ç‚¹è¿˜æ˜¯éœ€è¦åŒºåˆ†å…³è”å­æŸ¥è¯¢å’Œéå…³è”å­æŸ¥è¯¢ï¼Œéå…³è”å­æŸ¥è¯¢ç›´æ¥æŸ¥è¯¢ç‰©åŒ–å³å¯ï¼Œä½†æ˜¯å…³è”å­æŸ¥è¯¢ç”±äºæ‰§è¡Œæ¨¡å¼ç±»ä¼¼nest loop joinï¼Œæ‰§è¡Œæ•ˆç‡ä¸é«˜ï¼Œæ‰€ä»¥éœ€è¦è¿›è¡Œç‰¹æ®Šå¤„ç†ï¼Œå½“å‰pgä¸­æœ‰ä¸¤ä¸ªå‡½æ•°</p><ol><li>å­é“¾æ¥çš„ä¸Šæ‹‰</li><li>å­æŸ¥è¯¢çš„ä¸Šæ‹‰</li></ol><p>æ–‡ç« å‚è€ƒ
<a href=https://zhuanlan.zhihu.com/p/60380557 target=_blank>1</a>
<a href=https://developer.aliyun.com/article/802290#slide-1 target=_blank>2</a>
<a href=https://blog.csdn.net/yunqiinsight/article/details/115323435 target=_blank>3</a></p><blockquote><p>planner_hookä½¿ç”¨cascadeå®ç°çš„å¯è¡Œæ€§åˆ†æ</p></blockquote><hr><ul><li>è¾“å…¥<ul><li>Query</li><li>const char *</li><li>int</li><li>ParamListInfo</li></ul></li><li>è¾“å‡º<ul><li>PlannedStmt</li></ul></li><li>åŠŸèƒ½ç‚¹<ul><li>å®ç°SQLä¼˜åŒ–ï¼Œè¾“å…¥ä¸ºqueryç±»å‹çš„æ•°æ®ç»“æ„ï¼Œè¾“å‡ºä¸ºæ ‘å½¢ç»“æ„çš„planï¼Œ</li></ul></li><li>æ•°æ®ç»“æ„</li></ul><p>cascade
group
expression
node
cost
mem</p><hr><p>è¯­æ³•æ ‘çš„è¡¨ç¤º</p><ol><li>node</li><li>var</li><li>rangetableentry</li><li>rangetableref</li><li>joinexpr</li><li>fromexpr</li><li>query
ä»ä¸Šè¿°çš„è¡¨å’Œå¯¹åº”çš„æ‰“å°çš„æ•°æ®ç»“æ„ï¼Œåˆ†æå…·ä½“çš„ç»“æ„ä½“çš„å®é™…æ“ä½œæ–¹æ³•</li></ol><p>è¯­æ³•æ ‘çš„éå†
1.</p></section><div class=divider></div><div class="flex flex-col md:flex-row justify-between gap-4 py-4"><a role=button class="btn btn-outline h-12" href=/posts/postgres/locks/ title=Locks><ion-icon name=chevron-back></ion-icon><div class="inline-flex flex-col items-start"><span class="text-base-content/60 text-xs font-normal">Previous page</span>
<span class="max-w-48 truncate">Locks</span></div></a><a role=button class="btn btn-outline h-12" href=/posts/postgres/storage/ title="Postgres Storage"><div class="inline-flex flex-col items-end"><span class="text-base-content/60 text-xs font-normal">Next page</span>
<span class="max-w-48 truncate">Postgres Storage</span></div><ion-icon name=chevron-forward></ion-icon></a></div><div class=divider></div><section class=space-y-4><template x-if="['localhost', '127.0.0.1'].indexOf(window.location.hostname) == -1"><article><script src=https://utteranc.es/client.js repo=https://askyx.github.io/ issue-term=og:title theme=github-light crossorigin=anonymous async></script></article></template></section></article></div><div x-data=tocHighlighter() @scroll.window=debouncedScroll class="hidden lg:flex lg:flex-col lg:items-end lg:self-start"><nav id=TableOfContents><ul><li><a href=#paths-and-join-pairs>Paths and Join Pairs</a></li><li><a href=#join-tree-construction>Join Tree Construction</a></li><li><a href=#valid-outer-join-optimizations>Valid OUTER JOIN Optimizations</a></li><li><a href=#pulling-up-subqueries>Pulling Up Subqueries</a></li><li><a href=#optimizer-functions>Optimizer Functions</a></li><li><a href=#optimizer-data-structures>Optimizer Data Structures</a></li><li><a href=#equivalenceclasses>EquivalenceClasses</a></li><li><a href=#pathkeys>PathKeys</a></li><li><a href=#order-of-processing-for-equivalenceclasses-and-pathkeys>Order of processing for EquivalenceClasses and PathKeys</a></li><li><a href=#parameterized-paths>Parameterized Paths</a></li><li><a href=#lateral-subqueries>LATERAL subqueries</a></li><li><a href=#security-level-constraints-on-qual-clauses>Security-level constraints on qual clauses</a></li><li><a href=#post-scanjoin-planning>Post scan/join planning</a></li><li><a href=#parallel-query-and-partial-paths>Parallel Query and Partial Paths</a></li><li><a href=#partitionwise-joins>Partitionwise joins</a></li><li><a href=#partitionwise-aggregatesgrouping>Partitionwise aggregates/grouping</a><ul><li><a href=#paths-and-join-pairs-1>Paths and Join Pairs</a></li><li><a href=#join-tree-construction-1>Join Tree Construction</a></li><li><a href=#ä¼˜åŒ–å™¨ä»£ç ç»†èŠ‚>ä¼˜åŒ–å™¨ä»£ç ç»†èŠ‚</a></li><li><a href=#ä¼˜åŒ–>ä¼˜åŒ–</a></li></ul></li></ul></nav></div></div><footer class="flex justify-between items-center gap-2 px-4 py-12"><div><p>Â© 2016 - 2025 Askyx's Blog</p><p class=text-sm>ğŸŒ±
<span class=text-base-content/60>Powered by <a class=hover:underline href=https://gohugo.io/ target=_blank>Hugo</a> with theme
<a class=hover:underline href=https://github.com/g1eny0ung/hugo-theme-dream target=_blank>Dream</a>.</span></p></div><div x-data="{ icons: [
    { name: 'sunny', status: 'n' },
    { name: 'moon', status: 'y' },
    { name: 'desktop', status: 'auto' }
  ] }" class="flex items-center gap-2 h-[32px] px-2 bg-base-100 border border-base-content/30 rounded-full"><template x-for="icon in icons"><div role=button tabindex=0 :aria-label="'Select ' + icon.name + ' mode'" class="group inline-flex justify-center items-center p-1 rounded-full cursor-pointer hover:bg-primary" :class="$store.darkMode.icon() === icon.name && 'bg-primary'" @click=$store.darkMode.toggle(icon.status)><ion-icon :name="`${icon.name}-outline`" class=group-hover:text-primary-content :class="$store.darkMode.icon() === icon.name && 'text-primary-content'"></ion-icon></div></template></div></footer></div></div><div class=back><div class=container><div class="dream-grid dream-grid-about"><div class="w-full md:w-1/2 lg:w-1/3 xl:w-1/4 p-4 dream-column"><article class="card bg-base-100 hover:bg-base-content/10 shadow-xl dark:border dark:border-base-content/30"><div class=card-body><div class=card-title>About Me</div><div class="prose dark:prose-invert"><p>Hi, my name is Yue Yang.</p><p>This is my blog.</p><h2 id=ãƒ¾Ï‰o>ãƒ¾(â€¢Ï‰â€¢`)o</h2><p>æ¯”è¾ƒèƒ†å°ï¼Œå‡ºé—¨éƒ½å¾—è´´å¢™èµ°</p></div></div></article></div></div><footer class="flex justify-between items-center gap-2 px-4 py-12"><div><p>Â© 2016 - 2025 Askyx's Blog</p><p class=text-sm>ğŸŒ±
<span class=text-base-content/60>Powered by <a class=hover:underline href=https://gohugo.io/ target=_blank>Hugo</a> with theme
<a class=hover:underline href=https://github.com/g1eny0ung/hugo-theme-dream target=_blank>Dream</a>.</span></p></div><div x-data="{ icons: [
    { name: 'sunny', status: 'n' },
    { name: 'moon', status: 'y' },
    { name: 'desktop', status: 'auto' }
  ] }" class="flex items-center gap-2 h-[32px] px-2 bg-base-100 border border-base-content/30 rounded-full"><template x-for="icon in icons"><div role=button tabindex=0 :aria-label="'Select ' + icon.name + ' mode'" class="group inline-flex justify-center items-center p-1 rounded-full cursor-pointer hover:bg-primary" :class="$store.darkMode.icon() === icon.name && 'bg-primary'" @click=$store.darkMode.toggle(icon.status)><ion-icon :name="`${icon.name}-outline`" class=group-hover:text-primary-content :class="$store.darkMode.icon() === icon.name && 'text-primary-content'"></ion-icon></div></template></div></footer></div></div></div></div><script>window.lightTheme="emerald",window.darkTheme="forest"</script><script src=https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin=anonymous></script><script src=/js/grid.min.js></script><script src=/js/main.min.js></script><script src=https://cdn.jsdelivr.net/npm/luxon@1.26.0 integrity="sha256-4sbTzmCCW9LGrIh5OsN8V5Pfdad1F1MwhLAOyXKnsE0=" crossorigin=anonymous></script><script>format();function format(){document.querySelectorAll('span[data-format="luxon"]').forEach(e=>{const t=e.textContent;e.textContent=luxon.DateTime.fromISO(t,{locale:"en"}).toFormat("yyyyå¹´MMæœˆddæ—¥")})}</script><script src=/js/toc.min.js></script><script type=module>
      import mediumZoom from 'https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/+esm';
      mediumZoom('#dream-single-post-content img', {
        background: 'oklch(var(--b1))',
        margin: 24,
      })
    </script><script type=module src=https://cdn.jsdelivr.net/npm/ionicons@7.4.0/dist/ionicons/ionicons.esm.js integrity="sha256-/IFmi82bIhdYWctu0UddSlJqpnzWm7Vh2C4CM32wF/k=" crossorigin=anonymous></script><script nomodule src=https://cdn.jsdelivr.net/npm/ionicons@7.4.0/dist/ionicons/ionicons.js integrity="sha256-mr7eJMX3VC3F7G32mk4oWp1C6a2tlMYxUdptfT7uKI8=" crossorigin=anonymous></script></body></html>