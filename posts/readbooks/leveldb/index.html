<!doctype html><html lang=en>
<head>
<title>
LevelDB源码阅读 ::
Esoye — My note blog
</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="LevelDB: version 1.23 Date: Thu Oct 20 15:32:47 2022 CPU: 16 * AMD Ryzen 9 5900HS with Radeon Graphics CPUCache: 512 KB Keys: 16 bytes each Values: 100 bytes each (50 bytes after compression) Entries: 1000000 RawSize: 110.6 MB (estimated) FileSize: 62.9 MB (estimated) ------------------------------------------------ fillseq : 1.394 micros/op; 79.3 MB/s fillsync : 1208.178 micros/op; 0.1 MB/s (1000 ops) fillrandom : 1.948 micros/op; 56.8 MB/s overwrite : 2.448 micros/op; 45.">
<meta name=keywords content="数据库">
<meta name=robots content="noodp">
<link rel=canonical href=https://select1fromdual.github.io/posts/readbooks/leveldb/>
<link rel=stylesheet href=https://select1fromdual.github.io/assets/style.css>
<link rel=stylesheet href=https://select1fromdual.github.io/style.css>
<link rel=apple-touch-icon-precomposed sizes=144x144 href=https://select1fromdual.github.io/img/apple-touch-icon-144-precomposed.png>
<link rel="shortcut icon" href=https://select1fromdual.github.io/img/favicon.png>
<link href=https://select1fromdual.github.io/assets/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=https://select1fromdual.github.io/assets/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=https://select1fromdual.github.io/assets/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=https://select1fromdual.github.io/assets/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=https://select1fromdual.github.io/assets/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=https://select1fromdual.github.io/assets/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin>
<meta name=twitter:card content="summary">
<meta name=twitter:title content="LevelDB源码阅读">
<meta name=twitter:description content="leveldb 源码总结分析">
<meta property="og:title" content="LevelDB源码阅读">
<meta property="og:description" content="leveldb 源码总结分析">
<meta property="og:type" content="article">
<meta property="og:url" content="https://select1fromdual.github.io/posts/readbooks/leveldb/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-05-15T21:59:53+08:00">
<meta property="article:modified_time" content="2022-05-15T21:59:53+08:00"><meta property="og:site_name" content="Esoye">
</head>
<body class=light-theme>
<div class=container>
<header class=header>
<span class=header__inner>
<a href=/ class=logo style=text-decoration:none>
<span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg>
</span>
<span class=logo__text>Esoye</span>
<span class=logo__cursor></span>
</a>
<span class=header__right>
<nav class=menu>
<ul class="menu__inner menu__inner--desktop">
<li><a href=/archive>Archive</a></li>
</ul>
<ul class="menu__inner menu__inner--mobile">
<li><a href=/archive>Archive</a></li>
</ul>
</nav>
<span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
</span>
<span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg>
</span>
</span>
</span>
</header>
<div class=content>
<div class=post>
<h1 class=post-title>LevelDB源码阅读</h1>
<div class=post-meta>
<span class=post-date>
2022-05-15
</span>
</div>
<span class=post-tags>
<a href=https://select1fromdual.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/>#源码阅读</a>&nbsp;
<a href=https://select1fromdual.github.io/tags/leveldb/>#LevelDB</a>&nbsp;
<a href=https://select1fromdual.github.io/tags/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/>#存储引擎</a>&nbsp;
</span>
<div class=post-content>
<hr>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>LevelDB:    version <span style=color:#ae81ff>1.23</span>
Date:       Thu Oct <span style=color:#ae81ff>20</span> <span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>32</span><span style=color:#f92672>:</span><span style=color:#ae81ff>47</span> <span style=color:#ae81ff>2022</span>
CPU:        <span style=color:#ae81ff>16</span> <span style=color:#f92672>*</span> AMD Ryzen <span style=color:#ae81ff>9</span> <span style=color:#ae81ff>5900</span>HS with Radeon Graphics
CPUCache:   <span style=color:#ae81ff>512</span> KB
Keys:       <span style=color:#ae81ff>16</span> bytes each
Values:     <span style=color:#ae81ff>100</span> bytes each (<span style=color:#ae81ff>50</span> bytes after compression)
Entries:    <span style=color:#ae81ff>1000000</span>
RawSize:    <span style=color:#ae81ff>110.6</span> MB (estimated)
FileSize:   <span style=color:#ae81ff>62.9</span> MB (estimated)
<span style=color:#f92672>------------------------------------------------</span>
fillseq      :       <span style=color:#ae81ff>1.394</span> micros<span style=color:#f92672>/</span>op;   <span style=color:#ae81ff>79.3</span> MB<span style=color:#f92672>/</span>s     
fillsync     :    <span style=color:#ae81ff>1208.178</span> micros<span style=color:#f92672>/</span>op;    <span style=color:#ae81ff>0.1</span> MB<span style=color:#f92672>/</span>s (<span style=color:#ae81ff>1000</span> ops)
fillrandom   :       <span style=color:#ae81ff>1.948</span> micros<span style=color:#f92672>/</span>op;   <span style=color:#ae81ff>56.8</span> MB<span style=color:#f92672>/</span>s     
overwrite    :       <span style=color:#ae81ff>2.448</span> micros<span style=color:#f92672>/</span>op;   <span style=color:#ae81ff>45.2</span> MB<span style=color:#f92672>/</span>s     
readrandom   :       <span style=color:#ae81ff>3.251</span> micros<span style=color:#f92672>/</span>op; (<span style=color:#ae81ff>864322</span> of <span style=color:#ae81ff>1000000</span> found)
readrandom   :       <span style=color:#ae81ff>2.947</span> micros<span style=color:#f92672>/</span>op; (<span style=color:#ae81ff>864083</span> of <span style=color:#ae81ff>1000000</span> found)
readseq      :       <span style=color:#ae81ff>0.126</span> micros<span style=color:#f92672>/</span>op;  <span style=color:#ae81ff>878.1</span> MB<span style=color:#f92672>/</span>s    
readreverse  :       <span style=color:#ae81ff>0.216</span> micros<span style=color:#f92672>/</span>op;  <span style=color:#ae81ff>511.4</span> MB<span style=color:#f92672>/</span>s    
compact      :  <span style=color:#ae81ff>473557.000</span> micros<span style=color:#f92672>/</span>op;
readrandom   :       <span style=color:#ae81ff>2.174</span> micros<span style=color:#f92672>/</span>op; (<span style=color:#ae81ff>864105</span> of <span style=color:#ae81ff>1000000</span> found)
readseq      :       <span style=color:#ae81ff>0.111</span> micros<span style=color:#f92672>/</span>op;  <span style=color:#ae81ff>997.1</span> MB<span style=color:#f92672>/</span>s    
readreverse  :       <span style=color:#ae81ff>0.185</span> micros<span style=color:#f92672>/</span>op;  <span style=color:#ae81ff>598.0</span> MB<span style=color:#f92672>/</span>s    
fill100K     :     <span style=color:#ae81ff>530.603</span> micros<span style=color:#f92672>/</span>op;  <span style=color:#ae81ff>179.8</span> MB<span style=color:#f92672>/</span>s (<span style=color:#ae81ff>1000</span> ops)
crc32c       :       <span style=color:#ae81ff>0.904</span> micros<span style=color:#f92672>/</span>op; <span style=color:#ae81ff>4322.1</span> MB<span style=color:#f92672>/</span>s (<span style=color:#ae81ff>4</span>K per op)
snappycomp   :       <span style=color:#ae81ff>2.353</span> micros<span style=color:#f92672>/</span>op; <span style=color:#ae81ff>1659.9</span> MB<span style=color:#f92672>/</span>s (output: <span style=color:#ae81ff>55.1</span><span style=color:#f92672>%</span>)
snappyuncomp :       <span style=color:#ae81ff>0.390</span> micros<span style=color:#f92672>/</span>op; <span style=color:#ae81ff>10026.4</span> MB<span style=color:#f92672>/</span>s 

</code></pre></div><hr>
<pre><code>read: d019e3605f222ebc5a3a2484a2cb29db537551dd
</code></pre>
<p>小且完整的工业存储实现，其中有许多细节是可以借鉴的。这里没有完整的深入每一行代码，后续会时不时的慢慢补充</p>
<ul>
<li>2022-05-17 初步阅读代码，了解组件及大致执行逻辑</li>
<li>2022-10-20 重读部分代码，感觉自己貌似有了些许长进</li>
</ul>
<h2 id=编译>
编译
<a href=#%e7%bc%96%e8%af%91 class=h-anchor aria-hidden=true>#</a>
</h2>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>git clone --recurse-submodules https://github.com/google/leveldb.git
cd leveldb
</code></pre></div><p><code>VSCode</code>安装<code>cmake</code>插件之后，打开项目，cmake插件自动配置，此时使用<code>shift+p</code>设置<code>cmake: set build target</code>之后，再使用<code>shift+p</code>选择<code>cmake: build</code>即可编译目标模块，d019e3605f222ebc5a3a2484a2cb29db537551dd中测试文件进行了调整，全部合并到<code>leveldb_tests</code>中，调试时按照想要了解的模块，自己注释其他测试文件，重新编译即可。此时可以在文件中断点调试，或者使用gdb调试</p>
<h2 id=slice>
slice
<a href=#slice class=h-anchor aria-hidden=true>#</a>
</h2>
<p>字符串的浅拷贝实现，使用一个指针和指针长度实现，类似c++后来实现的string_view，如果使用string，则在传递数据的时候会进行拷贝操作，有性能损失。另一个目的是为了自主可控，确保数据在传输的过程中不会造成太多的数据副本。所以拷贝构造函数使用的是默认的系统函数，使用浅拷贝</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>Slice(<span style=color:#66d9ef>const</span> Slice<span style=color:#f92672>&amp;</span>) <span style=color:#f92672>=</span> <span style=color:#66d9ef>default</span>;
Slice<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(<span style=color:#66d9ef>const</span> Slice<span style=color:#f92672>&amp;</span>) <span style=color:#f92672>=</span> <span style=color:#66d9ef>default</span>;
</code></pre></div><h2 id=status>
status
<a href=#status class=h-anchor aria-hidden=true>#</a>
</h2>
<p>自定义信息模块，把状态码和状态信息进行压缩，压缩格式如下</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>Status<span style=color:#f92672>::</span>Status(Code code, <span style=color:#66d9ef>const</span> Slice<span style=color:#f92672>&amp;</span> msg, <span style=color:#66d9ef>const</span> Slice<span style=color:#f92672>&amp;</span> msg2) {
  assert(code <span style=color:#f92672>!=</span> kOk);
  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>uint32_t</span> len1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint32_t</span><span style=color:#f92672>&gt;</span>(msg.size());
  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>uint32_t</span> len2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint32_t</span><span style=color:#f92672>&gt;</span>(msg2.size());
  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>uint32_t</span> size <span style=color:#f92672>=</span> len1 <span style=color:#f92672>+</span> (len2 <span style=color:#f92672>?</span> (<span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> len2) <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>);
  <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> result <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>char</span>[size <span style=color:#f92672>+</span> <span style=color:#ae81ff>5</span>];
  std<span style=color:#f92672>::</span>memcpy(result, <span style=color:#f92672>&amp;</span>size, <span style=color:#66d9ef>sizeof</span>(size));
  result[<span style=color:#ae81ff>4</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span>(code);
  std<span style=color:#f92672>::</span>memcpy(result <span style=color:#f92672>+</span> <span style=color:#ae81ff>5</span>, msg.data(), len1);
  <span style=color:#66d9ef>if</span> (len2) {
    result[<span style=color:#ae81ff>5</span> <span style=color:#f92672>+</span> len1] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;:&#39;</span>;
    result[<span style=color:#ae81ff>6</span> <span style=color:#f92672>+</span> len1] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39; &#39;</span>;
    std<span style=color:#f92672>::</span>memcpy(result <span style=color:#f92672>+</span> <span style=color:#ae81ff>7</span> <span style=color:#f92672>+</span> len1, msg2.data(), len2);
  }
  state_ <span style=color:#f92672>=</span> result;
}
</code></pre></div><blockquote>
<p>TIPS: 对于数字，之际拷贝地址可以直接序列化，不需要使用 to_string，取数的时候直接取字节码，然后static_cast就可以了</p>
</blockquote>
<h2 id=数值编码>
数值编码
<a href=#%e6%95%b0%e5%80%bc%e7%bc%96%e7%a0%81 class=h-anchor aria-hidden=true>#</a>
</h2>
<p>leveldb中几乎所有的数据都会和数据格式的编码或多或少的有联系，首先数据的存储不能直接简单的to_string然后存储字符串，其次对于整形的变长编码，他会把数据的二进制编码按7拆分，在每个字节的第一位使用1表示是否为数据的结尾，例如<code>int(1)</code>编码为<code>00000001</code>，<code>11 10101010</code>会编码为<code>10101010 00000111</code>，对应压缩和解压代码如下，变长编码是一种编程技巧，int类型是4字节，long是8字节。当存储的数据小的时候。可以节约空间。并且我们有理由相信，程序中大部分场景使用的是小数字。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>EncodeVarint32</span>(<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> dst, <span style=color:#66d9ef>uint32_t</span> v) {
  <span style=color:#75715e>// Operate on characters as unsigneds
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>*</span> ptr <span style=color:#f92672>=</span> <span style=color:#66d9ef>reinterpret_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>*&gt;</span>(dst);
  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> B <span style=color:#f92672>=</span> <span style=color:#ae81ff>128</span>;
  <span style=color:#66d9ef>if</span> (v <span style=color:#f92672>&lt;</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>7</span>)) {
    <span style=color:#f92672>*</span>(ptr<span style=color:#f92672>++</span>) <span style=color:#f92672>=</span> v;
  } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (v <span style=color:#f92672>&lt;</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>14</span>)) {
    <span style=color:#f92672>*</span>(ptr<span style=color:#f92672>++</span>) <span style=color:#f92672>=</span> v <span style=color:#f92672>|</span> B;
    <span style=color:#f92672>*</span>(ptr<span style=color:#f92672>++</span>) <span style=color:#f92672>=</span> v <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>7</span>;
  } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (v <span style=color:#f92672>&lt;</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>21</span>)) {
    <span style=color:#f92672>*</span>(ptr<span style=color:#f92672>++</span>) <span style=color:#f92672>=</span> v <span style=color:#f92672>|</span> B;
    <span style=color:#f92672>*</span>(ptr<span style=color:#f92672>++</span>) <span style=color:#f92672>=</span> (v <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>7</span>) <span style=color:#f92672>|</span> B;
    <span style=color:#f92672>*</span>(ptr<span style=color:#f92672>++</span>) <span style=color:#f92672>=</span> v <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>14</span>;
  } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (v <span style=color:#f92672>&lt;</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>28</span>)) {

<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> GetVarint32PtrFallback(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> p, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> limit,
                                   <span style=color:#66d9ef>uint32_t</span><span style=color:#f92672>*</span> value) {
  <span style=color:#66d9ef>uint32_t</span> result <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>uint32_t</span> shift <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; shift <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>28</span> <span style=color:#f92672>&amp;&amp;</span> p <span style=color:#f92672>&lt;</span> limit; shift <span style=color:#f92672>+=</span> <span style=color:#ae81ff>7</span>) {
    <span style=color:#66d9ef>uint32_t</span> byte <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(<span style=color:#66d9ef>reinterpret_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>*&gt;</span>(p));
    p<span style=color:#f92672>++</span>;
    <span style=color:#66d9ef>if</span> (byte <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>128</span>) {
      <span style=color:#75715e>// More bytes are present
</span><span style=color:#75715e></span>      result <span style=color:#f92672>|=</span> ((byte <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>127</span>) <span style=color:#f92672>&lt;&lt;</span> shift);
    } <span style=color:#66d9ef>else</span> {
      result <span style=color:#f92672>|=</span> (byte <span style=color:#f92672>&lt;&lt;</span> shift);
      <span style=color:#f92672>*</span>value <span style=color:#f92672>=</span> result;
      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>reinterpret_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*&gt;</span>(p);
    }
  }
  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
}
</code></pre></div><p>除了变长之外，还有定长编码，以及对应的32位，64位的实现等，在实际的数据处理中，会有记录数据长度等操作，就会使用编码操作，把数值编码到数据中。定长编码是直接存储字节序。</p>
<h2 id=arena>
Arena
<a href=#arena class=h-anchor aria-hidden=true>#</a>
</h2>
<p>自定义内存池，设计思路是申请内存和分配内存隔离，申请内存的时候多申请，分配内存的时候从已申请的内存中分配，使用vector维护内存空间，LevelDB中在memtable中使用，理论上可以用在任何想使用的组件中，但是实际上数据变动最多的地方是memtable，所以暂时只发现只有这里使用。</p>
<ul>
<li>对于大空间(大于kBlockSize / 4的空间，大于kBlockSize = 4096)，则直接申请，独占一个block，不受block大小的限制，且不改变之前记录的block的指针状态</li>
<li>对于小空间
<ul>
<li>第一次会申请大小为4k的空间，然后记录当前空间的指针及空间使用情况，然后从空间上分配内存，且空间push到vector中</li>
<li>之后的空间申请如果在当前block上可以继续分配，则在block上直接分配</li>
<li>如果不满足条件，则重新分配，之前残留的空间直接丢弃，且不计入使用空间统计</li>
</ul>
</li>
<li>对于空间的统计情况，使用原子变量<code>std::atomic&lt;size_t> memory_usage_;</code>记录，因为Arena在skiplist中使用的时候，可能有并发的情况</li>
</ul>
<blockquote>
<p>TIPS: 原子类型的细节需要调研</p>
</blockquote>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span> pool <span style=color:#f92672>=</span> area<span style=color:#f92672>-&gt;</span>Allocate(size);               <span style=color:#75715e>// 不对齐的申请
</span><span style=color:#75715e>// char * pool = area-&gt;AllocateAligned(size);     // 申请对齐的空间
</span><span style=color:#75715e></span><span style=color:#66d9ef>auto</span> mem <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> (pool) <span style=color:#66d9ef>char</span>(size);

Allocate(size) {
  <span style=color:#66d9ef>if</span> (size <span style=color:#f92672>&lt;</span> alloc_bytes_remaining_) {
    <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> result <span style=color:#f92672>=</span> alloc_ptr_;
    alloc_ptr_ <span style=color:#f92672>+=</span> bytes;
    alloc_bytes_remaining_ <span style=color:#f92672>-=</span> bytes;
    <span style=color:#66d9ef>return</span> result;
  }
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>AllocateFallback</span>(size);
}
</code></pre></div><h2 id=skiplist>
SkipList
<a href=#skiplist class=h-anchor aria-hidden=true>#</a>
</h2>
<p>来自论文<a href=https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.>Skip lists: a probabilistic alternative to balanced trees</a>，其中介绍了跳表的实现和其他不同结构之间的对比情况，</p>
<blockquote>
<p>需要重修概率论</p>
</blockquote>
<p>跳表使用使用概率均衡的技术，大部分操作都可以实现<code>O(log n)</code>的时间复杂度，可以参考上面的文章，这里总结几个点</p>
<ol>
<li>跳表可以简单的理解为链表的+index的实现，index的目的是为了快速的查找数据</li>
<li>跳表在增加节点的时候，使用概率为0.25来确定使得否增加下一层，在这个概率下，空间需要花费的代价为<code>(cost(node) * 1.33)</code></li>
</ol>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> kBranching <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
  <span style=color:#66d9ef>int</span> height <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
  <span style=color:#66d9ef>while</span> (height <span style=color:#f92672>&lt;</span> kMaxHeight <span style=color:#f92672>&amp;&amp;</span> rnd_.OneIn(kBranching)) {
    height<span style=color:#f92672>++</span>;
  }
</code></pre></div><ol start=3>
<li>查找的时间复杂度可以抽象的理解为二分查找的<code>O(log n)</code></li>
<li>跳表的操作的时间复杂度和红黑树几乎差不多，但是有一点功能是红黑树无法实现的，即<code>range search</code>，红黑树由于结构特性，无法进行类似的操作，跳表可以定位node之后，可以根据node间的链接实现顺序遍历</li>
<li>insert的时候先查找位置，然后按概率计算层高，再进行插入
<img src=/posts/readbooks/images/skiplist.png alt=skiplist></li>
<li>容易实现并发操作，并发的时候只需要对极少的节点加锁即可，但是红黑树由于需要变形旋转需要对整棵树加锁，所以这也是大部分存储使用skiplist的作为memtable的理由之一<br>
1. <a href=https://www.bookstack.cn/read/Cpp_Concurrency_In_Action/README.md>c++并发编程</a><br>
2. 三种并发
<ol>
<li>max_heights_ 使用memory_order_relaxed，skiplist只允许一写多读，max_height_只有写才会改变</li>
<li>insert设置新节点的next，使用NoBarrier_Next和NoBarrier_SetNext操作，此时对node使用memory_order_relaxed操作，此时其他线程无法看见新节点</li>
<li>insert设置新节点的forward，此时使用SetNext的memory_order_release，此时所有线程可以看见新节点 <br>
但是由于skiplist 分层，所以此时只能看见当前插入的这一层，而查询是需要从顶层往下查的，所以insert需要从底层开始，否则可能出现上层查询节点存在，但是下层不存在</li>
</ol>
</li>
<li>leveldb中，skiplist没有delete操作，如果需要实现，则需要实现类似insert中的部分操作，查找到pre，在设置节点即可。</li>
</ol>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Key, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Comparator</span><span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>void</span> SkipList<span style=color:#f92672>&lt;</span>Key, Comparator<span style=color:#f92672>&gt;::</span>Insert(<span style=color:#66d9ef>const</span> Key<span style=color:#f92672>&amp;</span> key) {
  Node<span style=color:#f92672>*</span> prev[kMaxHeight];
  <span style=color:#75715e>// 设置pre，从顶层开始查找，记录的是每一层的当前节点的pre节点
</span><span style=color:#75715e></span>  Node<span style=color:#f92672>*</span> x <span style=color:#f92672>=</span> FindGreaterOrEqual(key, prev);

  assert(x <span style=color:#f92672>==</span> <span style=color:#66d9ef>nullptr</span> <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>Equal(key, x<span style=color:#f92672>-&gt;</span>key));

  <span style=color:#75715e>//   随即高度
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> height <span style=color:#f92672>=</span> RandomHeight();
  <span style=color:#66d9ef>if</span> (height <span style=color:#f92672>&gt;</span> GetMaxHeight()) {
    <span style=color:#75715e>// 如果高度比之前的高，则把prev之前高度节点到height之间的node设置为head_
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> GetMaxHeight(); i <span style=color:#f92672>&lt;</span> height; i<span style=color:#f92672>++</span>) {
      prev[i] <span style=color:#f92672>=</span> head_;
    }
    max_height_.store(height, std<span style=color:#f92672>::</span>memory_order_relaxed);
  }

  x <span style=color:#f92672>=</span> NewNode(key, height);
  <span style=color:#75715e>// 使用height设置当前节点和pre以及next阶段之间的链接
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> height; i<span style=color:#f92672>++</span>) {
    x<span style=color:#f92672>-&gt;</span>NoBarrier_SetNext(i, prev[i]<span style=color:#f92672>-&gt;</span>NoBarrier_Next(i));
    prev[i]<span style=color:#f92672>-&gt;</span>SetNext(i, x);
  }
}
</code></pre></div><ol start=8>
<li><code>std::atomic&lt;Node*> next_[1];</code>，不能是<code>next_[0]</code>，因为0的时候sizeof不计算这位，大小不对，不能是二级指针，因为此时next在后续的使用种，上层next_是nullptr，无法直接操作，只有使用数组提前占位，才可以设置node，自己手写的时候需要注意。也可以再insert的时候注意于head的相对关系。</li>
</ol>
<h2 id=memtable>
MemTable
<a href=#memtable class=h-anchor aria-hidden=true>#</a>
</h2>
<p>SkipList的封装，长期处于内存中，活动的table只有一个，满的之后冻结落盘。基础操作为add和get，使用MemTableIterator访问memtable。<br>
MemTableIterator是SkipList的迭代器的封装。持有一个跳表和node，使用SeekToFirst和SeekToLast定位node之后，开始使用</p>
<ol>
<li>add编码数据和类型以及长度和key等，拼接为一个buffer，然后insert到skiplist中</li>
</ol>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// Format of an entry is concatenation of:
</span><span style=color:#75715e>//  key_size     : varint32 of internal_key.size()
</span><span style=color:#75715e>//  key bytes    : char[internal_key.size()]
</span><span style=color:#75715e>//  tag          : uint64((sequence &lt;&lt; 8) | type)
</span><span style=color:#75715e>//  value_size   : varint32 of value.size()
</span><span style=color:#75715e>//  value bytes  : char[value.size()]
</span></code></pre></div><ol start=2>
<li>使用迭代器seek到node，然后获得数据，解码，判断数据类型</li>
</ol>
<h2 id=dbimpl>
DBImpl
<a href=#dbimpl class=h-anchor aria-hidden=true>#</a>
</h2>
<p>DB的具体实现，对外接口使用DB对象，但是内部实际调用的还是DBImpl实例</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>Status DBImpl<span style=color:#f92672>::</span>Put(<span style=color:#66d9ef>const</span> WriteOptions<span style=color:#f92672>&amp;</span> o, <span style=color:#66d9ef>const</span> Slice<span style=color:#f92672>&amp;</span> key, <span style=color:#66d9ef>const</span> Slice<span style=color:#f92672>&amp;</span> val) {
<span style=color:#66d9ef>return</span> DB<span style=color:#f92672>::</span>Put(o, key, val);
}

Status DBImpl<span style=color:#f92672>::</span>Delete(<span style=color:#66d9ef>const</span> WriteOptions<span style=color:#f92672>&amp;</span> options, <span style=color:#66d9ef>const</span> Slice<span style=color:#f92672>&amp;</span> key) {
<span style=color:#66d9ef>return</span> DB<span style=color:#f92672>::</span>Delete(options, key);
}
</code></pre></div><ol>
<li>新建</li>
<li>恢复</li>
<li>写<br>
1. 使用WriteBatch打包一批写入数据
2. 限制一写多读，WriteBatch会添加到队列，等待写入消耗
3. 写入会有多种中间状况
<ol>
<li>当前正在L0的compact，此时如果不是强制异步写，则需要等待1s让出资源，等待compact完成，但是最多只能等待一次</li>
<li>mem空间不足，需要进行 compact， 等待</li>
<li>L0 SST超过限制，等待compact</li>
</ol>
<blockquote>
<p>这里几条应该是写入的最大的性能瓶颈，RocksDB中应该有解决的方案，后续可以看看他的写入流程</p>
</blockquote>
</li>
<li>读<br>
1. 三层读取。存在读放大的问题<br>
2. 先都memtable
3. 再都inmem
4. 读取L0层
5. 读取其他层
6. 读取文件上的数据的时候使用<code>Version::Get</code>，内部先从L0开始，然后在依次向下读取，能进行key的比对的依据是version中保存文件的FileMetaData</li>
<li>compact</li>
<li>lock机制</li>
</ol>
<h2 id=writebatch>
WriteBatch
<a href=#writebatch class=h-anchor aria-hidden=true>#</a>
</h2>
<p><img src=/posts/readbooks/images/xx.webp alt></p>
<p>写操作的主要操作对象，主要步骤是把操作的数据打包为一个buffer，然后使用<code>WriteBatch::Iterate</code>操作handler实现insert操作，hanle是一个实现put和delete的接口，所以这里是把数据和操作分离了，这里有几点细节</p>
<ol>
<li>WriteBatch的数据格式为 <code>seq|countkey|{type|key|val}</code>，batch添加一个数据的时候，除了正常添加数据，还会count++，用于在<code>WriteBatch::Iterate</code>的时候检测当前批次数据数量是否正确</li>
<li>一个batch的数据只有一个sequence，batch写完之后，数值加一，</li>
<li>有標記控制是否使用使用同步寫。默認為同步寫，異步寫入的速度快，但是可能導致系統崩潰的時候丟數據，所以爲了分攤大量數據的同步寫的cost，這裏設計WriteBatch來打包數據，進行一次同步寫操作，因爲是順序寫入磁盤，所以寫入速度可以接受</li>
<li>写入操作具有原子性，在写数据的时候会先写日志然后再写数据，当写日志之前或者写日志过程中宕机，下次重启时恢复数据库的时候直接丢弃异常日志。或者写完日志之后宕机，系统在下次启动之后都是确保数据的原子性，</li>
</ol>
<h2 id=posixenv>
PosixEnv
<a href=#posixenv class=h-anchor aria-hidden=true>#</a>
</h2>
<p>posix环境资源的实现，继承自env，目的是便于实现不同平台下的代码，</p>
<ul>
<li>线程池，一个简单的例子 <a href=https://github.com/progschj/ThreadPool>https://github.com/progschj/ThreadPool</a></li>
<li>日志</li>
<li>文件</li>
</ul>
<h2 id=wal日志>
WAL日志
<a href=#wal%e6%97%a5%e5%bf%97 class=h-anchor aria-hidden=true>#</a>
</h2>
<blockquote>
<p><a href=https://leveldb-handbook.readthedocs.io/zh/latest/journal.html>https://leveldb-handbook.readthedocs.io/zh/latest/journal.html</a></p>
</blockquote>
<p>日志在写数据之前记录，写完之后立刻flush，之后才是真正的写数据到memtable，日志文件会一直保存，直到数据落盘才删除，即memtable变为immemtable且compact(数据落盘)之后才删除，如果期间系统异常，则日志文件保存，到下次重启之后回复之后才删除，</p>
<p>(log::Writer)<br>
写数据之前需要预写日志，目的是为了保证数据安全，在操作数据异常的时候可以使用日志恢复数据，按block划分，一个block大小为32k，一个block有四种状态</p>
<ol>
<li>kFullType<br>
一个block可以存完数据</li>
<li>kFirstType<br>
一个block存不下数据，标记为第一个block</li>
<li>kLastType<br>
最后一个block</li>
<li>kMiddleType<br>
中间的block</li>
</ol>
<p>每一个block中的数据的组织格式为<code>crc|len(2)|type(1)|values</code>，其中values的数据来自于前面的WriteBatch打包的数据，是一个整体，没有做太多的处理，主要的调用方法为</p>
<ul>
<li>DBImpl::Write</li>
<li>DBImpl::NewDB</li>
<li>VersionSet::LogAndApply</li>
<li>VersionSet::WriteSnapshot</li>
</ul>
<p>(log::Reader)<br>
wal对应的读取操作</p>
<h2 id=lrucache>
LRUCache
<a href=#lrucache class=h-anchor aria-hidden=true>#</a>
</h2>
<blockquote>
<p><a href=https://leveldb-handbook.readthedocs.io/zh/latest/cache.html>https://leveldb-handbook.readthedocs.io/zh/latest/cache.html</a></p>
</blockquote>
<p>缓存模块，测试文件为<code>cache_test.cc</code>。</p>
<ul>
<li>
<p>ShardedLRUCache<br>
LRUHandle的包装，主要原因是LRUHandle的接口都加锁，所以这里使用ShardedLRUCache包装一下，使用16个LRUHandle来管理缓存，以提高并发时候的操作效率。<code>uint32_t Shard(uint32_t hash) { return hash >> (32 - kNumShardBits); }</code>会使用前4个bit计算位置，得到对应的LRUHandle对象，之后的操作使用此对象处理，相当于LRUHandle的hash表。</p>
</li>
<li>
<p>LRUCache</p>
<blockquote>
<p><a href=https://leetcode.cn/problems/lru-cache/>https://leetcode.cn/problems/lru-cache/</a></p>
</blockquote>
<p>LRU的实现，使用HandleTable作为hash表保存的数据。LRUHandle为链表保存数据，主要细节为</p>
<ul>
<li>使用hash表保存数据</li>
<li>使用一个LRUHandle维护使用情况，数据在缓存中的时候，要么只是在缓存中，保存在lru_链表中，或者是使用中的数据，保存在<code>in_use_</code>中</li>
<li>使用引用标记数据的使用，只有当引用为0的时候，才会删除数据，当数据存在在缓存中的时候，引用默认为1，为0则表示不缓存且没有外部引用</li>
<li>对于重复的key，会直接替换</li>
<li>容量不足的时候。替换lru_中的数据，<code>in_use_</code>中的数据不操作</li>
<li>链表在append的时候，总是添加在链表头节点</li>
</ul>
</li>
<li>
<p>LRUHandle<br>
双向链表，在hash表中会保存数据，在LRU中会维护使用情况，</p>
<ul>
<li>remove，直接设置链接，跳过当前节点</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>void</span> LRUCache<span style=color:#f92672>::</span>LRU_Remove(LRUHandle<span style=color:#f92672>*</span> e) {
  e<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> e<span style=color:#f92672>-&gt;</span>prev;
  e<span style=color:#f92672>-&gt;</span>prev<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> e<span style=color:#f92672>-&gt;</span>next;
}
</code></pre></div><ul>
<li>LRU_Append，insert操作，把节点append在链表之前</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>void</span> LRUCache<span style=color:#f92672>::</span>LRU_Append(LRUHandle<span style=color:#f92672>*</span> list, LRUHandle<span style=color:#f92672>*</span> e) {
  <span style=color:#75715e>// Make &#34;e&#34; newest entry by inserting just before *list
</span><span style=color:#75715e></span>  e<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> list;
  e<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> list<span style=color:#f92672>-&gt;</span>prev;
  e<span style=color:#f92672>-&gt;</span>prev<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> e;
  e<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> e;
}
</code></pre></div></li>
<li>
<p>HandleTable
LRUHandle的二维数组，使用连地址法来处理冲突，基础容量为4，rehash按2扩充空间</p>
</li>
</ul>
<p>缓存有两种，一种是用来缓存的打开的SST table的cache，一种是用来缓存使用的block的cache</p>
<h2 id=sst>
SST
<a href=#sst class=h-anchor aria-hidden=true>#</a>
</h2>
<p><img src=/posts/readbooks/images/image.png alt=格式圖>
具體格式如圖，文件最后是footer，保存mata和index的大小和偏移，</p>
<ul>
<li>
<p>footer (<code>Footer::EncodeTo</code>)</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>  int64 <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>|</span> mata
  int64 <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>|</span> index
  padding
  magicnum
</code></pre></div></li>
<li>
<p>BlockBuilder<br>
磁盘读写按照一定大小读取比较有效率，leveldb按照4K大小组织文件，4K为一个block，block按照一个一个的条目编码数据，格式为<code>slen|uslen|vlen|uskey|v</code>，s指的是share，如下的例子</p>
</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>  {
    string key1 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;abcd&#34;</span>, v1 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;vv1vv&#34;</span>;
    string key2 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;abce&#34;</span>, v2 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;vv2vv&#34;</span>;
    string key3 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;abxf&#34;</span>, v3 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;vv3vv&#34;</span>;
    encode <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>5</span> abcd vv1vv <span style=color:#f92672>|</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>5</span> e vv2vv <span style=color:#f92672>|</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>5</span> xf vv3vv}
  }
</code></pre></div><p>第一个记录不编码，第二个和第一个对比，编码存取，key抽取相同的前缀，记录长度，之后的数据都按前一个数据编码，如果数据太多，可能后面的key和之前的key差距比较大，查找的时候只能全部解码然后寻找key，所以设计可以控制每隔固定数量的key存一个完整的key，称为重启点，按重启点划分为不同的group，此时且记录key的偏移，此时查找的时候可以按照偏移取key然后使用二分查找等方式快速查寻。在持久化的时候，block末尾记录group的大小，再使用一个bit记录压缩格式，再使用4个bit记录crc。这就是block的基本格式
除了footer使用单独的编码格式之外。其余的mata，index，data都使用block的格式编码数据，</p>
<ul>
<li>写入流程</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>TableBuilder<span style=color:#f92672>::</span>Add
  <span style=color:#66d9ef>if</span> (r<span style=color:#f92672>-&gt;</span>pending_index_entry)   <span style=color:#75715e>//  新的block设置index
</span><span style=color:#75715e></span>    index_block.Add
  filter_block<span style=color:#f92672>-&gt;</span>AddKey          <span style=color:#75715e>//  设置filter
</span><span style=color:#75715e></span>  data_block.Add                <span style=color:#75715e>// 添加数据到data_block，如果大小达到限制，flush
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (estimated_block_size <span style=color:#f92672>&gt;=</span> r<span style=color:#f92672>-&gt;</span>options.block_size)
    TableBuilder<span style=color:#f92672>::</span>Flush()
      TableBuilder<span style=color:#f92672>::</span>WriteBlock    <span style=color:#75715e>// 写block 
</span><span style=color:#75715e></span>        BlockBuilder<span style=color:#f92672>::</span>Finish      <span style=color:#75715e>// 打包数据，编码group offset
</span><span style=color:#75715e></span>        compression               <span style=color:#75715e>//  压缩
</span><span style=color:#75715e></span>        TableBuilder<span style=color:#f92672>::</span>WriteRawBlock <span style=color:#75715e>//  写压缩之后的数据，设置编码格式和crc
</span><span style=color:#75715e></span>    r<span style=color:#f92672>-&gt;</span>pending_index_entry <span style=color:#f92672>=</span> true;  <span style=color:#75715e>//  设置标记为true，记录index
</span></code></pre></div><ul>
<li>
<p>读取流程<br>
讀取的時候逆向操作，校監crc</p>
</li>
<li>
<p>index
index的一個條目對應的是一個datablock中的最大的key以及block的偏移和大小，key使用FindShortestSeparator計算得出，確保他計算的key是當前保存的datablock中的最大值加1，目的是便於查找</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>  start: abcdef
  limit: abcdgh
  FindShortestSeparator<span style=color:#f92672>--&gt;</span> start <span style=color:#f92672>=</span> abcdf  <span style=color:#75715e>// 公共前綴加1
</span></code></pre></div></li>
</ul>
<hr>
<ul>
<li>immemtable的寫入</li>
</ul>
<blockquote>
<p><a href=https://hardcore.feishu.cn/docs/doccn4w8clvork96K3dqQnJRh9g#>https://hardcore.feishu.cn/docs/doccn4w8clvork96K3dqQnJRh9g#</a>
<a href=https://my.oschina.net/fileoptions/blog/903206>https://my.oschina.net/fileoptions/blog/903206</a></p>
</blockquote>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>
WriteLevel0Table
  {
    mutex_.Unlock();    <span style=color:#75715e>// 不加鎖是因爲immemtable不可變，所以沒有并發問題
</span><span style=color:#75715e></span>    s <span style=color:#f92672>=</span> BuildTable(dbname_, env_, options_, table_cache_, iter, <span style=color:#f92672>&amp;</span>meta);
    BuildTable :{
      <span style=color:#75715e>// get file
</span><span style=color:#75715e></span>      <span style=color:#75715e>// add values
</span><span style=color:#75715e></span>      builder<span style=color:#f92672>-&gt;</span>Add(key, iter<span style=color:#f92672>-&gt;</span>value());
      s <span style=color:#f92672>=</span> builder<span style=color:#f92672>-&gt;</span>Finish();
      Finish: {
        <span style=color:#75715e>// filter
</span><span style=color:#75715e></span>        <span style=color:#75715e>// metaindex
</span><span style=color:#75715e></span>        <span style=color:#75715e>// index
</span><span style=color:#75715e></span>        <span style=color:#75715e>// footer
</span><span style=color:#75715e></span>      }
      file<span style=color:#f92672>-&gt;</span>sync();
      file<span style=color:#f92672>-&gt;</span>close();
    }
    mutex_.Lock();
  }
</code></pre></div><p>具體的細節可以參考代碼的文檔，</p>
<h2 id=迭代器>
迭代器
<a href=#%e8%bf%ad%e4%bb%a3%e5%99%a8 class=h-anchor aria-hidden=true>#</a>
</h2>
<p>訪問特定數據結構的抽象，使數據的訪問和存儲分離，可以參考STL的實現，levelDB中對不同的組件實現不同的迭代器</p>
<ul>
<li>MemTableIterator</li>
<li>LevelFileNumIterator</li>
<li>Block::Iter</li>
</ul>
<h2 id=version>
version
<a href=#version class=h-anchor aria-hidden=true>#</a>
</h2>
<blockquote>
<p><a href=https://leveldb-handbook.readthedocs.io/zh/latest/version.html>https://leveldb-handbook.readthedocs.io/zh/latest/version.html</a></p>
</blockquote>
<p>本质上是使用版本号组成key，用来查询数据，之前数据存放的时候，是有记录seq的，version是专为这种行为设计的系统，<br>
需要管理磁盘文件的版本，不同的版本使用不同的Sequence，key中含有LastSequence信息，所以本质上还是key的查询</p>
<ul>
<li>get<br>
需要读取磁盘中的文件，version中保存FileMetaData，所以可以快速的定位数据的sst，然后直接读取sst，对于L0，由于存在重复key，所以
需要进行key的比较，读取多个文件</li>
</ul>
<h2 id=compact>
compact
<a href=#compact class=h-anchor aria-hidden=true>#</a>
</h2>
<p>定期的数据的整理合并操作</p>
<hr>
<ul>
<li>minor compaction<br>
immemtable持久化为SST，可以手动使用TEST_CompactMemTable触发，主要方式是设置<code>DBImpl::Write</code>的WriteBatch参数为null，此时在<code>MakeRoomForWrite</code>中，会根据参数导致选择compact的分支，会进行CompactMemTable操作，此时之前的数据会固化到文件中。也可以自动触发，当memtable 满了之后，会进行相同的操作。
<ul>
<li>TIPS: 此时version中会保存SST的相关信息，包括beginkey和endkey，以及版本信息</li>
<li>文件不一定是level0，对于大文件，预测level0可能很快到达限制，可以在一定条件下直接把文件放在较高层。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>Major Compaction<br>
sst之间向下合并，其会把相同key的不同版本的数据合并，可以手动使用TEST_CompactRange触发，此时可以选择需要compact的level和start key和endkey，他会把文件向下层合并，这里需要注意的是
<ul>
<li>level0会有重叠的key，compact的时候需要选择beginkey endkey以及他中间覆盖的文件进行compact操作，否则会残留下old key，</li>
<li>sst不一定是向下推一层，可以选择想要合并的层数，对于level 0，使用文件个数计算score，对于其他层，使用文件大小计算</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> level <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; level <span style=color:#f92672>&lt;</span> config<span style=color:#f92672>::</span>kNumLevels <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; level<span style=color:#f92672>++</span>) {
    <span style=color:#66d9ef>double</span> score;
    <span style=color:#66d9ef>if</span> (level <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
    <span style=color:#75715e>// We treat level-0 specially by bounding the number of files
</span><span style=color:#75715e></span>    <span style=color:#75715e>// instead of number of bytes for two reasons:
</span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span><span style=color:#75715e></span>    <span style=color:#75715e>// (1) With larger write-buffer sizes, it is nice not to do too
</span><span style=color:#75715e></span>    <span style=color:#75715e>// many level-0 compactions.
</span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span><span style=color:#75715e></span>    <span style=color:#75715e>// (2) The files in level-0 are merged on every read and
</span><span style=color:#75715e></span>    <span style=color:#75715e>// therefore we wish to avoid too many files when the individual
</span><span style=color:#75715e></span>    <span style=color:#75715e>// file size is small (perhaps because of a small write-buffer
</span><span style=color:#75715e></span>    <span style=color:#75715e>// setting, or very high compression ratios, or lots of
</span><span style=color:#75715e></span>    <span style=color:#75715e>// overwrites/deletions).
</span><span style=color:#75715e></span>    score <span style=color:#f92672>=</span> v<span style=color:#f92672>-&gt;</span>files_[level].size() <span style=color:#f92672>/</span>
          <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>double</span><span style=color:#f92672>&gt;</span>(config<span style=color:#f92672>::</span>kL0_CompactionTrigger);
    } <span style=color:#66d9ef>else</span> {
      <span style=color:#75715e>// Compute the ratio of current size to size limit.
</span><span style=color:#75715e></span>      <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>uint64_t</span> level_bytes <span style=color:#f92672>=</span> TotalFileSize(v<span style=color:#f92672>-&gt;</span>files_[level]);
      score <span style=color:#f92672>=</span>
          <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>double</span><span style=color:#f92672>&gt;</span>(level_bytes) <span style=color:#f92672>/</span> MaxBytesForLevel(options_, level);
    }

    <span style=color:#66d9ef>if</span> (score <span style=color:#f92672>&gt;</span> best_score) {
      best_level <span style=color:#f92672>=</span> level;
      best_score <span style=color:#f92672>=</span> score;
    }
  }
</code></pre></div><ul>
<li>sst记录一个查询次数，当一个文件被查询多次且是无效查询的时候的，当达到一定次数就会触发compcat操作，理由是他可能和其他文件有太多的重复的key，需要被清理以平衡io操作，这里的依据是的一次额外的compact操作的cost和多次的无效seek的均衡。</li>
<li>他的大致逻辑是当前使用的线程设置manual_compaction_信息，然后调用compact线程使用manual_compaction_执行compact操作</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>compact {
  BackgroundCompaction {
    <span style=color:#66d9ef>if</span> (imm_ <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nullptr</span>) {
      CompactMemTable();
      <span style=color:#66d9ef>return</span>;
    }

    Compaction<span style=color:#f92672>*</span> c;
    <span style=color:#66d9ef>if</span> (is_manual) {
      <span style=color:#75715e>// 执行manual compact，优先级最高，获得Compaction
</span><span style=color:#75715e></span>      c <span style=color:#f92672>=</span> versions_<span style=color:#f92672>-&gt;</span>CompactRange(m<span style=color:#f92672>-&gt;</span>level, m<span style=color:#f92672>-&gt;</span>begin, m<span style=color:#f92672>-&gt;</span>end);
    } 

    <span style=color:#66d9ef>if</span> (c <span style=color:#f92672>==</span> <span style=color:#66d9ef>nullptr</span>) {
      <span style=color:#75715e>// 不做处理，不需要compact
</span><span style=color:#75715e></span>    }<span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (<span style=color:#f92672>!</span>is_manual <span style=color:#f92672>&amp;&amp;</span> c<span style=color:#f92672>-&gt;</span>IsTrivialMove()) {
      <span style=color:#75715e>// 仅仅只需要移动文件，例如最开始的时候下层没有需要合并的文件，直接移动文件，修改元数据即可
</span><span style=color:#75715e></span>    } <span style=color:#66d9ef>else</span> {
      <span style=color:#75715e>// 执行compact
</span><span style=color:#75715e></span>      CompactionState<span style=color:#f92672>*</span> compact <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CompactionState(c);
      status <span style=color:#f92672>=</span> DoCompactionWork(compact); 
    }
  }


  <span style=color:#75715e>//  多个文件的合并操作，会处理过期或者需要删除的数据
</span><span style=color:#75715e></span>  DoCompactionWork {
    Iterator<span style=color:#f92672>*</span> input <span style=color:#f92672>=</span> versions_<span style=color:#f92672>-&gt;</span>MakeInputIterator(compact<span style=color:#f92672>-&gt;</span>compaction);
    <span style=color:#66d9ef>while</span> (input<span style=color:#f92672>-&gt;</span>Valid() <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>shutting_down_.load(std<span style=color:#f92672>::</span>memory_order_acquire)) {
      <span style=color:#66d9ef>if</span> (has_imm_.load(std<span style=color:#f92672>::</span>memory_order_relaxed)) {
        <span style=color:#75715e>//  如果有minor compact，则优先处理
</span><span style=color:#75715e></span>      }

      <span style=color:#75715e>// 判断重叠，重叠太多影响查询，直接终止
</span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> compact<span style=color:#f92672>-&gt;</span>compaction<span style=color:#f92672>-&gt;</span>ShouldStopBefore(key)
        <span style=color:#66d9ef>break</span><span style=color:#960050;background-color:#1e0010>；</span>

      <span style=color:#75715e>// 处理key
</span><span style=color:#75715e></span>      {
        <span style=color:#75715e>// 如果是delete
</span><span style=color:#75715e></span>        <span style=color:#75715e>//  或者是sequence小于当前使用中的sequence 
</span><span style=color:#75715e></span>        <span style=color:#75715e>//  或者更高层没有这个key
</span><span style=color:#75715e></span>        drop <span style=color:#f92672>=</span> true;
      }

      <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>drop)
        compact<span style=color:#f92672>-&gt;</span>builder<span style=color:#f92672>-&gt;</span>Add(key, input<span style=color:#f92672>-&gt;</span>value());
    }
  }
}
</code></pre></div></li>
</ul>
<p>由于compact的时候，会占用一定的系统资源，所以如果发生compaction的时候</p>
<ul>
<li>如果是minor compact，则减缓写操作，释放一定的系统资源</li>
<li>如果是Major Compaction，则暂停操作。等待compact任务完成</li>
</ul>
</div>
<div class=pagination>
<div class=pagination__title>
<span class=pagination__title-h>Read other posts</span>
<hr>
</div>
<div class=pagination__buttons>
<span class="button previous">
<a href=https://select1fromdual.github.io/posts/course/6.824/coursenote/>
<span class=button__icon>←</span>
<span class=button__text>Coursenote</span>
</a>
</span>
<span class="button next">
<a href=https://select1fromdual.github.io/posts/readbooks/volcanooptimizer/>
<span class=button__text>VolcanoOptimizer</span>
<span class=button__icon>→</span>
</a>
</span>
</div>
</div>
</div>
</div>
<footer class=footer>
<div class=footer__inner>
<a href=/ class=logo style=text-decoration:none>
<span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg>
</span>
<span class=logo__text>Esoye</span>
<span class=logo__cursor></span>
</a>
<div class=copyright>
<span>© 2022 Powered by
<a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span>
<span>Theme created by
<a href=https://twitter.com/panr target=_blank rel=noopener>panr</a></span>
</div>
</div>
</footer>
<script src=https://select1fromdual.github.io/assets/main.js></script>
<script src=https://select1fromdual.github.io/assets/prism.js></script>
</div>
</body>
</html>