<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>LOCK on Askyx's Blog</title><link>https://askyx.github.io/tags/lock/</link><description>Recent content in LOCK on Askyx's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-Hans</language><lastBuildDate>Wed, 28 Sep 2022 15:42:18 +0800</lastBuildDate><atom:link href="https://askyx.github.io/tags/lock/index.xml" rel="self" type="application/rss+xml"/><item><title>Locks</title><link>https://askyx.github.io/posts/postgres/locks/</link><pubDate>Wed, 28 Sep 2022 15:42:18 +0800</pubDate><guid>https://askyx.github.io/posts/postgres/locks/</guid><description>SpinLock 使用tas实现的自旋锁。 while (TAS_SPIN(lock)) { perform_spin_delay(&amp;amp;delayStatus); } perform_spin_delay(SpinDelayStatus *status) { /* CPU-specific delay each time through the loop */ SPIN_DELAY(); /* Block the process every spins_per_delay tries */ if (++(status-&amp;gt;spins) &amp;gt;= spins_per_delay) { if (++(status-&amp;gt;delays) &amp;gt; NUM_DELAYS) s_lock_stuck(status-&amp;gt;file, status-&amp;gt;line, status-&amp;gt;func); if (status-&amp;gt;cur_delay == 0) /* first time to delay? */ status-&amp;gt;cur_delay = MIN_DELAY_USEC; pg_usleep(status-&amp;gt;cur_delay); /* increase delay by a</description></item></channel></rss>